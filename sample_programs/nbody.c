
// We need to define _GNU_SOURCE before
// _any_ headers files are imported to get
// the usage statistics of a thread (i.e. have RUSAGE_THREAD) on GNU/Linux
// https://manpages.courier-mta.org/htmlman2/getrusage.2.html
#ifndef _GNU_SOURCE // Avoid possible double-definition warning.
#define _GNU_SOURCE
#endif

#ifdef __clang__
#pragma clang diagnostic ignored "-Wunused-function"
#pragma clang diagnostic ignored "-Wunused-variable"
#pragma clang diagnostic ignored "-Wparentheses"
#pragma clang diagnostic ignored "-Wunused-label"
#elif __GNUC__
#pragma GCC diagnostic ignored "-Wunused-function"
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wparentheses"
#pragma GCC diagnostic ignored "-Wunused-label"
#pragma GCC diagnostic ignored "-Wunused-but-set-variable"
#endif

// Headers\n")
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <stdio.h>
#include <float.h>

#ifdef __cplusplus
extern "C" {
#endif

// Initialisation
struct futhark_context_config;
struct futhark_context_config *futhark_context_config_new(void);
void futhark_context_config_free(struct futhark_context_config *cfg);
void futhark_context_config_set_debugging(struct futhark_context_config *cfg,
                                          int flag);
void futhark_context_config_set_profiling(struct futhark_context_config *cfg,
                                          int flag);
void futhark_context_config_set_logging(struct futhark_context_config *cfg,
                                        int flag);
struct futhark_context;
struct futhark_context *futhark_context_new(struct futhark_context_config *cfg);
void futhark_context_free(struct futhark_context *ctx);
int futhark_context_config_set_tuning_param(struct futhark_context_config *cfg,
                                            const char *param_name,
                                            size_t param_value);
int futhark_get_tuning_param_count(void);
const char *futhark_get_tuning_param_name(int);
const char *futhark_get_tuning_param_class(int);

// Arrays
struct futhark_f32_1d;
struct futhark_f32_1d *futhark_new_f32_1d(struct futhark_context *ctx, const
                                          float *data, int64_t dim0);
struct futhark_f32_1d *futhark_new_raw_f32_1d(struct futhark_context *ctx, const
                                              unsigned char *data,
                                              int64_t offset, int64_t dim0);
int futhark_free_f32_1d(struct futhark_context *ctx,
                        struct futhark_f32_1d *arr);
int futhark_values_f32_1d(struct futhark_context *ctx,
                          struct futhark_f32_1d *arr, float *data);
unsigned char *futhark_values_raw_f32_1d(struct futhark_context *ctx,
                                         struct futhark_f32_1d *arr);
const int64_t *futhark_shape_f32_1d(struct futhark_context *ctx,
                                    struct futhark_f32_1d *arr);

// Opaque values


// Entry points
int futhark_entry_main(struct futhark_context *ctx,
                       struct futhark_f32_1d **out0,
                       struct futhark_f32_1d **out1,
                       struct futhark_f32_1d **out2,
                       struct futhark_f32_1d **out3,
                       struct futhark_f32_1d **out4,
                       struct futhark_f32_1d **out5,
                       struct futhark_f32_1d **out6, const int32_t in0, const
                       float in1, const float in2, const
                       struct futhark_f32_1d *in3, const
                       struct futhark_f32_1d *in4, const
                       struct futhark_f32_1d *in5, const
                       struct futhark_f32_1d *in6, const
                       struct futhark_f32_1d *in7, const
                       struct futhark_f32_1d *in8, const
                       struct futhark_f32_1d *in9);

// Miscellaneous
int futhark_context_sync(struct futhark_context *ctx);
char *futhark_context_report(struct futhark_context *ctx);
char *futhark_context_get_error(struct futhark_context *ctx);
void futhark_context_set_logging_file(struct futhark_context *ctx, FILE *f);
void futhark_context_pause_profiling(struct futhark_context *ctx);
void futhark_context_unpause_profiling(struct futhark_context *ctx);
int futhark_context_clear_caches(struct futhark_context *ctx);
#define FUTHARK_BACKEND_c
#define FUTHARK_SUCCESS 0
#define FUTHARK_PROGRAM_ERROR 2
#define FUTHARK_OUT_OF_MEMORY 3

#ifdef __cplusplus
}
#endif

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <math.h>
#include <stdint.h>
// If NDEBUG is set, the assert() macro will do nothing. Since Futhark
// (unfortunately) makes use of assert() for error detection (and even some
// side effects), we want to avoid that.
#undef NDEBUG
#include <assert.h>
#include <stdarg.h>
// Start of util.h.
//
// Various helper functions that are useful in all generated C code.

#include <errno.h>
#include <string.h>

static const char *fut_progname = "(embedded Futhark)";

static void futhark_panic(int eval, const char *fmt, ...) __attribute__((noreturn));
static char* msgprintf(const char *s, ...);
static void* slurp_file(const char *filename, size_t *size);
static int dump_file(const char *file, const void *buf, size_t n);
struct str_builder;
static void str_builder_init(struct str_builder *b);
static void str_builder(struct str_builder *b, const char *s, ...);

static void futhark_panic(int eval, const char *fmt, ...) {
  va_list ap;
  va_start(ap, fmt);
  fprintf(stderr, "%s: ", fut_progname);
  vfprintf(stderr, fmt, ap);
  va_end(ap);
  exit(eval);
}

// For generating arbitrary-sized error messages.  It is the callers
// responsibility to free the buffer at some point.
static char* msgprintf(const char *s, ...) {
  va_list vl;
  va_start(vl, s);
  size_t needed = 1 + (size_t)vsnprintf(NULL, 0, s, vl);
  char *buffer = (char*) malloc(needed);
  va_start(vl, s); // Must re-init.
  vsnprintf(buffer, needed, s, vl);
  return buffer;
}

static inline void check_err(int errval, int sets_errno, const char *fun, int line,
                             const char *msg, ...) {
  if (errval) {
    char errnum[10];

    va_list vl;
    va_start(vl, msg);

    fprintf(stderr, "ERROR: ");
    vfprintf(stderr, msg, vl);
    fprintf(stderr, " in %s() at line %d with error code %s\n",
            fun, line,
            sets_errno ? strerror(errno) : errnum);
    exit(errval);
  }
}

#define CHECK_ERR(err, ...) check_err(err, 0, __func__, __LINE__, __VA_ARGS__)
#define CHECK_ERRNO(err, ...) check_err(err, 1, __func__, __LINE__, __VA_ARGS__)

// Read the rest of an open file into a NUL-terminated string; returns
// NULL on error.
static void* fslurp_file(FILE *f, size_t *size) {
  long start = ftell(f);
  fseek(f, 0, SEEK_END);
  long src_size = ftell(f)-start;
  fseek(f, start, SEEK_SET);
  unsigned char *s = (unsigned char*) malloc((size_t)src_size + 1);
  if (fread(s, 1, (size_t)src_size, f) != (size_t)src_size) {
    free(s);
    s = NULL;
  } else {
    s[src_size] = '\0';
  }

  if (size) {
    *size = (size_t)src_size;
  }

  return s;
}

// Read a file into a NUL-terminated string; returns NULL on error.
static void* slurp_file(const char *filename, size_t *size) {
  FILE *f = fopen(filename, "rb"); // To avoid Windows messing with linebreaks.
  if (f == NULL) return NULL;
  unsigned char *s = fslurp_file(f, size);
  fclose(f);
  return s;
}

// Dump 'n' bytes from 'buf' into the file at the designated location.
// Returns 0 on success.
static int dump_file(const char *file, const void *buf, size_t n) {
  FILE *f = fopen(file, "w");

  if (f == NULL) {
    return 1;
  }

  if (fwrite(buf, sizeof(char), n, f) != n) {
    return 1;
  }

  if (fclose(f) != 0) {
    return 1;
  }

  return 0;
}

struct str_builder {
  char *str;
  size_t capacity; // Size of buffer.
  size_t used; // Bytes used, *not* including final zero.
};

static void str_builder_init(struct str_builder *b) {
  b->capacity = 10;
  b->used = 0;
  b->str = malloc(b->capacity);
  b->str[0] = 0;
}

static void str_builder(struct str_builder *b, const char *s, ...) {
  va_list vl;
  va_start(vl, s);
  size_t needed = (size_t)vsnprintf(NULL, 0, s, vl);

  while (b->capacity < b->used + needed + 1) {
    b->capacity *= 2;
    b->str = realloc(b->str, b->capacity);
  }

  va_start(vl, s); // Must re-init.
  vsnprintf(b->str+b->used, b->capacity-b->used, s, vl);
  b->used += needed;
}

static int lexical_realloc(char **error, unsigned char **ptr, size_t *old_size, size_t new_size) {
  unsigned char *new = realloc(*ptr, new_size);
  if (new == NULL) {
    *error = msgprintf("Failed to allocate memory.\nAttempted allocation: %12lld bytes\n",
                       (long long) new_size);
    return FUTHARK_OUT_OF_MEMORY;
  } else {
    *ptr = new;
    *old_size = new_size;
    return FUTHARK_SUCCESS;
  }
}

// End of util.h.
// Start of half.h.

// Conversion functions are from http://half.sourceforge.net/, but
// translated to C.
//
// Copyright (c) 2012-2021 Christian Rau
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

#ifndef __OPENCL_VERSION__
#define __constant
#endif

__constant static const uint16_t base_table[512] = {
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080, 0x0100,
  0x0200, 0x0400, 0x0800, 0x0C00, 0x1000, 0x1400, 0x1800, 0x1C00, 0x2000, 0x2400, 0x2800, 0x2C00, 0x3000, 0x3400, 0x3800, 0x3C00,
  0x4000, 0x4400, 0x4800, 0x4C00, 0x5000, 0x5400, 0x5800, 0x5C00, 0x6000, 0x6400, 0x6800, 0x6C00, 0x7000, 0x7400, 0x7800, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8001, 0x8002, 0x8004, 0x8008, 0x8010, 0x8020, 0x8040, 0x8080, 0x8100,
  0x8200, 0x8400, 0x8800, 0x8C00, 0x9000, 0x9400, 0x9800, 0x9C00, 0xA000, 0xA400, 0xA800, 0xAC00, 0xB000, 0xB400, 0xB800, 0xBC00,
  0xC000, 0xC400, 0xC800, 0xCC00, 0xD000, 0xD400, 0xD800, 0xDC00, 0xE000, 0xE400, 0xE800, 0xEC00, 0xF000, 0xF400, 0xF800, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00 };

__constant static const unsigned char shift_table[512] = {
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 13,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 13 };

__constant static const uint32_t mantissa_table[2048] = {
  0x00000000, 0x33800000, 0x34000000, 0x34400000, 0x34800000, 0x34A00000, 0x34C00000, 0x34E00000, 0x35000000, 0x35100000, 0x35200000, 0x35300000, 0x35400000, 0x35500000, 0x35600000, 0x35700000,
  0x35800000, 0x35880000, 0x35900000, 0x35980000, 0x35A00000, 0x35A80000, 0x35B00000, 0x35B80000, 0x35C00000, 0x35C80000, 0x35D00000, 0x35D80000, 0x35E00000, 0x35E80000, 0x35F00000, 0x35F80000,
  0x36000000, 0x36040000, 0x36080000, 0x360C0000, 0x36100000, 0x36140000, 0x36180000, 0x361C0000, 0x36200000, 0x36240000, 0x36280000, 0x362C0000, 0x36300000, 0x36340000, 0x36380000, 0x363C0000,
  0x36400000, 0x36440000, 0x36480000, 0x364C0000, 0x36500000, 0x36540000, 0x36580000, 0x365C0000, 0x36600000, 0x36640000, 0x36680000, 0x366C0000, 0x36700000, 0x36740000, 0x36780000, 0x367C0000,
  0x36800000, 0x36820000, 0x36840000, 0x36860000, 0x36880000, 0x368A0000, 0x368C0000, 0x368E0000, 0x36900000, 0x36920000, 0x36940000, 0x36960000, 0x36980000, 0x369A0000, 0x369C0000, 0x369E0000,
  0x36A00000, 0x36A20000, 0x36A40000, 0x36A60000, 0x36A80000, 0x36AA0000, 0x36AC0000, 0x36AE0000, 0x36B00000, 0x36B20000, 0x36B40000, 0x36B60000, 0x36B80000, 0x36BA0000, 0x36BC0000, 0x36BE0000,
  0x36C00000, 0x36C20000, 0x36C40000, 0x36C60000, 0x36C80000, 0x36CA0000, 0x36CC0000, 0x36CE0000, 0x36D00000, 0x36D20000, 0x36D40000, 0x36D60000, 0x36D80000, 0x36DA0000, 0x36DC0000, 0x36DE0000,
  0x36E00000, 0x36E20000, 0x36E40000, 0x36E60000, 0x36E80000, 0x36EA0000, 0x36EC0000, 0x36EE0000, 0x36F00000, 0x36F20000, 0x36F40000, 0x36F60000, 0x36F80000, 0x36FA0000, 0x36FC0000, 0x36FE0000,
  0x37000000, 0x37010000, 0x37020000, 0x37030000, 0x37040000, 0x37050000, 0x37060000, 0x37070000, 0x37080000, 0x37090000, 0x370A0000, 0x370B0000, 0x370C0000, 0x370D0000, 0x370E0000, 0x370F0000,
  0x37100000, 0x37110000, 0x37120000, 0x37130000, 0x37140000, 0x37150000, 0x37160000, 0x37170000, 0x37180000, 0x37190000, 0x371A0000, 0x371B0000, 0x371C0000, 0x371D0000, 0x371E0000, 0x371F0000,
  0x37200000, 0x37210000, 0x37220000, 0x37230000, 0x37240000, 0x37250000, 0x37260000, 0x37270000, 0x37280000, 0x37290000, 0x372A0000, 0x372B0000, 0x372C0000, 0x372D0000, 0x372E0000, 0x372F0000,
  0x37300000, 0x37310000, 0x37320000, 0x37330000, 0x37340000, 0x37350000, 0x37360000, 0x37370000, 0x37380000, 0x37390000, 0x373A0000, 0x373B0000, 0x373C0000, 0x373D0000, 0x373E0000, 0x373F0000,
  0x37400000, 0x37410000, 0x37420000, 0x37430000, 0x37440000, 0x37450000, 0x37460000, 0x37470000, 0x37480000, 0x37490000, 0x374A0000, 0x374B0000, 0x374C0000, 0x374D0000, 0x374E0000, 0x374F0000,
  0x37500000, 0x37510000, 0x37520000, 0x37530000, 0x37540000, 0x37550000, 0x37560000, 0x37570000, 0x37580000, 0x37590000, 0x375A0000, 0x375B0000, 0x375C0000, 0x375D0000, 0x375E0000, 0x375F0000,
  0x37600000, 0x37610000, 0x37620000, 0x37630000, 0x37640000, 0x37650000, 0x37660000, 0x37670000, 0x37680000, 0x37690000, 0x376A0000, 0x376B0000, 0x376C0000, 0x376D0000, 0x376E0000, 0x376F0000,
  0x37700000, 0x37710000, 0x37720000, 0x37730000, 0x37740000, 0x37750000, 0x37760000, 0x37770000, 0x37780000, 0x37790000, 0x377A0000, 0x377B0000, 0x377C0000, 0x377D0000, 0x377E0000, 0x377F0000,
  0x37800000, 0x37808000, 0x37810000, 0x37818000, 0x37820000, 0x37828000, 0x37830000, 0x37838000, 0x37840000, 0x37848000, 0x37850000, 0x37858000, 0x37860000, 0x37868000, 0x37870000, 0x37878000,
  0x37880000, 0x37888000, 0x37890000, 0x37898000, 0x378A0000, 0x378A8000, 0x378B0000, 0x378B8000, 0x378C0000, 0x378C8000, 0x378D0000, 0x378D8000, 0x378E0000, 0x378E8000, 0x378F0000, 0x378F8000,
  0x37900000, 0x37908000, 0x37910000, 0x37918000, 0x37920000, 0x37928000, 0x37930000, 0x37938000, 0x37940000, 0x37948000, 0x37950000, 0x37958000, 0x37960000, 0x37968000, 0x37970000, 0x37978000,
  0x37980000, 0x37988000, 0x37990000, 0x37998000, 0x379A0000, 0x379A8000, 0x379B0000, 0x379B8000, 0x379C0000, 0x379C8000, 0x379D0000, 0x379D8000, 0x379E0000, 0x379E8000, 0x379F0000, 0x379F8000,
  0x37A00000, 0x37A08000, 0x37A10000, 0x37A18000, 0x37A20000, 0x37A28000, 0x37A30000, 0x37A38000, 0x37A40000, 0x37A48000, 0x37A50000, 0x37A58000, 0x37A60000, 0x37A68000, 0x37A70000, 0x37A78000,
  0x37A80000, 0x37A88000, 0x37A90000, 0x37A98000, 0x37AA0000, 0x37AA8000, 0x37AB0000, 0x37AB8000, 0x37AC0000, 0x37AC8000, 0x37AD0000, 0x37AD8000, 0x37AE0000, 0x37AE8000, 0x37AF0000, 0x37AF8000,
  0x37B00000, 0x37B08000, 0x37B10000, 0x37B18000, 0x37B20000, 0x37B28000, 0x37B30000, 0x37B38000, 0x37B40000, 0x37B48000, 0x37B50000, 0x37B58000, 0x37B60000, 0x37B68000, 0x37B70000, 0x37B78000,
  0x37B80000, 0x37B88000, 0x37B90000, 0x37B98000, 0x37BA0000, 0x37BA8000, 0x37BB0000, 0x37BB8000, 0x37BC0000, 0x37BC8000, 0x37BD0000, 0x37BD8000, 0x37BE0000, 0x37BE8000, 0x37BF0000, 0x37BF8000,
  0x37C00000, 0x37C08000, 0x37C10000, 0x37C18000, 0x37C20000, 0x37C28000, 0x37C30000, 0x37C38000, 0x37C40000, 0x37C48000, 0x37C50000, 0x37C58000, 0x37C60000, 0x37C68000, 0x37C70000, 0x37C78000,
  0x37C80000, 0x37C88000, 0x37C90000, 0x37C98000, 0x37CA0000, 0x37CA8000, 0x37CB0000, 0x37CB8000, 0x37CC0000, 0x37CC8000, 0x37CD0000, 0x37CD8000, 0x37CE0000, 0x37CE8000, 0x37CF0000, 0x37CF8000,
  0x37D00000, 0x37D08000, 0x37D10000, 0x37D18000, 0x37D20000, 0x37D28000, 0x37D30000, 0x37D38000, 0x37D40000, 0x37D48000, 0x37D50000, 0x37D58000, 0x37D60000, 0x37D68000, 0x37D70000, 0x37D78000,
  0x37D80000, 0x37D88000, 0x37D90000, 0x37D98000, 0x37DA0000, 0x37DA8000, 0x37DB0000, 0x37DB8000, 0x37DC0000, 0x37DC8000, 0x37DD0000, 0x37DD8000, 0x37DE0000, 0x37DE8000, 0x37DF0000, 0x37DF8000,
  0x37E00000, 0x37E08000, 0x37E10000, 0x37E18000, 0x37E20000, 0x37E28000, 0x37E30000, 0x37E38000, 0x37E40000, 0x37E48000, 0x37E50000, 0x37E58000, 0x37E60000, 0x37E68000, 0x37E70000, 0x37E78000,
  0x37E80000, 0x37E88000, 0x37E90000, 0x37E98000, 0x37EA0000, 0x37EA8000, 0x37EB0000, 0x37EB8000, 0x37EC0000, 0x37EC8000, 0x37ED0000, 0x37ED8000, 0x37EE0000, 0x37EE8000, 0x37EF0000, 0x37EF8000,
  0x37F00000, 0x37F08000, 0x37F10000, 0x37F18000, 0x37F20000, 0x37F28000, 0x37F30000, 0x37F38000, 0x37F40000, 0x37F48000, 0x37F50000, 0x37F58000, 0x37F60000, 0x37F68000, 0x37F70000, 0x37F78000,
  0x37F80000, 0x37F88000, 0x37F90000, 0x37F98000, 0x37FA0000, 0x37FA8000, 0x37FB0000, 0x37FB8000, 0x37FC0000, 0x37FC8000, 0x37FD0000, 0x37FD8000, 0x37FE0000, 0x37FE8000, 0x37FF0000, 0x37FF8000,
  0x38000000, 0x38004000, 0x38008000, 0x3800C000, 0x38010000, 0x38014000, 0x38018000, 0x3801C000, 0x38020000, 0x38024000, 0x38028000, 0x3802C000, 0x38030000, 0x38034000, 0x38038000, 0x3803C000,
  0x38040000, 0x38044000, 0x38048000, 0x3804C000, 0x38050000, 0x38054000, 0x38058000, 0x3805C000, 0x38060000, 0x38064000, 0x38068000, 0x3806C000, 0x38070000, 0x38074000, 0x38078000, 0x3807C000,
  0x38080000, 0x38084000, 0x38088000, 0x3808C000, 0x38090000, 0x38094000, 0x38098000, 0x3809C000, 0x380A0000, 0x380A4000, 0x380A8000, 0x380AC000, 0x380B0000, 0x380B4000, 0x380B8000, 0x380BC000,
  0x380C0000, 0x380C4000, 0x380C8000, 0x380CC000, 0x380D0000, 0x380D4000, 0x380D8000, 0x380DC000, 0x380E0000, 0x380E4000, 0x380E8000, 0x380EC000, 0x380F0000, 0x380F4000, 0x380F8000, 0x380FC000,
  0x38100000, 0x38104000, 0x38108000, 0x3810C000, 0x38110000, 0x38114000, 0x38118000, 0x3811C000, 0x38120000, 0x38124000, 0x38128000, 0x3812C000, 0x38130000, 0x38134000, 0x38138000, 0x3813C000,
  0x38140000, 0x38144000, 0x38148000, 0x3814C000, 0x38150000, 0x38154000, 0x38158000, 0x3815C000, 0x38160000, 0x38164000, 0x38168000, 0x3816C000, 0x38170000, 0x38174000, 0x38178000, 0x3817C000,
  0x38180000, 0x38184000, 0x38188000, 0x3818C000, 0x38190000, 0x38194000, 0x38198000, 0x3819C000, 0x381A0000, 0x381A4000, 0x381A8000, 0x381AC000, 0x381B0000, 0x381B4000, 0x381B8000, 0x381BC000,
  0x381C0000, 0x381C4000, 0x381C8000, 0x381CC000, 0x381D0000, 0x381D4000, 0x381D8000, 0x381DC000, 0x381E0000, 0x381E4000, 0x381E8000, 0x381EC000, 0x381F0000, 0x381F4000, 0x381F8000, 0x381FC000,
  0x38200000, 0x38204000, 0x38208000, 0x3820C000, 0x38210000, 0x38214000, 0x38218000, 0x3821C000, 0x38220000, 0x38224000, 0x38228000, 0x3822C000, 0x38230000, 0x38234000, 0x38238000, 0x3823C000,
  0x38240000, 0x38244000, 0x38248000, 0x3824C000, 0x38250000, 0x38254000, 0x38258000, 0x3825C000, 0x38260000, 0x38264000, 0x38268000, 0x3826C000, 0x38270000, 0x38274000, 0x38278000, 0x3827C000,
  0x38280000, 0x38284000, 0x38288000, 0x3828C000, 0x38290000, 0x38294000, 0x38298000, 0x3829C000, 0x382A0000, 0x382A4000, 0x382A8000, 0x382AC000, 0x382B0000, 0x382B4000, 0x382B8000, 0x382BC000,
  0x382C0000, 0x382C4000, 0x382C8000, 0x382CC000, 0x382D0000, 0x382D4000, 0x382D8000, 0x382DC000, 0x382E0000, 0x382E4000, 0x382E8000, 0x382EC000, 0x382F0000, 0x382F4000, 0x382F8000, 0x382FC000,
  0x38300000, 0x38304000, 0x38308000, 0x3830C000, 0x38310000, 0x38314000, 0x38318000, 0x3831C000, 0x38320000, 0x38324000, 0x38328000, 0x3832C000, 0x38330000, 0x38334000, 0x38338000, 0x3833C000,
  0x38340000, 0x38344000, 0x38348000, 0x3834C000, 0x38350000, 0x38354000, 0x38358000, 0x3835C000, 0x38360000, 0x38364000, 0x38368000, 0x3836C000, 0x38370000, 0x38374000, 0x38378000, 0x3837C000,
  0x38380000, 0x38384000, 0x38388000, 0x3838C000, 0x38390000, 0x38394000, 0x38398000, 0x3839C000, 0x383A0000, 0x383A4000, 0x383A8000, 0x383AC000, 0x383B0000, 0x383B4000, 0x383B8000, 0x383BC000,
  0x383C0000, 0x383C4000, 0x383C8000, 0x383CC000, 0x383D0000, 0x383D4000, 0x383D8000, 0x383DC000, 0x383E0000, 0x383E4000, 0x383E8000, 0x383EC000, 0x383F0000, 0x383F4000, 0x383F8000, 0x383FC000,
  0x38400000, 0x38404000, 0x38408000, 0x3840C000, 0x38410000, 0x38414000, 0x38418000, 0x3841C000, 0x38420000, 0x38424000, 0x38428000, 0x3842C000, 0x38430000, 0x38434000, 0x38438000, 0x3843C000,
  0x38440000, 0x38444000, 0x38448000, 0x3844C000, 0x38450000, 0x38454000, 0x38458000, 0x3845C000, 0x38460000, 0x38464000, 0x38468000, 0x3846C000, 0x38470000, 0x38474000, 0x38478000, 0x3847C000,
  0x38480000, 0x38484000, 0x38488000, 0x3848C000, 0x38490000, 0x38494000, 0x38498000, 0x3849C000, 0x384A0000, 0x384A4000, 0x384A8000, 0x384AC000, 0x384B0000, 0x384B4000, 0x384B8000, 0x384BC000,
  0x384C0000, 0x384C4000, 0x384C8000, 0x384CC000, 0x384D0000, 0x384D4000, 0x384D8000, 0x384DC000, 0x384E0000, 0x384E4000, 0x384E8000, 0x384EC000, 0x384F0000, 0x384F4000, 0x384F8000, 0x384FC000,
  0x38500000, 0x38504000, 0x38508000, 0x3850C000, 0x38510000, 0x38514000, 0x38518000, 0x3851C000, 0x38520000, 0x38524000, 0x38528000, 0x3852C000, 0x38530000, 0x38534000, 0x38538000, 0x3853C000,
  0x38540000, 0x38544000, 0x38548000, 0x3854C000, 0x38550000, 0x38554000, 0x38558000, 0x3855C000, 0x38560000, 0x38564000, 0x38568000, 0x3856C000, 0x38570000, 0x38574000, 0x38578000, 0x3857C000,
  0x38580000, 0x38584000, 0x38588000, 0x3858C000, 0x38590000, 0x38594000, 0x38598000, 0x3859C000, 0x385A0000, 0x385A4000, 0x385A8000, 0x385AC000, 0x385B0000, 0x385B4000, 0x385B8000, 0x385BC000,
  0x385C0000, 0x385C4000, 0x385C8000, 0x385CC000, 0x385D0000, 0x385D4000, 0x385D8000, 0x385DC000, 0x385E0000, 0x385E4000, 0x385E8000, 0x385EC000, 0x385F0000, 0x385F4000, 0x385F8000, 0x385FC000,
  0x38600000, 0x38604000, 0x38608000, 0x3860C000, 0x38610000, 0x38614000, 0x38618000, 0x3861C000, 0x38620000, 0x38624000, 0x38628000, 0x3862C000, 0x38630000, 0x38634000, 0x38638000, 0x3863C000,
  0x38640000, 0x38644000, 0x38648000, 0x3864C000, 0x38650000, 0x38654000, 0x38658000, 0x3865C000, 0x38660000, 0x38664000, 0x38668000, 0x3866C000, 0x38670000, 0x38674000, 0x38678000, 0x3867C000,
  0x38680000, 0x38684000, 0x38688000, 0x3868C000, 0x38690000, 0x38694000, 0x38698000, 0x3869C000, 0x386A0000, 0x386A4000, 0x386A8000, 0x386AC000, 0x386B0000, 0x386B4000, 0x386B8000, 0x386BC000,
  0x386C0000, 0x386C4000, 0x386C8000, 0x386CC000, 0x386D0000, 0x386D4000, 0x386D8000, 0x386DC000, 0x386E0000, 0x386E4000, 0x386E8000, 0x386EC000, 0x386F0000, 0x386F4000, 0x386F8000, 0x386FC000,
  0x38700000, 0x38704000, 0x38708000, 0x3870C000, 0x38710000, 0x38714000, 0x38718000, 0x3871C000, 0x38720000, 0x38724000, 0x38728000, 0x3872C000, 0x38730000, 0x38734000, 0x38738000, 0x3873C000,
  0x38740000, 0x38744000, 0x38748000, 0x3874C000, 0x38750000, 0x38754000, 0x38758000, 0x3875C000, 0x38760000, 0x38764000, 0x38768000, 0x3876C000, 0x38770000, 0x38774000, 0x38778000, 0x3877C000,
  0x38780000, 0x38784000, 0x38788000, 0x3878C000, 0x38790000, 0x38794000, 0x38798000, 0x3879C000, 0x387A0000, 0x387A4000, 0x387A8000, 0x387AC000, 0x387B0000, 0x387B4000, 0x387B8000, 0x387BC000,
  0x387C0000, 0x387C4000, 0x387C8000, 0x387CC000, 0x387D0000, 0x387D4000, 0x387D8000, 0x387DC000, 0x387E0000, 0x387E4000, 0x387E8000, 0x387EC000, 0x387F0000, 0x387F4000, 0x387F8000, 0x387FC000,
  0x38000000, 0x38002000, 0x38004000, 0x38006000, 0x38008000, 0x3800A000, 0x3800C000, 0x3800E000, 0x38010000, 0x38012000, 0x38014000, 0x38016000, 0x38018000, 0x3801A000, 0x3801C000, 0x3801E000,
  0x38020000, 0x38022000, 0x38024000, 0x38026000, 0x38028000, 0x3802A000, 0x3802C000, 0x3802E000, 0x38030000, 0x38032000, 0x38034000, 0x38036000, 0x38038000, 0x3803A000, 0x3803C000, 0x3803E000,
  0x38040000, 0x38042000, 0x38044000, 0x38046000, 0x38048000, 0x3804A000, 0x3804C000, 0x3804E000, 0x38050000, 0x38052000, 0x38054000, 0x38056000, 0x38058000, 0x3805A000, 0x3805C000, 0x3805E000,
  0x38060000, 0x38062000, 0x38064000, 0x38066000, 0x38068000, 0x3806A000, 0x3806C000, 0x3806E000, 0x38070000, 0x38072000, 0x38074000, 0x38076000, 0x38078000, 0x3807A000, 0x3807C000, 0x3807E000,
  0x38080000, 0x38082000, 0x38084000, 0x38086000, 0x38088000, 0x3808A000, 0x3808C000, 0x3808E000, 0x38090000, 0x38092000, 0x38094000, 0x38096000, 0x38098000, 0x3809A000, 0x3809C000, 0x3809E000,
  0x380A0000, 0x380A2000, 0x380A4000, 0x380A6000, 0x380A8000, 0x380AA000, 0x380AC000, 0x380AE000, 0x380B0000, 0x380B2000, 0x380B4000, 0x380B6000, 0x380B8000, 0x380BA000, 0x380BC000, 0x380BE000,
  0x380C0000, 0x380C2000, 0x380C4000, 0x380C6000, 0x380C8000, 0x380CA000, 0x380CC000, 0x380CE000, 0x380D0000, 0x380D2000, 0x380D4000, 0x380D6000, 0x380D8000, 0x380DA000, 0x380DC000, 0x380DE000,
  0x380E0000, 0x380E2000, 0x380E4000, 0x380E6000, 0x380E8000, 0x380EA000, 0x380EC000, 0x380EE000, 0x380F0000, 0x380F2000, 0x380F4000, 0x380F6000, 0x380F8000, 0x380FA000, 0x380FC000, 0x380FE000,
  0x38100000, 0x38102000, 0x38104000, 0x38106000, 0x38108000, 0x3810A000, 0x3810C000, 0x3810E000, 0x38110000, 0x38112000, 0x38114000, 0x38116000, 0x38118000, 0x3811A000, 0x3811C000, 0x3811E000,
  0x38120000, 0x38122000, 0x38124000, 0x38126000, 0x38128000, 0x3812A000, 0x3812C000, 0x3812E000, 0x38130000, 0x38132000, 0x38134000, 0x38136000, 0x38138000, 0x3813A000, 0x3813C000, 0x3813E000,
  0x38140000, 0x38142000, 0x38144000, 0x38146000, 0x38148000, 0x3814A000, 0x3814C000, 0x3814E000, 0x38150000, 0x38152000, 0x38154000, 0x38156000, 0x38158000, 0x3815A000, 0x3815C000, 0x3815E000,
  0x38160000, 0x38162000, 0x38164000, 0x38166000, 0x38168000, 0x3816A000, 0x3816C000, 0x3816E000, 0x38170000, 0x38172000, 0x38174000, 0x38176000, 0x38178000, 0x3817A000, 0x3817C000, 0x3817E000,
  0x38180000, 0x38182000, 0x38184000, 0x38186000, 0x38188000, 0x3818A000, 0x3818C000, 0x3818E000, 0x38190000, 0x38192000, 0x38194000, 0x38196000, 0x38198000, 0x3819A000, 0x3819C000, 0x3819E000,
  0x381A0000, 0x381A2000, 0x381A4000, 0x381A6000, 0x381A8000, 0x381AA000, 0x381AC000, 0x381AE000, 0x381B0000, 0x381B2000, 0x381B4000, 0x381B6000, 0x381B8000, 0x381BA000, 0x381BC000, 0x381BE000,
  0x381C0000, 0x381C2000, 0x381C4000, 0x381C6000, 0x381C8000, 0x381CA000, 0x381CC000, 0x381CE000, 0x381D0000, 0x381D2000, 0x381D4000, 0x381D6000, 0x381D8000, 0x381DA000, 0x381DC000, 0x381DE000,
  0x381E0000, 0x381E2000, 0x381E4000, 0x381E6000, 0x381E8000, 0x381EA000, 0x381EC000, 0x381EE000, 0x381F0000, 0x381F2000, 0x381F4000, 0x381F6000, 0x381F8000, 0x381FA000, 0x381FC000, 0x381FE000,
  0x38200000, 0x38202000, 0x38204000, 0x38206000, 0x38208000, 0x3820A000, 0x3820C000, 0x3820E000, 0x38210000, 0x38212000, 0x38214000, 0x38216000, 0x38218000, 0x3821A000, 0x3821C000, 0x3821E000,
  0x38220000, 0x38222000, 0x38224000, 0x38226000, 0x38228000, 0x3822A000, 0x3822C000, 0x3822E000, 0x38230000, 0x38232000, 0x38234000, 0x38236000, 0x38238000, 0x3823A000, 0x3823C000, 0x3823E000,
  0x38240000, 0x38242000, 0x38244000, 0x38246000, 0x38248000, 0x3824A000, 0x3824C000, 0x3824E000, 0x38250000, 0x38252000, 0x38254000, 0x38256000, 0x38258000, 0x3825A000, 0x3825C000, 0x3825E000,
  0x38260000, 0x38262000, 0x38264000, 0x38266000, 0x38268000, 0x3826A000, 0x3826C000, 0x3826E000, 0x38270000, 0x38272000, 0x38274000, 0x38276000, 0x38278000, 0x3827A000, 0x3827C000, 0x3827E000,
  0x38280000, 0x38282000, 0x38284000, 0x38286000, 0x38288000, 0x3828A000, 0x3828C000, 0x3828E000, 0x38290000, 0x38292000, 0x38294000, 0x38296000, 0x38298000, 0x3829A000, 0x3829C000, 0x3829E000,
  0x382A0000, 0x382A2000, 0x382A4000, 0x382A6000, 0x382A8000, 0x382AA000, 0x382AC000, 0x382AE000, 0x382B0000, 0x382B2000, 0x382B4000, 0x382B6000, 0x382B8000, 0x382BA000, 0x382BC000, 0x382BE000,
  0x382C0000, 0x382C2000, 0x382C4000, 0x382C6000, 0x382C8000, 0x382CA000, 0x382CC000, 0x382CE000, 0x382D0000, 0x382D2000, 0x382D4000, 0x382D6000, 0x382D8000, 0x382DA000, 0x382DC000, 0x382DE000,
  0x382E0000, 0x382E2000, 0x382E4000, 0x382E6000, 0x382E8000, 0x382EA000, 0x382EC000, 0x382EE000, 0x382F0000, 0x382F2000, 0x382F4000, 0x382F6000, 0x382F8000, 0x382FA000, 0x382FC000, 0x382FE000,
  0x38300000, 0x38302000, 0x38304000, 0x38306000, 0x38308000, 0x3830A000, 0x3830C000, 0x3830E000, 0x38310000, 0x38312000, 0x38314000, 0x38316000, 0x38318000, 0x3831A000, 0x3831C000, 0x3831E000,
  0x38320000, 0x38322000, 0x38324000, 0x38326000, 0x38328000, 0x3832A000, 0x3832C000, 0x3832E000, 0x38330000, 0x38332000, 0x38334000, 0x38336000, 0x38338000, 0x3833A000, 0x3833C000, 0x3833E000,
  0x38340000, 0x38342000, 0x38344000, 0x38346000, 0x38348000, 0x3834A000, 0x3834C000, 0x3834E000, 0x38350000, 0x38352000, 0x38354000, 0x38356000, 0x38358000, 0x3835A000, 0x3835C000, 0x3835E000,
  0x38360000, 0x38362000, 0x38364000, 0x38366000, 0x38368000, 0x3836A000, 0x3836C000, 0x3836E000, 0x38370000, 0x38372000, 0x38374000, 0x38376000, 0x38378000, 0x3837A000, 0x3837C000, 0x3837E000,
  0x38380000, 0x38382000, 0x38384000, 0x38386000, 0x38388000, 0x3838A000, 0x3838C000, 0x3838E000, 0x38390000, 0x38392000, 0x38394000, 0x38396000, 0x38398000, 0x3839A000, 0x3839C000, 0x3839E000,
  0x383A0000, 0x383A2000, 0x383A4000, 0x383A6000, 0x383A8000, 0x383AA000, 0x383AC000, 0x383AE000, 0x383B0000, 0x383B2000, 0x383B4000, 0x383B6000, 0x383B8000, 0x383BA000, 0x383BC000, 0x383BE000,
  0x383C0000, 0x383C2000, 0x383C4000, 0x383C6000, 0x383C8000, 0x383CA000, 0x383CC000, 0x383CE000, 0x383D0000, 0x383D2000, 0x383D4000, 0x383D6000, 0x383D8000, 0x383DA000, 0x383DC000, 0x383DE000,
  0x383E0000, 0x383E2000, 0x383E4000, 0x383E6000, 0x383E8000, 0x383EA000, 0x383EC000, 0x383EE000, 0x383F0000, 0x383F2000, 0x383F4000, 0x383F6000, 0x383F8000, 0x383FA000, 0x383FC000, 0x383FE000,
  0x38400000, 0x38402000, 0x38404000, 0x38406000, 0x38408000, 0x3840A000, 0x3840C000, 0x3840E000, 0x38410000, 0x38412000, 0x38414000, 0x38416000, 0x38418000, 0x3841A000, 0x3841C000, 0x3841E000,
  0x38420000, 0x38422000, 0x38424000, 0x38426000, 0x38428000, 0x3842A000, 0x3842C000, 0x3842E000, 0x38430000, 0x38432000, 0x38434000, 0x38436000, 0x38438000, 0x3843A000, 0x3843C000, 0x3843E000,
  0x38440000, 0x38442000, 0x38444000, 0x38446000, 0x38448000, 0x3844A000, 0x3844C000, 0x3844E000, 0x38450000, 0x38452000, 0x38454000, 0x38456000, 0x38458000, 0x3845A000, 0x3845C000, 0x3845E000,
  0x38460000, 0x38462000, 0x38464000, 0x38466000, 0x38468000, 0x3846A000, 0x3846C000, 0x3846E000, 0x38470000, 0x38472000, 0x38474000, 0x38476000, 0x38478000, 0x3847A000, 0x3847C000, 0x3847E000,
  0x38480000, 0x38482000, 0x38484000, 0x38486000, 0x38488000, 0x3848A000, 0x3848C000, 0x3848E000, 0x38490000, 0x38492000, 0x38494000, 0x38496000, 0x38498000, 0x3849A000, 0x3849C000, 0x3849E000,
  0x384A0000, 0x384A2000, 0x384A4000, 0x384A6000, 0x384A8000, 0x384AA000, 0x384AC000, 0x384AE000, 0x384B0000, 0x384B2000, 0x384B4000, 0x384B6000, 0x384B8000, 0x384BA000, 0x384BC000, 0x384BE000,
  0x384C0000, 0x384C2000, 0x384C4000, 0x384C6000, 0x384C8000, 0x384CA000, 0x384CC000, 0x384CE000, 0x384D0000, 0x384D2000, 0x384D4000, 0x384D6000, 0x384D8000, 0x384DA000, 0x384DC000, 0x384DE000,
  0x384E0000, 0x384E2000, 0x384E4000, 0x384E6000, 0x384E8000, 0x384EA000, 0x384EC000, 0x384EE000, 0x384F0000, 0x384F2000, 0x384F4000, 0x384F6000, 0x384F8000, 0x384FA000, 0x384FC000, 0x384FE000,
  0x38500000, 0x38502000, 0x38504000, 0x38506000, 0x38508000, 0x3850A000, 0x3850C000, 0x3850E000, 0x38510000, 0x38512000, 0x38514000, 0x38516000, 0x38518000, 0x3851A000, 0x3851C000, 0x3851E000,
  0x38520000, 0x38522000, 0x38524000, 0x38526000, 0x38528000, 0x3852A000, 0x3852C000, 0x3852E000, 0x38530000, 0x38532000, 0x38534000, 0x38536000, 0x38538000, 0x3853A000, 0x3853C000, 0x3853E000,
  0x38540000, 0x38542000, 0x38544000, 0x38546000, 0x38548000, 0x3854A000, 0x3854C000, 0x3854E000, 0x38550000, 0x38552000, 0x38554000, 0x38556000, 0x38558000, 0x3855A000, 0x3855C000, 0x3855E000,
  0x38560000, 0x38562000, 0x38564000, 0x38566000, 0x38568000, 0x3856A000, 0x3856C000, 0x3856E000, 0x38570000, 0x38572000, 0x38574000, 0x38576000, 0x38578000, 0x3857A000, 0x3857C000, 0x3857E000,
  0x38580000, 0x38582000, 0x38584000, 0x38586000, 0x38588000, 0x3858A000, 0x3858C000, 0x3858E000, 0x38590000, 0x38592000, 0x38594000, 0x38596000, 0x38598000, 0x3859A000, 0x3859C000, 0x3859E000,
  0x385A0000, 0x385A2000, 0x385A4000, 0x385A6000, 0x385A8000, 0x385AA000, 0x385AC000, 0x385AE000, 0x385B0000, 0x385B2000, 0x385B4000, 0x385B6000, 0x385B8000, 0x385BA000, 0x385BC000, 0x385BE000,
  0x385C0000, 0x385C2000, 0x385C4000, 0x385C6000, 0x385C8000, 0x385CA000, 0x385CC000, 0x385CE000, 0x385D0000, 0x385D2000, 0x385D4000, 0x385D6000, 0x385D8000, 0x385DA000, 0x385DC000, 0x385DE000,
  0x385E0000, 0x385E2000, 0x385E4000, 0x385E6000, 0x385E8000, 0x385EA000, 0x385EC000, 0x385EE000, 0x385F0000, 0x385F2000, 0x385F4000, 0x385F6000, 0x385F8000, 0x385FA000, 0x385FC000, 0x385FE000,
  0x38600000, 0x38602000, 0x38604000, 0x38606000, 0x38608000, 0x3860A000, 0x3860C000, 0x3860E000, 0x38610000, 0x38612000, 0x38614000, 0x38616000, 0x38618000, 0x3861A000, 0x3861C000, 0x3861E000,
  0x38620000, 0x38622000, 0x38624000, 0x38626000, 0x38628000, 0x3862A000, 0x3862C000, 0x3862E000, 0x38630000, 0x38632000, 0x38634000, 0x38636000, 0x38638000, 0x3863A000, 0x3863C000, 0x3863E000,
  0x38640000, 0x38642000, 0x38644000, 0x38646000, 0x38648000, 0x3864A000, 0x3864C000, 0x3864E000, 0x38650000, 0x38652000, 0x38654000, 0x38656000, 0x38658000, 0x3865A000, 0x3865C000, 0x3865E000,
  0x38660000, 0x38662000, 0x38664000, 0x38666000, 0x38668000, 0x3866A000, 0x3866C000, 0x3866E000, 0x38670000, 0x38672000, 0x38674000, 0x38676000, 0x38678000, 0x3867A000, 0x3867C000, 0x3867E000,
  0x38680000, 0x38682000, 0x38684000, 0x38686000, 0x38688000, 0x3868A000, 0x3868C000, 0x3868E000, 0x38690000, 0x38692000, 0x38694000, 0x38696000, 0x38698000, 0x3869A000, 0x3869C000, 0x3869E000,
  0x386A0000, 0x386A2000, 0x386A4000, 0x386A6000, 0x386A8000, 0x386AA000, 0x386AC000, 0x386AE000, 0x386B0000, 0x386B2000, 0x386B4000, 0x386B6000, 0x386B8000, 0x386BA000, 0x386BC000, 0x386BE000,
  0x386C0000, 0x386C2000, 0x386C4000, 0x386C6000, 0x386C8000, 0x386CA000, 0x386CC000, 0x386CE000, 0x386D0000, 0x386D2000, 0x386D4000, 0x386D6000, 0x386D8000, 0x386DA000, 0x386DC000, 0x386DE000,
  0x386E0000, 0x386E2000, 0x386E4000, 0x386E6000, 0x386E8000, 0x386EA000, 0x386EC000, 0x386EE000, 0x386F0000, 0x386F2000, 0x386F4000, 0x386F6000, 0x386F8000, 0x386FA000, 0x386FC000, 0x386FE000,
  0x38700000, 0x38702000, 0x38704000, 0x38706000, 0x38708000, 0x3870A000, 0x3870C000, 0x3870E000, 0x38710000, 0x38712000, 0x38714000, 0x38716000, 0x38718000, 0x3871A000, 0x3871C000, 0x3871E000,
  0x38720000, 0x38722000, 0x38724000, 0x38726000, 0x38728000, 0x3872A000, 0x3872C000, 0x3872E000, 0x38730000, 0x38732000, 0x38734000, 0x38736000, 0x38738000, 0x3873A000, 0x3873C000, 0x3873E000,
  0x38740000, 0x38742000, 0x38744000, 0x38746000, 0x38748000, 0x3874A000, 0x3874C000, 0x3874E000, 0x38750000, 0x38752000, 0x38754000, 0x38756000, 0x38758000, 0x3875A000, 0x3875C000, 0x3875E000,
  0x38760000, 0x38762000, 0x38764000, 0x38766000, 0x38768000, 0x3876A000, 0x3876C000, 0x3876E000, 0x38770000, 0x38772000, 0x38774000, 0x38776000, 0x38778000, 0x3877A000, 0x3877C000, 0x3877E000,
  0x38780000, 0x38782000, 0x38784000, 0x38786000, 0x38788000, 0x3878A000, 0x3878C000, 0x3878E000, 0x38790000, 0x38792000, 0x38794000, 0x38796000, 0x38798000, 0x3879A000, 0x3879C000, 0x3879E000,
  0x387A0000, 0x387A2000, 0x387A4000, 0x387A6000, 0x387A8000, 0x387AA000, 0x387AC000, 0x387AE000, 0x387B0000, 0x387B2000, 0x387B4000, 0x387B6000, 0x387B8000, 0x387BA000, 0x387BC000, 0x387BE000,
  0x387C0000, 0x387C2000, 0x387C4000, 0x387C6000, 0x387C8000, 0x387CA000, 0x387CC000, 0x387CE000, 0x387D0000, 0x387D2000, 0x387D4000, 0x387D6000, 0x387D8000, 0x387DA000, 0x387DC000, 0x387DE000,
  0x387E0000, 0x387E2000, 0x387E4000, 0x387E6000, 0x387E8000, 0x387EA000, 0x387EC000, 0x387EE000, 0x387F0000, 0x387F2000, 0x387F4000, 0x387F6000, 0x387F8000, 0x387FA000, 0x387FC000, 0x387FE000 };
__constant static const uint32_t exponent_table[64] = {
  0x00000000, 0x00800000, 0x01000000, 0x01800000, 0x02000000, 0x02800000, 0x03000000, 0x03800000, 0x04000000, 0x04800000, 0x05000000, 0x05800000, 0x06000000, 0x06800000, 0x07000000, 0x07800000,
  0x08000000, 0x08800000, 0x09000000, 0x09800000, 0x0A000000, 0x0A800000, 0x0B000000, 0x0B800000, 0x0C000000, 0x0C800000, 0x0D000000, 0x0D800000, 0x0E000000, 0x0E800000, 0x0F000000, 0x47800000,
  0x80000000, 0x80800000, 0x81000000, 0x81800000, 0x82000000, 0x82800000, 0x83000000, 0x83800000, 0x84000000, 0x84800000, 0x85000000, 0x85800000, 0x86000000, 0x86800000, 0x87000000, 0x87800000,
  0x88000000, 0x88800000, 0x89000000, 0x89800000, 0x8A000000, 0x8A800000, 0x8B000000, 0x8B800000, 0x8C000000, 0x8C800000, 0x8D000000, 0x8D800000, 0x8E000000, 0x8E800000, 0x8F000000, 0xC7800000 };
__constant static const unsigned short offset_table[64] = {
  0, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024,
  0, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024 };

static uint16_t float2halfbits(float value) {
  union { float x; uint32_t y; } u;
  u.x = value;
  uint32_t bits = u.y;

  uint16_t hbits = base_table[bits>>23] + (uint16_t)((bits&0x7FFFFF)>>shift_table[bits>>23]);;

  return hbits;
}

static float halfbits2float(uint16_t value) {
  uint32_t bits = mantissa_table[offset_table[value>>10]+(value&0x3FF)] + exponent_table[value>>10];

  union { uint32_t x; float y; } u;
  u.x = bits;
  return u.y;
}

// End of half.h.
// Start of timing.h.

// The function get_wall_time() returns the wall time in microseconds
// (with an unspecified offset).

#ifdef _WIN32

#include <windows.h>

static int64_t get_wall_time(void) {
  LARGE_INTEGER time,freq;
  assert(QueryPerformanceFrequency(&freq));
  assert(QueryPerformanceCounter(&time));
  return ((double)time.QuadPart / freq.QuadPart) * 1000000;
}

#else
// Assuming POSIX

#include <time.h>
#include <sys/time.h>

static int64_t get_wall_time(void) {
  struct timeval time;
  assert(gettimeofday(&time,NULL) == 0);
  return time.tv_sec * 1000000 + time.tv_usec;
}

static int64_t get_wall_time_ns(void) {
  struct timespec time;
  assert(clock_gettime(CLOCK_REALTIME, &time) == 0);
  return time.tv_sec * 1000000000 + time.tv_nsec;
}

#endif

// End of timing.h.
#include <getopt.h>
#include <ctype.h>
#include <inttypes.h>
#include <unistd.h>
// Start of values.h.

//// Text I/O

typedef int (*writer)(FILE*, const void*);
typedef int (*bin_reader)(void*);
typedef int (*str_reader)(const char *, void*);

struct array_reader {
  char* elems;
  int64_t n_elems_space;
  int64_t elem_size;
  int64_t n_elems_used;
  int64_t *shape;
  str_reader elem_reader;
};

static void skipspaces(FILE *f) {
  int c;
  do {
    c = getc(f);
  } while (isspace(c));

  if (c != EOF) {
    ungetc(c, f);
  }
}

static int constituent(char c) {
  return isalnum(c) || c == '.' || c == '-' || c == '+' || c == '_';
}

// Produces an empty token only on EOF.
static void next_token(FILE *f, char *buf, int bufsize) {
 start:
  skipspaces(f);

  int i = 0;
  while (i < bufsize) {
    int c = getc(f);
    buf[i] = (char)c;

    if (c == EOF) {
      buf[i] = 0;
      return;
    } else if (c == '-' && i == 1 && buf[0] == '-') {
      // Line comment, so skip to end of line and start over.
      for (; c != '\n' && c != EOF; c = getc(f));
      goto start;
    } else if (!constituent((char)c)) {
      if (i == 0) {
        // We permit single-character tokens that are not
        // constituents; this lets things like ']' and ',' be
        // tokens.
        buf[i+1] = 0;
        return;
      } else {
        ungetc(c, f);
        buf[i] = 0;
        return;
      }
    }

    i++;
  }

  buf[bufsize-1] = 0;
}

static int next_token_is(FILE *f, char *buf, int bufsize, const char* expected) {
  next_token(f, buf, bufsize);
  return strcmp(buf, expected) == 0;
}

static void remove_underscores(char *buf) {
  char *w = buf;

  for (char *r = buf; *r; r++) {
    if (*r != '_') {
      *w++ = *r;
    }
  }

  *w++ = 0;
}

static int read_str_elem(char *buf, struct array_reader *reader) {
  int ret;
  if (reader->n_elems_used == reader->n_elems_space) {
    reader->n_elems_space *= 2;
    reader->elems = (char*) realloc(reader->elems,
                                    (size_t)(reader->n_elems_space * reader->elem_size));
  }

  ret = reader->elem_reader(buf, reader->elems + reader->n_elems_used * reader->elem_size);

  if (ret == 0) {
    reader->n_elems_used++;
  }

  return ret;
}

static int read_str_array_elems(FILE *f,
                                char *buf, int bufsize,
                                struct array_reader *reader, int64_t dims) {
  int ret;
  int first = 1;
  char *knows_dimsize = (char*) calloc((size_t)dims, sizeof(char));
  int cur_dim = (int)dims-1;
  int64_t *elems_read_in_dim = (int64_t*) calloc((size_t)dims, sizeof(int64_t));

  while (1) {
    next_token(f, buf, bufsize);

    if (strcmp(buf, "]") == 0) {
      if (knows_dimsize[cur_dim]) {
        if (reader->shape[cur_dim] != elems_read_in_dim[cur_dim]) {
          ret = 1;
          break;
        }
      } else {
        knows_dimsize[cur_dim] = 1;
        reader->shape[cur_dim] = elems_read_in_dim[cur_dim];
      }
      if (cur_dim == 0) {
        ret = 0;
        break;
      } else {
        cur_dim--;
        elems_read_in_dim[cur_dim]++;
      }
    } else if (strcmp(buf, ",") == 0) {
      next_token(f, buf, bufsize);
      if (strcmp(buf, "[") == 0) {
        if (cur_dim == dims - 1) {
          ret = 1;
          break;
        }
        first = 1;
        cur_dim++;
        elems_read_in_dim[cur_dim] = 0;
      } else if (cur_dim == dims - 1) {
        ret = read_str_elem(buf, reader);
        if (ret != 0) {
          break;
        }
        elems_read_in_dim[cur_dim]++;
      } else {
        ret = 1;
        break;
      }
    } else if (strlen(buf) == 0) {
      // EOF
      ret = 1;
      break;
    } else if (first) {
      if (strcmp(buf, "[") == 0) {
        if (cur_dim == dims - 1) {
          ret = 1;
          break;
        }
        cur_dim++;
        elems_read_in_dim[cur_dim] = 0;
      } else {
        ret = read_str_elem(buf, reader);
        if (ret != 0) {
          break;
        }
        elems_read_in_dim[cur_dim]++;
        first = 0;
      }
    } else {
      ret = 1;
      break;
    }
  }

  free(knows_dimsize);
  free(elems_read_in_dim);
  return ret;
}

static int read_str_empty_array(FILE *f, char *buf, int bufsize,
                                const char *type_name, int64_t *shape, int64_t dims) {
  if (strlen(buf) == 0) {
    // EOF
    return 1;
  }

  if (strcmp(buf, "empty") != 0) {
    return 1;
  }

  if (!next_token_is(f, buf, bufsize, "(")) {
    return 1;
  }

  for (int i = 0; i < dims; i++) {
    if (!next_token_is(f, buf, bufsize, "[")) {
      return 1;
    }

    next_token(f, buf, bufsize);

    if (sscanf(buf, "%"SCNu64, (uint64_t*)&shape[i]) != 1) {
      return 1;
    }

    if (!next_token_is(f, buf, bufsize, "]")) {
      return 1;
    }
  }

  if (!next_token_is(f, buf, bufsize, type_name)) {
    return 1;
  }


  if (!next_token_is(f, buf, bufsize, ")")) {
    return 1;
  }

  // Check whether the array really is empty.
  for (int i = 0; i < dims; i++) {
    if (shape[i] == 0) {
      return 0;
    }
  }

  // Not an empty array!
  return 1;
}

static int read_str_array(FILE *f,
                          int64_t elem_size, str_reader elem_reader,
                          const char *type_name,
                          void **data, int64_t *shape, int64_t dims) {
  int ret;
  struct array_reader reader;
  char buf[100];

  int dims_seen;
  for (dims_seen = 0; dims_seen < dims; dims_seen++) {
    if (!next_token_is(f, buf, sizeof(buf), "[")) {
      break;
    }
  }

  if (dims_seen == 0) {
    return read_str_empty_array(f, buf, sizeof(buf), type_name, shape, dims);
  }

  if (dims_seen != dims) {
    return 1;
  }

  reader.shape = shape;
  reader.n_elems_used = 0;
  reader.elem_size = elem_size;
  reader.n_elems_space = 16;
  reader.elems = (char*) realloc(*data, (size_t)(elem_size*reader.n_elems_space));
  reader.elem_reader = elem_reader;

  ret = read_str_array_elems(f, buf, sizeof(buf), &reader, dims);

  *data = reader.elems;

  return ret;
}

#define READ_STR(MACRO, PTR, SUFFIX)                                   \
  remove_underscores(buf);                                              \
  int j;                                                                \
  if (sscanf(buf, "%"MACRO"%n", (PTR*)dest, &j) == 1) {                 \
    return !(strcmp(buf+j, "") == 0 || strcmp(buf+j, SUFFIX) == 0);     \
  } else {                                                              \
    return 1;                                                           \
  }

static int read_str_i8(char *buf, void* dest) {
  // Some platforms (WINDOWS) does not support scanf %hhd or its
  // cousin, %SCNi8.  Read into int first to avoid corrupting
  // memory.
  //
  // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=63417
  remove_underscores(buf);
  int j, x;
  if (sscanf(buf, "%i%n", &x, &j) == 1) {
    *(int8_t*)dest = (int8_t)x;
    return !(strcmp(buf+j, "") == 0 || strcmp(buf+j, "i8") == 0);
  } else {
    return 1;
  }
}

static int read_str_u8(char *buf, void* dest) {
  // Some platforms (WINDOWS) does not support scanf %hhd or its
  // cousin, %SCNu8.  Read into int first to avoid corrupting
  // memory.
  //
  // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=63417
  remove_underscores(buf);
  int j, x;
  if (sscanf(buf, "%i%n", &x, &j) == 1) {
    *(uint8_t*)dest = (uint8_t)x;
    return !(strcmp(buf+j, "") == 0 || strcmp(buf+j, "u8") == 0);
  } else {
    return 1;
  }
}

static int read_str_i16(char *buf, void* dest) {
  READ_STR(SCNi16, int16_t, "i16");
}

static int read_str_u16(char *buf, void* dest) {
  READ_STR(SCNi16, int16_t, "u16");
}

static int read_str_i32(char *buf, void* dest) {
  READ_STR(SCNi32, int32_t, "i32");
}

static int read_str_u32(char *buf, void* dest) {
  READ_STR(SCNi32, int32_t, "u32");
}

static int read_str_i64(char *buf, void* dest) {
  READ_STR(SCNi64, int64_t, "i64");
}

static int read_str_u64(char *buf, void* dest) {
  // FIXME: This is not correct, as SCNu64 only permits decimal
  // literals.  However, SCNi64 does not handle very large numbers
  // correctly (it's really for signed numbers, so that's fair).
  READ_STR(SCNu64, uint64_t, "u64");
}

static int read_str_f16(char *buf, void* dest) {
  remove_underscores(buf);
  if (strcmp(buf, "f16.nan") == 0) {
    *(uint16_t*)dest = float2halfbits(NAN);
    return 0;
  } else if (strcmp(buf, "f16.inf") == 0) {
    *(uint16_t*)dest = float2halfbits(INFINITY);
    return 0;
  } else if (strcmp(buf, "-f16.inf") == 0) {
    *(uint16_t*)dest = float2halfbits(-INFINITY);
    return 0;
  } else {
    int j;
    float x;
    if (sscanf(buf, "%f%n", &x, &j) == 1) {
      if (strcmp(buf+j, "") == 0 || strcmp(buf+j, "f16") == 0) {
        *(uint16_t*)dest = float2halfbits(x);
        return 0;
      }
    }
    return 1;
  }
}

static int read_str_f32(char *buf, void* dest) {
  remove_underscores(buf);
  if (strcmp(buf, "f32.nan") == 0) {
    *(float*)dest = (float)NAN;
    return 0;
  } else if (strcmp(buf, "f32.inf") == 0) {
    *(float*)dest = (float)INFINITY;
    return 0;
  } else if (strcmp(buf, "-f32.inf") == 0) {
    *(float*)dest = (float)-INFINITY;
    return 0;
  } else {
    READ_STR("f", float, "f32");
  }
}

static int read_str_f64(char *buf, void* dest) {
  remove_underscores(buf);
  if (strcmp(buf, "f64.nan") == 0) {
    *(double*)dest = (double)NAN;
    return 0;
  } else if (strcmp(buf, "f64.inf") == 0) {
    *(double*)dest = (double)INFINITY;
    return 0;
  } else if (strcmp(buf, "-f64.inf") == 0) {
    *(double*)dest = (double)-INFINITY;
    return 0;
  } else {
    READ_STR("lf", double, "f64");
  }
}

static int read_str_bool(char *buf, void* dest) {
  if (strcmp(buf, "true") == 0) {
    *(char*)dest = 1;
    return 0;
  } else if (strcmp(buf, "false") == 0) {
    *(char*)dest = 0;
    return 0;
  } else {
    return 1;
  }
}

static int write_str_i8(FILE *out, int8_t *src) {
  return fprintf(out, "%hhdi8", *src);
}

static int write_str_u8(FILE *out, uint8_t *src) {
  return fprintf(out, "%hhuu8", *src);
}

static int write_str_i16(FILE *out, int16_t *src) {
  return fprintf(out, "%hdi16", *src);
}

static int write_str_u16(FILE *out, uint16_t *src) {
  return fprintf(out, "%huu16", *src);
}

static int write_str_i32(FILE *out, int32_t *src) {
  return fprintf(out, "%di32", *src);
}

static int write_str_u32(FILE *out, uint32_t *src) {
  return fprintf(out, "%uu32", *src);
}

static int write_str_i64(FILE *out, int64_t *src) {
  return fprintf(out, "%"PRIi64"i64", *src);
}

static int write_str_u64(FILE *out, uint64_t *src) {
  return fprintf(out, "%"PRIu64"u64", *src);
}

static int write_str_f16(FILE *out, uint16_t *src) {
  float x = halfbits2float(*src);
  if (isnan(x)) {
    return fprintf(out, "f16.nan");
  } else if (isinf(x) && x >= 0) {
    return fprintf(out, "f16.inf");
  } else if (isinf(x)) {
    return fprintf(out, "-f16.inf");
  } else {
    return fprintf(out, "%.6ff16", x);
  }
}

static int write_str_f32(FILE *out, float *src) {
  float x = *src;
  if (isnan(x)) {
    return fprintf(out, "f32.nan");
  } else if (isinf(x) && x >= 0) {
    return fprintf(out, "f32.inf");
  } else if (isinf(x)) {
    return fprintf(out, "-f32.inf");
  } else {
    return fprintf(out, "%.6ff32", x);
  }
}

static int write_str_f64(FILE *out, double *src) {
  double x = *src;
  if (isnan(x)) {
    return fprintf(out, "f64.nan");
  } else if (isinf(x) && x >= 0) {
    return fprintf(out, "f64.inf");
  } else if (isinf(x)) {
    return fprintf(out, "-f64.inf");
  } else {
    return fprintf(out, "%.6ff64", *src);
  }
}

static int write_str_bool(FILE *out, void *src) {
  return fprintf(out, *(char*)src ? "true" : "false");
}

//// Binary I/O

#define BINARY_FORMAT_VERSION 2
#define IS_BIG_ENDIAN (!*(unsigned char *)&(uint16_t){1})

static void flip_bytes(size_t elem_size, unsigned char *elem) {
  for (size_t j=0; j<elem_size/2; j++) {
    unsigned char head = elem[j];
    size_t tail_index = elem_size-1-j;
    elem[j] = elem[tail_index];
    elem[tail_index] = head;
  }
}

// On Windows we need to explicitly set the file mode to not mangle
// newline characters.  On *nix there is no difference.
#ifdef _WIN32
#include <io.h>
#include <fcntl.h>
static void set_binary_mode(FILE *f) {
  setmode(fileno(f), O_BINARY);
}
#else
static void set_binary_mode(FILE *f) {
  (void)f;
}
#endif

static int read_byte(FILE *f, void* dest) {
  size_t num_elems_read = fread(dest, 1, 1, f);
  return num_elems_read == 1 ? 0 : 1;
}

//// Types

struct primtype_info_t {
  const char binname[4]; // Used for parsing binary data.
  const char* type_name; // Same name as in Futhark.
  const int64_t size; // in bytes
  const writer write_str; // Write in text format.
  const str_reader read_str; // Read in text format.
};

static const struct primtype_info_t i8_info =
  {.binname = "  i8", .type_name = "i8",   .size = 1,
   .write_str = (writer)write_str_i8, .read_str = (str_reader)read_str_i8};
static const struct primtype_info_t i16_info =
  {.binname = " i16", .type_name = "i16",  .size = 2,
   .write_str = (writer)write_str_i16, .read_str = (str_reader)read_str_i16};
static const struct primtype_info_t i32_info =
  {.binname = " i32", .type_name = "i32",  .size = 4,
   .write_str = (writer)write_str_i32, .read_str = (str_reader)read_str_i32};
static const struct primtype_info_t i64_info =
  {.binname = " i64", .type_name = "i64",  .size = 8,
   .write_str = (writer)write_str_i64, .read_str = (str_reader)read_str_i64};
static const struct primtype_info_t u8_info =
  {.binname = "  u8", .type_name = "u8",   .size = 1,
   .write_str = (writer)write_str_u8, .read_str = (str_reader)read_str_u8};
static const struct primtype_info_t u16_info =
  {.binname = " u16", .type_name = "u16",  .size = 2,
   .write_str = (writer)write_str_u16, .read_str = (str_reader)read_str_u16};
static const struct primtype_info_t u32_info =
  {.binname = " u32", .type_name = "u32",  .size = 4,
   .write_str = (writer)write_str_u32, .read_str = (str_reader)read_str_u32};
static const struct primtype_info_t u64_info =
  {.binname = " u64", .type_name = "u64",  .size = 8,
   .write_str = (writer)write_str_u64, .read_str = (str_reader)read_str_u64};
static const struct primtype_info_t f16_info =
  {.binname = " f16", .type_name = "f16",  .size = 2,
   .write_str = (writer)write_str_f16, .read_str = (str_reader)read_str_f16};
static const struct primtype_info_t f32_info =
  {.binname = " f32", .type_name = "f32",  .size = 4,
   .write_str = (writer)write_str_f32, .read_str = (str_reader)read_str_f32};
static const struct primtype_info_t f64_info =
  {.binname = " f64", .type_name = "f64",  .size = 8,
   .write_str = (writer)write_str_f64, .read_str = (str_reader)read_str_f64};
static const struct primtype_info_t bool_info =
  {.binname = "bool", .type_name = "bool", .size = 1,
   .write_str = (writer)write_str_bool, .read_str = (str_reader)read_str_bool};

static const struct primtype_info_t* primtypes[] = {
  &i8_info, &i16_info, &i32_info, &i64_info,
  &u8_info, &u16_info, &u32_info, &u64_info,
  &f16_info, &f32_info, &f64_info,
  &bool_info,
  NULL // NULL-terminated
};

// General value interface.  All endian business taken care of at
// lower layers.

static int read_is_binary(FILE *f) {
  skipspaces(f);
  int c = getc(f);
  if (c == 'b') {
    int8_t bin_version;
    int ret = read_byte(f, &bin_version);

    if (ret != 0) { futhark_panic(1, "binary-input: could not read version.\n"); }

    if (bin_version != BINARY_FORMAT_VERSION) {
      futhark_panic(1, "binary-input: File uses version %i, but I only understand version %i.\n",
            bin_version, BINARY_FORMAT_VERSION);
    }

    return 1;
  }
  ungetc(c, f);
  return 0;
}

static const struct primtype_info_t* read_bin_read_type_enum(FILE *f) {
  char read_binname[4];

  int num_matched = fscanf(f, "%4c", read_binname);
  if (num_matched != 1) { futhark_panic(1, "binary-input: Couldn't read element type.\n"); }

  const struct primtype_info_t **type = primtypes;

  for (; *type != NULL; type++) {
    // I compare the 4 characters manually instead of using strncmp because
    // this allows any value to be used, also NULL bytes
    if (memcmp(read_binname, (*type)->binname, 4) == 0) {
      return *type;
    }
  }
  futhark_panic(1, "binary-input: Did not recognize the type '%s'.\n", read_binname);
  return NULL;
}

static void read_bin_ensure_scalar(FILE *f, const struct primtype_info_t *expected_type) {
  int8_t bin_dims;
  int ret = read_byte(f, &bin_dims);
  if (ret != 0) { futhark_panic(1, "binary-input: Couldn't get dims.\n"); }

  if (bin_dims != 0) {
    futhark_panic(1, "binary-input: Expected scalar (0 dimensions), but got array with %i dimensions.\n",
          bin_dims);
  }

  const struct primtype_info_t *bin_type = read_bin_read_type_enum(f);
  if (bin_type != expected_type) {
    futhark_panic(1, "binary-input: Expected scalar of type %s but got scalar of type %s.\n",
          expected_type->type_name,
          bin_type->type_name);
  }
}

//// High-level interface

static int read_bin_array(FILE *f,
                          const struct primtype_info_t *expected_type, void **data, int64_t *shape, int64_t dims) {
  int ret;

  int8_t bin_dims;
  ret = read_byte(f, &bin_dims);
  if (ret != 0) { futhark_panic(1, "binary-input: Couldn't get dims.\n"); }

  if (bin_dims != dims) {
    futhark_panic(1, "binary-input: Expected %i dimensions, but got array with %i dimensions.\n",
          dims, bin_dims);
  }

  const struct primtype_info_t *bin_primtype = read_bin_read_type_enum(f);
  if (expected_type != bin_primtype) {
    futhark_panic(1, "binary-input: Expected %iD-array with element type '%s' but got %iD-array with element type '%s'.\n",
          dims, expected_type->type_name, dims, bin_primtype->type_name);
  }

  int64_t elem_count = 1;
  for (int i=0; i<dims; i++) {
    int64_t bin_shape;
    ret = (int)fread(&bin_shape, sizeof(bin_shape), 1, f);
    if (ret != 1) {
      futhark_panic(1, "binary-input: Couldn't read size for dimension %i of array.\n", i);
    }
    if (IS_BIG_ENDIAN) {
      flip_bytes(sizeof(bin_shape), (unsigned char*) &bin_shape);
    }
    elem_count *= bin_shape;
    shape[i] = bin_shape;
  }

  int64_t elem_size = expected_type->size;
  void* tmp = realloc(*data, (size_t)(elem_count * elem_size));
  if (tmp == NULL) {
    futhark_panic(1, "binary-input: Failed to allocate array of size %i.\n",
          elem_count * elem_size);
  }
  *data = tmp;

  int64_t num_elems_read = (int64_t)fread(*data, (size_t)elem_size, (size_t)elem_count, f);
  if (num_elems_read != elem_count) {
    futhark_panic(1, "binary-input: tried to read %i elements of an array, but only got %i elements.\n",
          elem_count, num_elems_read);
  }

  // If we're on big endian platform we must change all multibyte elements
  // from using little endian to big endian
  if (IS_BIG_ENDIAN && elem_size != 1) {
    flip_bytes((size_t)elem_size, (unsigned char*) *data);
  }

  return 0;
}

static int read_array(FILE *f, const struct primtype_info_t *expected_type, void **data, int64_t *shape, int64_t dims) {
  if (!read_is_binary(f)) {
    return read_str_array(f, expected_type->size, (str_reader)expected_type->read_str, expected_type->type_name, data, shape, dims);
  } else {
    return read_bin_array(f, expected_type, data, shape, dims);
  }
}

static int end_of_input(FILE *f) {
  skipspaces(f);
  char token[2];
  next_token(f, token, sizeof(token));
  if (strcmp(token, "") == 0) {
    return 0;
  } else {
    return 1;
  }
}

static int write_str_array(FILE *out,
                           const struct primtype_info_t *elem_type,
                           const unsigned char *data,
                           const int64_t *shape,
                           int8_t rank) {
  if (rank==0) {
    elem_type->write_str(out, (const void*)data);
  } else {
    int64_t len = (int64_t)shape[0];
    int64_t slice_size = 1;

    int64_t elem_size = elem_type->size;
    for (int8_t i = 1; i < rank; i++) {
      slice_size *= shape[i];
    }

    if (len*slice_size == 0) {
      fprintf(out, "empty(");
      for (int64_t i = 0; i < rank; i++) {
        fprintf(out, "[%"PRIi64"]", shape[i]);
      }
      fprintf(out, "%s", elem_type->type_name);
      fprintf(out, ")");
    } else if (rank==1) {
      fputc('[', out);
      for (int64_t i = 0; i < len; i++) {
        elem_type->write_str(out, (const void*) (data + i * elem_size));
        if (i != len-1) {
          fprintf(out, ", ");
        }
      }
      fputc(']', out);
    } else {
      fputc('[', out);
      for (int64_t i = 0; i < len; i++) {
        write_str_array(out, elem_type, data + i * slice_size * elem_size, shape+1, rank-1);
        if (i != len-1) {
          fprintf(out, ", ");
        }
      }
      fputc(']', out);
    }
  }
  return 0;
}

static int write_bin_array(FILE *out,
                           const struct primtype_info_t *elem_type,
                           const unsigned char *data,
                           const int64_t *shape,
                           int8_t rank) {
  int64_t num_elems = 1;
  for (int64_t i = 0; i < rank; i++) {
    num_elems *= shape[i];
  }

  fputc('b', out);
  fputc((char)BINARY_FORMAT_VERSION, out);
  fwrite(&rank, sizeof(int8_t), 1, out);
  fwrite(elem_type->binname, 4, 1, out);
  if (shape != NULL) {
    fwrite(shape, sizeof(int64_t), (size_t)rank, out);
  }

  if (IS_BIG_ENDIAN) {
    for (int64_t i = 0; i < num_elems; i++) {
      const unsigned char *elem = data+i*elem_type->size;
      for (int64_t j = 0; j < elem_type->size; j++) {
        fwrite(&elem[elem_type->size-j], 1, 1, out);
      }
    }
  } else {
    fwrite(data, (size_t)elem_type->size, (size_t)num_elems, out);
  }

  return 0;
}

static int write_array(FILE *out, int write_binary,
                       const struct primtype_info_t *elem_type,
                       const void *data,
                       const int64_t *shape,
                       const int8_t rank) {
  if (write_binary) {
    return write_bin_array(out, elem_type, data, shape, rank);
  } else {
    return write_str_array(out, elem_type, data, shape, rank);
  }
}

static int read_scalar(FILE *f,
                       const struct primtype_info_t *expected_type, void *dest) {
  if (!read_is_binary(f)) {
    char buf[100];
    next_token(f, buf, sizeof(buf));
    return expected_type->read_str(buf, dest);
  } else {
    read_bin_ensure_scalar(f, expected_type);
    size_t elem_size = (size_t)expected_type->size;
    size_t num_elems_read = fread(dest, elem_size, 1, f);
    if (IS_BIG_ENDIAN) {
      flip_bytes(elem_size, (unsigned char*) dest);
    }
    return num_elems_read == 1 ? 0 : 1;
  }
}

static int write_scalar(FILE *out, int write_binary, const struct primtype_info_t *type, void *src) {
  if (write_binary) {
    return write_bin_array(out, type, src, NULL, 0);
  } else {
    return type->write_str(out, src);
  }
}

// End of values.h.

static int binary_output = 0;
static int print_result = 1;
static FILE *runtime_file;
static int perform_warmup = 0;
static int num_runs = 1;
static const char *entry_point = "main";
// Start of tuning.h.

static char* load_tuning_file(const char *fname,
                              void *cfg,
                              int (*set_tuning_param)(void*, const char*, size_t)) {
  const int max_line_len = 1024;
  char* line = (char*) malloc(max_line_len);

  FILE *f = fopen(fname, "r");

  if (f == NULL) {
    snprintf(line, max_line_len, "Cannot open file: %s", strerror(errno));
    return line;
  }

  int lineno = 0;
  while (fgets(line, max_line_len, f) != NULL) {
    lineno++;
    char *eql = strstr(line, "=");
    if (eql) {
      *eql = 0;
      int value = atoi(eql+1);
      if (set_tuning_param(cfg, line, (size_t)value) != 0) {
        char* err = (char*) malloc(max_line_len + 50);
        snprintf(err, max_line_len + 50, "Unknown name '%s' on line %d.", line, lineno);
        free(line);
        return err;
      }
    } else {
      snprintf(line, max_line_len, "Invalid line %d (must be of form 'name=int').",
               lineno);
      return line;
    }
  }

  free(line);

  return NULL;
}

// End of tuning.h.

int parse_options(struct futhark_context_config *cfg, int argc,
                  char *const argv[])
{
    int ch;
    static struct option long_options[] = {{"write-runtime-to",
                                            required_argument, NULL, 1},
                                           {"runs", required_argument, NULL, 2},
                                           {"debugging", no_argument, NULL, 3},
                                           {"log", no_argument, NULL, 4},
                                           {"entry-point", required_argument,
                                            NULL, 5}, {"binary-output",
                                                       no_argument, NULL, 6},
                                           {"no-print-result", no_argument,
                                            NULL, 7}, {"help", no_argument,
                                                       NULL, 8},
                                           {"print-params", no_argument, NULL,
                                            9}, {"param", required_argument,
                                                 NULL, 10}, {"tuning",
                                                             required_argument,
                                                             NULL, 11}, {0, 0,
                                                                         0, 0}};
    static char *option_descriptions =
                "  -t/--write-runtime-to FILE Print the time taken to execute the program to the indicated file, an integral number of microseconds.\n  -r/--runs INT              Perform NUM runs of the program.\n  -D/--debugging             Perform possibly expensive internal correctness checks and verbose logging.\n  -L/--log                   Print various low-overhead logging information to stderr while running.\n  -e/--entry-point NAME      The entry point to run. Defaults to main.\n  -b/--binary-output         Print the program result in the binary output format.\n  -n/--no-print-result       Do not print the program result.\n  -h/--help                  Print help information and exit.\n  --print-params             Print all tuning parameters that can be set with --param or --tuning.\n  --param ASSIGNMENT         Set a tuning parameter to the given value.\n  --tuning FILE              Read size=value assignments from the given file.\n";
    
    while ((ch = getopt_long(argc, argv, ":t:r:DLe:bnh", long_options, NULL)) !=
           -1) {
        if (ch == 1 || ch == 't') {
            runtime_file = fopen(optarg, "w");
            if (runtime_file == NULL)
                futhark_panic(1, "Cannot open %s: %s\n", optarg,
                              strerror(errno));
        }
        if (ch == 2 || ch == 'r') {
            num_runs = atoi(optarg);
            perform_warmup = 1;
            if (num_runs <= 0)
                futhark_panic(1, "Need a positive number of runs, not %s\n",
                              optarg);
        }
        if (ch == 3 || ch == 'D')
            futhark_context_config_set_debugging(cfg, 1);
        if (ch == 4 || ch == 'L')
            futhark_context_config_set_logging(cfg, 1);
        if (ch == 5 || ch == 'e') {
            if (entry_point != NULL)
                entry_point = optarg;
        }
        if (ch == 6 || ch == 'b')
            binary_output = 1;
        if (ch == 7 || ch == 'n')
            print_result = 0;
        if (ch == 8 || ch == 'h') {
            printf("Usage: %s [OPTION]...\nOptions:\n\n%s\nFor more information, consult the Futhark User's Guide or the man pages.\n",
                   fut_progname, option_descriptions);
            exit(0);
        }
        if (ch == 9) {
            int n = futhark_get_tuning_param_count();
            
            for (int i = 0; i < n; i++)
                printf("%s (%s)\n", futhark_get_tuning_param_name(i),
                       futhark_get_tuning_param_class(i));
            exit(0);
        }
        if (ch == 10) {
            char *name = optarg;
            char *equals = strstr(optarg, "=");
            char *value_str = equals != NULL ? equals + 1 : optarg;
            int value = atoi(value_str);
            
            if (equals != NULL) {
                *equals = 0;
                if (futhark_context_config_set_tuning_param(cfg, name,
                                                            (size_t) value) !=
                    0)
                    futhark_panic(1, "Unknown size: %s\n", name);
            } else
                futhark_panic(1, "Invalid argument for size option: %s\n",
                              optarg);
        }
        if (ch == 11) {
            char *ret = load_tuning_file(optarg, cfg, (int (*)(void *, const
                                                               char *,
                                                               size_t)) futhark_context_config_set_tuning_param);
            
            if (ret != NULL)
                futhark_panic(1, "When loading tuning from '%s': %s\n", optarg,
                              ret);
        }
        if (ch == ':')
            futhark_panic(-1, "Missing argument for option %s\n", argv[optind -
                                                                       1]);
        if (ch == '?') {
            fprintf(stderr, "Usage: %s [OPTIONS]...\nOptions:\n\n%s\n",
                    fut_progname,
                    "  -t/--write-runtime-to FILE Print the time taken to execute the program to the indicated file, an integral number of microseconds.\n  -r/--runs INT              Perform NUM runs of the program.\n  -D/--debugging             Perform possibly expensive internal correctness checks and verbose logging.\n  -L/--log                   Print various low-overhead logging information to stderr while running.\n  -e/--entry-point NAME      The entry point to run. Defaults to main.\n  -b/--binary-output         Print the program result in the binary output format.\n  -n/--no-print-result       Do not print the program result.\n  -h/--help                  Print help information and exit.\n  --print-params             Print all tuning parameters that can be set with --param or --tuning.\n  --param ASSIGNMENT         Set a tuning parameter to the given value.\n  --tuning FILE              Read size=value assignments from the given file.\n");
            futhark_panic(1, "Unknown option: %s\n", argv[optind - 1]);
        }
    }
    return optind;
}
static void futrts_cli_entry_main(struct futhark_context *ctx)
{
    int64_t t_start, t_end;
    int time_runs = 0, profile_run = 0;
    
    // We do not want to profile all the initialisation.
    futhark_context_pause_profiling(ctx);
    // Declare and read input.
    set_binary_mode(stdin);
    
    int32_t read_value_0;
    
    if (read_scalar(stdin, &i32_info, &read_value_0) != 0)
        futhark_panic(1,
                      "Error when reading input #%d of type %s (errno: %s).\n",
                      0, "i32", strerror(errno));
    ;
    
    float read_value_1;
    
    if (read_scalar(stdin, &f32_info, &read_value_1) != 0)
        futhark_panic(1,
                      "Error when reading input #%d of type %s (errno: %s).\n",
                      1, "f32", strerror(errno));
    ;
    
    float read_value_2;
    
    if (read_scalar(stdin, &f32_info, &read_value_2) != 0)
        futhark_panic(1,
                      "Error when reading input #%d of type %s (errno: %s).\n",
                      2, "f32", strerror(errno));
    ;
    
    struct futhark_f32_1d * read_value_3;
    int64_t read_shape_3[1];
    float *read_arr_3 = NULL;
    
    errno = 0;
    if (read_array(stdin, &f32_info, (void **) &read_arr_3, read_shape_3, 1) !=
        0)
        futhark_panic(1, "Cannot read input #%d of type %s (errno: %s).\n", 3,
                      "[]f32", strerror(errno));
    
    struct futhark_f32_1d * read_value_4;
    int64_t read_shape_4[1];
    float *read_arr_4 = NULL;
    
    errno = 0;
    if (read_array(stdin, &f32_info, (void **) &read_arr_4, read_shape_4, 1) !=
        0)
        futhark_panic(1, "Cannot read input #%d of type %s (errno: %s).\n", 4,
                      "[]f32", strerror(errno));
    
    struct futhark_f32_1d * read_value_5;
    int64_t read_shape_5[1];
    float *read_arr_5 = NULL;
    
    errno = 0;
    if (read_array(stdin, &f32_info, (void **) &read_arr_5, read_shape_5, 1) !=
        0)
        futhark_panic(1, "Cannot read input #%d of type %s (errno: %s).\n", 5,
                      "[]f32", strerror(errno));
    
    struct futhark_f32_1d * read_value_6;
    int64_t read_shape_6[1];
    float *read_arr_6 = NULL;
    
    errno = 0;
    if (read_array(stdin, &f32_info, (void **) &read_arr_6, read_shape_6, 1) !=
        0)
        futhark_panic(1, "Cannot read input #%d of type %s (errno: %s).\n", 6,
                      "[]f32", strerror(errno));
    
    struct futhark_f32_1d * read_value_7;
    int64_t read_shape_7[1];
    float *read_arr_7 = NULL;
    
    errno = 0;
    if (read_array(stdin, &f32_info, (void **) &read_arr_7, read_shape_7, 1) !=
        0)
        futhark_panic(1, "Cannot read input #%d of type %s (errno: %s).\n", 7,
                      "[]f32", strerror(errno));
    
    struct futhark_f32_1d * read_value_8;
    int64_t read_shape_8[1];
    float *read_arr_8 = NULL;
    
    errno = 0;
    if (read_array(stdin, &f32_info, (void **) &read_arr_8, read_shape_8, 1) !=
        0)
        futhark_panic(1, "Cannot read input #%d of type %s (errno: %s).\n", 8,
                      "[]f32", strerror(errno));
    
    struct futhark_f32_1d * read_value_9;
    int64_t read_shape_9[1];
    float *read_arr_9 = NULL;
    
    errno = 0;
    if (read_array(stdin, &f32_info, (void **) &read_arr_9, read_shape_9, 1) !=
        0)
        futhark_panic(1, "Cannot read input #%d of type %s (errno: %s).\n", 9,
                      "[]f32", strerror(errno));
    if (end_of_input(stdin) != 0)
        futhark_panic(1,
                      "Expected EOF on stdin after reading input for \"%s\".\n",
                      "main");
    
    struct futhark_f32_1d * result_0;
    struct futhark_f32_1d * result_1;
    struct futhark_f32_1d * result_2;
    struct futhark_f32_1d * result_3;
    struct futhark_f32_1d * result_4;
    struct futhark_f32_1d * result_5;
    struct futhark_f32_1d * result_6;
    
    if (perform_warmup) {
        int r;
        
        ;
        ;
        ;
        assert((read_value_3 = futhark_new_f32_1d(ctx, read_arr_3,
                                                  read_shape_3[0])) != NULL);
        assert((read_value_4 = futhark_new_f32_1d(ctx, read_arr_4,
                                                  read_shape_4[0])) != NULL);
        assert((read_value_5 = futhark_new_f32_1d(ctx, read_arr_5,
                                                  read_shape_5[0])) != NULL);
        assert((read_value_6 = futhark_new_f32_1d(ctx, read_arr_6,
                                                  read_shape_6[0])) != NULL);
        assert((read_value_7 = futhark_new_f32_1d(ctx, read_arr_7,
                                                  read_shape_7[0])) != NULL);
        assert((read_value_8 = futhark_new_f32_1d(ctx, read_arr_8,
                                                  read_shape_8[0])) != NULL);
        assert((read_value_9 = futhark_new_f32_1d(ctx, read_arr_9,
                                                  read_shape_9[0])) != NULL);
        if (futhark_context_sync(ctx) != 0)
            futhark_panic(1, "%s", futhark_context_get_error(ctx));
        ;
        // Only profile last run.
        if (profile_run)
            futhark_context_unpause_profiling(ctx);
        t_start = get_wall_time();
        r = futhark_entry_main(ctx, &result_0, &result_1, &result_2, &result_3,
                               &result_4, &result_5, &result_6, read_value_0,
                               read_value_1, read_value_2, read_value_3,
                               read_value_4, read_value_5, read_value_6,
                               read_value_7, read_value_8, read_value_9);
        if (r != 0)
            futhark_panic(1, "%s", futhark_context_get_error(ctx));
        if (futhark_context_sync(ctx) != 0)
            futhark_panic(1, "%s", futhark_context_get_error(ctx));
        ;
        if (profile_run)
            futhark_context_pause_profiling(ctx);
        t_end = get_wall_time();
        
        long elapsed_usec = t_end - t_start;
        
        if (time_runs && runtime_file != NULL) {
            fprintf(runtime_file, "%lld\n", (long long) elapsed_usec);
            fflush(runtime_file);
        }
        ;
        ;
        ;
        assert(futhark_free_f32_1d(ctx, read_value_3) == 0);
        assert(futhark_free_f32_1d(ctx, read_value_4) == 0);
        assert(futhark_free_f32_1d(ctx, read_value_5) == 0);
        assert(futhark_free_f32_1d(ctx, read_value_6) == 0);
        assert(futhark_free_f32_1d(ctx, read_value_7) == 0);
        assert(futhark_free_f32_1d(ctx, read_value_8) == 0);
        assert(futhark_free_f32_1d(ctx, read_value_9) == 0);
        assert(futhark_free_f32_1d(ctx, result_0) == 0);
        assert(futhark_free_f32_1d(ctx, result_1) == 0);
        assert(futhark_free_f32_1d(ctx, result_2) == 0);
        assert(futhark_free_f32_1d(ctx, result_3) == 0);
        assert(futhark_free_f32_1d(ctx, result_4) == 0);
        assert(futhark_free_f32_1d(ctx, result_5) == 0);
        assert(futhark_free_f32_1d(ctx, result_6) == 0);
    }
    time_runs = 1;
    // Proper run.
    for (int run = 0; run < num_runs; run++) {
        // Only profile last run.
        profile_run = run == num_runs - 1;
        
        int r;
        
        ;
        ;
        ;
        assert((read_value_3 = futhark_new_f32_1d(ctx, read_arr_3,
                                                  read_shape_3[0])) != NULL);
        assert((read_value_4 = futhark_new_f32_1d(ctx, read_arr_4,
                                                  read_shape_4[0])) != NULL);
        assert((read_value_5 = futhark_new_f32_1d(ctx, read_arr_5,
                                                  read_shape_5[0])) != NULL);
        assert((read_value_6 = futhark_new_f32_1d(ctx, read_arr_6,
                                                  read_shape_6[0])) != NULL);
        assert((read_value_7 = futhark_new_f32_1d(ctx, read_arr_7,
                                                  read_shape_7[0])) != NULL);
        assert((read_value_8 = futhark_new_f32_1d(ctx, read_arr_8,
                                                  read_shape_8[0])) != NULL);
        assert((read_value_9 = futhark_new_f32_1d(ctx, read_arr_9,
                                                  read_shape_9[0])) != NULL);
        if (futhark_context_sync(ctx) != 0)
            futhark_panic(1, "%s", futhark_context_get_error(ctx));
        ;
        // Only profile last run.
        if (profile_run)
            futhark_context_unpause_profiling(ctx);
        t_start = get_wall_time();
        r = futhark_entry_main(ctx, &result_0, &result_1, &result_2, &result_3,
                               &result_4, &result_5, &result_6, read_value_0,
                               read_value_1, read_value_2, read_value_3,
                               read_value_4, read_value_5, read_value_6,
                               read_value_7, read_value_8, read_value_9);
        if (r != 0)
            futhark_panic(1, "%s", futhark_context_get_error(ctx));
        if (futhark_context_sync(ctx) != 0)
            futhark_panic(1, "%s", futhark_context_get_error(ctx));
        ;
        if (profile_run)
            futhark_context_pause_profiling(ctx);
        t_end = get_wall_time();
        
        long elapsed_usec = t_end - t_start;
        
        if (time_runs && runtime_file != NULL) {
            fprintf(runtime_file, "%lld\n", (long long) elapsed_usec);
            fflush(runtime_file);
        }
        ;
        ;
        ;
        assert(futhark_free_f32_1d(ctx, read_value_3) == 0);
        assert(futhark_free_f32_1d(ctx, read_value_4) == 0);
        assert(futhark_free_f32_1d(ctx, read_value_5) == 0);
        assert(futhark_free_f32_1d(ctx, read_value_6) == 0);
        assert(futhark_free_f32_1d(ctx, read_value_7) == 0);
        assert(futhark_free_f32_1d(ctx, read_value_8) == 0);
        assert(futhark_free_f32_1d(ctx, read_value_9) == 0);
        if (run < num_runs - 1) {
            assert(futhark_free_f32_1d(ctx, result_0) == 0);
            assert(futhark_free_f32_1d(ctx, result_1) == 0);
            assert(futhark_free_f32_1d(ctx, result_2) == 0);
            assert(futhark_free_f32_1d(ctx, result_3) == 0);
            assert(futhark_free_f32_1d(ctx, result_4) == 0);
            assert(futhark_free_f32_1d(ctx, result_5) == 0);
            assert(futhark_free_f32_1d(ctx, result_6) == 0);
        }
    }
    ;
    ;
    ;
    free(read_arr_3);
    free(read_arr_4);
    free(read_arr_5);
    free(read_arr_6);
    free(read_arr_7);
    free(read_arr_8);
    free(read_arr_9);
    if (print_result) {
        // Print the final result.
        if (binary_output)
            set_binary_mode(stdout);
        {
            float *arr = calloc(futhark_shape_f32_1d(ctx, result_0)[0],
                                f32_info.size);
            
            assert(arr != NULL);
            assert(futhark_values_f32_1d(ctx, result_0, arr) == 0);
            write_array(stdout, binary_output, &f32_info, arr,
                        futhark_shape_f32_1d(ctx, result_0), 1);
            free(arr);
        }
        printf("\n");
        {
            float *arr = calloc(futhark_shape_f32_1d(ctx, result_1)[0],
                                f32_info.size);
            
            assert(arr != NULL);
            assert(futhark_values_f32_1d(ctx, result_1, arr) == 0);
            write_array(stdout, binary_output, &f32_info, arr,
                        futhark_shape_f32_1d(ctx, result_1), 1);
            free(arr);
        }
        printf("\n");
        {
            float *arr = calloc(futhark_shape_f32_1d(ctx, result_2)[0],
                                f32_info.size);
            
            assert(arr != NULL);
            assert(futhark_values_f32_1d(ctx, result_2, arr) == 0);
            write_array(stdout, binary_output, &f32_info, arr,
                        futhark_shape_f32_1d(ctx, result_2), 1);
            free(arr);
        }
        printf("\n");
        {
            float *arr = calloc(futhark_shape_f32_1d(ctx, result_3)[0],
                                f32_info.size);
            
            assert(arr != NULL);
            assert(futhark_values_f32_1d(ctx, result_3, arr) == 0);
            write_array(stdout, binary_output, &f32_info, arr,
                        futhark_shape_f32_1d(ctx, result_3), 1);
            free(arr);
        }
        printf("\n");
        {
            float *arr = calloc(futhark_shape_f32_1d(ctx, result_4)[0],
                                f32_info.size);
            
            assert(arr != NULL);
            assert(futhark_values_f32_1d(ctx, result_4, arr) == 0);
            write_array(stdout, binary_output, &f32_info, arr,
                        futhark_shape_f32_1d(ctx, result_4), 1);
            free(arr);
        }
        printf("\n");
        {
            float *arr = calloc(futhark_shape_f32_1d(ctx, result_5)[0],
                                f32_info.size);
            
            assert(arr != NULL);
            assert(futhark_values_f32_1d(ctx, result_5, arr) == 0);
            write_array(stdout, binary_output, &f32_info, arr,
                        futhark_shape_f32_1d(ctx, result_5), 1);
            free(arr);
        }
        printf("\n");
        {
            float *arr = calloc(futhark_shape_f32_1d(ctx, result_6)[0],
                                f32_info.size);
            
            assert(arr != NULL);
            assert(futhark_values_f32_1d(ctx, result_6, arr) == 0);
            write_array(stdout, binary_output, &f32_info, arr,
                        futhark_shape_f32_1d(ctx, result_6), 1);
            free(arr);
        }
        printf("\n");
    }
    assert(futhark_free_f32_1d(ctx, result_0) == 0);
    assert(futhark_free_f32_1d(ctx, result_1) == 0);
    assert(futhark_free_f32_1d(ctx, result_2) == 0);
    assert(futhark_free_f32_1d(ctx, result_3) == 0);
    assert(futhark_free_f32_1d(ctx, result_4) == 0);
    assert(futhark_free_f32_1d(ctx, result_5) == 0);
    assert(futhark_free_f32_1d(ctx, result_6) == 0);
}
typedef void entry_point_fun(struct futhark_context *);
struct entry_point_entry {
    const char *name;
    entry_point_fun *fun;
};
int main(int argc, char **argv)
{
    fut_progname = argv[0];
    
    struct futhark_context_config *cfg = futhark_context_config_new();
    
    assert(cfg != NULL);
    
    int parsed_options = parse_options(cfg, argc, argv);
    
    argc -= parsed_options;
    argv += parsed_options;
    if (argc != 0)
        futhark_panic(1, "Excess non-option: %s\n", argv[0]);
    
    struct futhark_context *ctx = futhark_context_new(cfg);
    
    assert(ctx != NULL);
    
    char *error = futhark_context_get_error(ctx);
    
    if (error != NULL)
        futhark_panic(1, "%s", error);
    
    struct entry_point_entry entry_points[] = {{.name ="main", .fun =
                                                futrts_cli_entry_main}};
    
    if (entry_point != NULL) {
        int num_entry_points = sizeof(entry_points) / sizeof(entry_points[0]);
        entry_point_fun *entry_point_fun = NULL;
        
        for (int i = 0; i < num_entry_points; i++) {
            if (strcmp(entry_points[i].name, entry_point) == 0) {
                entry_point_fun = entry_points[i].fun;
                break;
            }
        }
        if (entry_point_fun == NULL) {
            fprintf(stderr,
                    "No entry point '%s'.  Select another with --entry-point.  Options are:\n",
                    entry_point);
            for (int i = 0; i < num_entry_points; i++)
                fprintf(stderr, "%s\n", entry_points[i].name);
            return 1;
        }
        if (isatty(fileno(stdin))) {
            fprintf(stderr, "Reading input from TTY.\n");
            fprintf(stderr,
                    "Send EOF (CTRL-d) after typing all input values.\n");
        }
        entry_point_fun(ctx);
        if (runtime_file != NULL)
            fclose(runtime_file);
        
        char *report = futhark_context_report(ctx);
        
        fputs(report, stderr);
        free(report);
    }
    futhark_context_free(ctx);
    futhark_context_config_free(cfg);
    return 0;
}

#ifdef _MSC_VER
#define inline __inline
#endif
#include <string.h>
#include <string.h>
#include <errno.h>
#include <assert.h>
#include <ctype.h>



// Start of lock.h.

// A very simple cross-platform implementation of locks.  Uses
// pthreads on Unix and some Windows thing there.  Futhark's
// host-level code is not multithreaded, but user code may be, so we
// need some mechanism for ensuring atomic access to API functions.
// This is that mechanism.  It is not exposed to user code at all, so
// we do not have to worry about name collisions.

#ifdef _WIN32

typedef HANDLE lock_t;

static void create_lock(lock_t *lock) {
  *lock = CreateMutex(NULL,  // Default security attributes.
                      FALSE, // Initially unlocked.
                      NULL); // Unnamed.
}

static void lock_lock(lock_t *lock) {
  assert(WaitForSingleObject(*lock, INFINITE) == WAIT_OBJECT_0);
}

static void lock_unlock(lock_t *lock) {
  assert(ReleaseMutex(*lock));
}

static void free_lock(lock_t *lock) {
  CloseHandle(*lock);
}

#else
// Assuming POSIX

#include <pthread.h>

typedef pthread_mutex_t lock_t;

static void create_lock(lock_t *lock) {
  int r = pthread_mutex_init(lock, NULL);
  assert(r == 0);
}

static void lock_lock(lock_t *lock) {
  int r = pthread_mutex_lock(lock);
  assert(r == 0);
}

static void lock_unlock(lock_t *lock) {
  int r = pthread_mutex_unlock(lock);
  assert(r == 0);
}

static void free_lock(lock_t *lock) {
  // Nothing to do for pthreads.
  (void)lock;
}

#endif

// End of lock.h.

#define FUTHARK_F64_ENABLED

// Start of scalar.h.

// Implementation of the primitive scalar operations.  Very
// repetitive.  This code is inserted directly into both CUDA and
// OpenCL programs, as well as the CPU code, so it has some #ifdefs to
// work everywhere.  Some operations are defined as macros because
// this allows us to use them as constant expressions in things like
// array sizes and static initialisers.

// Some of the #ifdefs are because OpenCL uses type-generic functions
// for some operations (e.g. sqrt), while C and CUDA sensibly use
// distinct functions for different precisions (e.g. sqrtf() and
// sqrt()).  This is quite annoying.  Due to C's unfortunate casting
// rules, it is also really easy to accidentally implement
// floating-point functions in the wrong precision, so be careful.

// Double-precision definitions are only included if the preprocessor
// macro FUTHARK_F64_ENABLED is set.

static inline uint8_t add8(uint8_t x, uint8_t y) {
  return x + y;
}

static inline uint16_t add16(uint16_t x, uint16_t y) {
  return x + y;
}

static inline uint32_t add32(uint32_t x, uint32_t y) {
  return x + y;
}

static inline uint64_t add64(uint64_t x, uint64_t y) {
  return x + y;
}

static inline uint8_t sub8(uint8_t x, uint8_t y) {
  return x - y;
}

static inline uint16_t sub16(uint16_t x, uint16_t y) {
  return x - y;
}

static inline uint32_t sub32(uint32_t x, uint32_t y) {
  return x - y;
}

static inline uint64_t sub64(uint64_t x, uint64_t y) {
  return x - y;
}

static inline uint8_t mul8(uint8_t x, uint8_t y) {
  return x * y;
}

static inline uint16_t mul16(uint16_t x, uint16_t y) {
  return x * y;
}

static inline uint32_t mul32(uint32_t x, uint32_t y) {
  return x * y;
}

static inline uint64_t mul64(uint64_t x, uint64_t y) {
  return x * y;
}

static inline uint8_t udiv8(uint8_t x, uint8_t y) {
  return x / y;
}

static inline uint16_t udiv16(uint16_t x, uint16_t y) {
  return x / y;
}

static inline uint32_t udiv32(uint32_t x, uint32_t y) {
  return x / y;
}

static inline uint64_t udiv64(uint64_t x, uint64_t y) {
  return x / y;
}

static inline uint8_t udiv_up8(uint8_t x, uint8_t y) {
  return (x + y - 1) / y;
}

static inline uint16_t udiv_up16(uint16_t x, uint16_t y) {
  return (x + y - 1) / y;
}

static inline uint32_t udiv_up32(uint32_t x, uint32_t y) {
  return (x + y - 1) / y;
}

static inline uint64_t udiv_up64(uint64_t x, uint64_t y) {
  return (x + y - 1) / y;
}

static inline uint8_t umod8(uint8_t x, uint8_t y) {
  return x % y;
}

static inline uint16_t umod16(uint16_t x, uint16_t y) {
  return x % y;
}

static inline uint32_t umod32(uint32_t x, uint32_t y) {
  return x % y;
}

static inline uint64_t umod64(uint64_t x, uint64_t y) {
  return x % y;
}

static inline uint8_t udiv_safe8(uint8_t x, uint8_t y) {
  return y == 0 ? 0 : x / y;
}

static inline uint16_t udiv_safe16(uint16_t x, uint16_t y) {
  return y == 0 ? 0 : x / y;
}

static inline uint32_t udiv_safe32(uint32_t x, uint32_t y) {
  return y == 0 ? 0 : x / y;
}

static inline uint64_t udiv_safe64(uint64_t x, uint64_t y) {
  return y == 0 ? 0 : x / y;
}

static inline uint8_t udiv_up_safe8(uint8_t x, uint8_t y) {
  return y == 0 ? 0 : (x + y - 1) / y;
}

static inline uint16_t udiv_up_safe16(uint16_t x, uint16_t y) {
  return y == 0 ? 0 : (x + y - 1) / y;
}

static inline uint32_t udiv_up_safe32(uint32_t x, uint32_t y) {
  return y == 0 ? 0 : (x + y - 1) / y;
}

static inline uint64_t udiv_up_safe64(uint64_t x, uint64_t y) {
  return y == 0 ? 0 : (x + y - 1) / y;
}

static inline uint8_t umod_safe8(uint8_t x, uint8_t y) {
  return y == 0 ? 0 : x % y;
}

static inline uint16_t umod_safe16(uint16_t x, uint16_t y) {
  return y == 0 ? 0 : x % y;
}

static inline uint32_t umod_safe32(uint32_t x, uint32_t y) {
  return y == 0 ? 0 : x % y;
}

static inline uint64_t umod_safe64(uint64_t x, uint64_t y) {
  return y == 0 ? 0 : x % y;
}

static inline int8_t sdiv8(int8_t x, int8_t y) {
  int8_t q = x / y;
  int8_t r = x % y;

  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}

static inline int16_t sdiv16(int16_t x, int16_t y) {
  int16_t q = x / y;
  int16_t r = x % y;

  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}

static inline int32_t sdiv32(int32_t x, int32_t y) {
  int32_t q = x / y;
  int32_t r = x % y;

  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}

static inline int64_t sdiv64(int64_t x, int64_t y) {
  int64_t q = x / y;
  int64_t r = x % y;

  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}

static inline int8_t sdiv_up8(int8_t x, int8_t y) {
  return sdiv8(x + y - 1, y);
}

static inline int16_t sdiv_up16(int16_t x, int16_t y) {
  return sdiv16(x + y - 1, y);
}

static inline int32_t sdiv_up32(int32_t x, int32_t y) {
  return sdiv32(x + y - 1, y);
}

static inline int64_t sdiv_up64(int64_t x, int64_t y) {
  return sdiv64(x + y - 1, y);
}

static inline int8_t smod8(int8_t x, int8_t y) {
  int8_t r = x % y;

  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}

static inline int16_t smod16(int16_t x, int16_t y) {
  int16_t r = x % y;

  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}

static inline int32_t smod32(int32_t x, int32_t y) {
  int32_t r = x % y;

  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}

static inline int64_t smod64(int64_t x, int64_t y) {
  int64_t r = x % y;

  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}

static inline int8_t sdiv_safe8(int8_t x, int8_t y) {
  return y == 0 ? 0 : sdiv8(x, y);
}

static inline int16_t sdiv_safe16(int16_t x, int16_t y) {
  return y == 0 ? 0 : sdiv16(x, y);
}

static inline int32_t sdiv_safe32(int32_t x, int32_t y) {
  return y == 0 ? 0 : sdiv32(x, y);
}

static inline int64_t sdiv_safe64(int64_t x, int64_t y) {
  return y == 0 ? 0 : sdiv64(x, y);
}

static inline int8_t sdiv_up_safe8(int8_t x, int8_t y) {
  return sdiv_safe8(x + y - 1, y);
}

static inline int16_t sdiv_up_safe16(int16_t x, int16_t y) {
  return sdiv_safe16(x + y - 1, y);
}

static inline int32_t sdiv_up_safe32(int32_t x, int32_t y) {
  return sdiv_safe32(x + y - 1, y);
}

static inline int64_t sdiv_up_safe64(int64_t x, int64_t y) {
  return sdiv_safe64(x + y - 1, y);
}

static inline int8_t smod_safe8(int8_t x, int8_t y) {
  return y == 0 ? 0 : smod8(x, y);
}

static inline int16_t smod_safe16(int16_t x, int16_t y) {
  return y == 0 ? 0 : smod16(x, y);
}

static inline int32_t smod_safe32(int32_t x, int32_t y) {
  return y == 0 ? 0 : smod32(x, y);
}

static inline int64_t smod_safe64(int64_t x, int64_t y) {
  return y == 0 ? 0 : smod64(x, y);
}

static inline int8_t squot8(int8_t x, int8_t y) {
  return x / y;
}

static inline int16_t squot16(int16_t x, int16_t y) {
  return x / y;
}

static inline int32_t squot32(int32_t x, int32_t y) {
  return x / y;
}

static inline int64_t squot64(int64_t x, int64_t y) {
  return x / y;
}

static inline int8_t srem8(int8_t x, int8_t y) {
  return x % y;
}

static inline int16_t srem16(int16_t x, int16_t y) {
  return x % y;
}

static inline int32_t srem32(int32_t x, int32_t y) {
  return x % y;
}

static inline int64_t srem64(int64_t x, int64_t y) {
  return x % y;
}

static inline int8_t squot_safe8(int8_t x, int8_t y) {
  return y == 0 ? 0 : x / y;
}

static inline int16_t squot_safe16(int16_t x, int16_t y) {
  return y == 0 ? 0 : x / y;
}

static inline int32_t squot_safe32(int32_t x, int32_t y) {
  return y == 0 ? 0 : x / y;
}

static inline int64_t squot_safe64(int64_t x, int64_t y) {
  return y == 0 ? 0 : x / y;
}

static inline int8_t srem_safe8(int8_t x, int8_t y) {
  return y == 0 ? 0 : x % y;
}

static inline int16_t srem_safe16(int16_t x, int16_t y) {
  return y == 0 ? 0 : x % y;
}

static inline int32_t srem_safe32(int32_t x, int32_t y) {
  return y == 0 ? 0 : x % y;
}

static inline int64_t srem_safe64(int64_t x, int64_t y) {
  return y == 0 ? 0 : x % y;
}

static inline int8_t smin8(int8_t x, int8_t y) {
  return x < y ? x : y;
}

static inline int16_t smin16(int16_t x, int16_t y) {
  return x < y ? x : y;
}

static inline int32_t smin32(int32_t x, int32_t y) {
  return x < y ? x : y;
}

static inline int64_t smin64(int64_t x, int64_t y) {
  return x < y ? x : y;
}

static inline uint8_t umin8(uint8_t x, uint8_t y) {
  return x < y ? x : y;
}

static inline uint16_t umin16(uint16_t x, uint16_t y) {
  return x < y ? x : y;
}

static inline uint32_t umin32(uint32_t x, uint32_t y) {
  return x < y ? x : y;
}

static inline uint64_t umin64(uint64_t x, uint64_t y) {
  return x < y ? x : y;
}

static inline int8_t smax8(int8_t x, int8_t y) {
  return x < y ? y : x;
}

static inline int16_t smax16(int16_t x, int16_t y) {
  return x < y ? y : x;
}

static inline int32_t smax32(int32_t x, int32_t y) {
  return x < y ? y : x;
}

static inline int64_t smax64(int64_t x, int64_t y) {
  return x < y ? y : x;
}

static inline uint8_t umax8(uint8_t x, uint8_t y) {
  return x < y ? y : x;
}

static inline uint16_t umax16(uint16_t x, uint16_t y) {
  return x < y ? y : x;
}

static inline uint32_t umax32(uint32_t x, uint32_t y) {
  return x < y ? y : x;
}

static inline uint64_t umax64(uint64_t x, uint64_t y) {
  return x < y ? y : x;
}

static inline uint8_t shl8(uint8_t x, uint8_t y) {
  return (uint8_t)(x << y);
}

static inline uint16_t shl16(uint16_t x, uint16_t y) {
  return (uint16_t)(x << y);
}

static inline uint32_t shl32(uint32_t x, uint32_t y) {
  return x << y;
}

static inline uint64_t shl64(uint64_t x, uint64_t y) {
  return x << y;
}

static inline uint8_t lshr8(uint8_t x, uint8_t y) {
  return x >> y;
}

static inline uint16_t lshr16(uint16_t x, uint16_t y) {
  return x >> y;
}

static inline uint32_t lshr32(uint32_t x, uint32_t y) {
  return x >> y;
}

static inline uint64_t lshr64(uint64_t x, uint64_t y) {
  return x >> y;
}

static inline int8_t ashr8(int8_t x, int8_t y) {
  return x >> y;
}

static inline int16_t ashr16(int16_t x, int16_t y) {
  return x >> y;
}

static inline int32_t ashr32(int32_t x, int32_t y) {
  return x >> y;
}

static inline int64_t ashr64(int64_t x, int64_t y) {
  return x >> y;
}

static inline uint8_t and8(uint8_t x, uint8_t y) {
  return x & y;
}

static inline uint16_t and16(uint16_t x, uint16_t y) {
  return x & y;
}

static inline uint32_t and32(uint32_t x, uint32_t y) {
  return x & y;
}

static inline uint64_t and64(uint64_t x, uint64_t y) {
  return x & y;
}

static inline uint8_t or8(uint8_t x, uint8_t y) {
  return x | y;
}

static inline uint16_t or16(uint16_t x, uint16_t y) {
  return x | y;
}

static inline uint32_t or32(uint32_t x, uint32_t y) {
  return x | y;
}

static inline uint64_t or64(uint64_t x, uint64_t y) {
  return x | y;
}

static inline uint8_t xor8(uint8_t x, uint8_t y) {
  return x ^ y;
}

static inline uint16_t xor16(uint16_t x, uint16_t y) {
  return x ^ y;
}

static inline uint32_t xor32(uint32_t x, uint32_t y) {
  return x ^ y;
}

static inline uint64_t xor64(uint64_t x, uint64_t y) {
  return x ^ y;
}

static inline bool ult8(uint8_t x, uint8_t y) {
  return x < y;
}

static inline bool ult16(uint16_t x, uint16_t y) {
  return x < y;
}

static inline bool ult32(uint32_t x, uint32_t y) {
  return x < y;
}

static inline bool ult64(uint64_t x, uint64_t y) {
  return x < y;
}

static inline bool ule8(uint8_t x, uint8_t y) {
  return x <= y;
}

static inline bool ule16(uint16_t x, uint16_t y) {
  return x <= y;
}

static inline bool ule32(uint32_t x, uint32_t y) {
  return x <= y;
}

static inline bool ule64(uint64_t x, uint64_t y) {
  return x <= y;
}

static inline bool slt8(int8_t x, int8_t y) {
  return x < y;
}

static inline bool slt16(int16_t x, int16_t y) {
  return x < y;
}

static inline bool slt32(int32_t x, int32_t y) {
  return x < y;
}

static inline bool slt64(int64_t x, int64_t y) {
  return x < y;
}

static inline bool sle8(int8_t x, int8_t y) {
  return x <= y;
}

static inline bool sle16(int16_t x, int16_t y) {
  return x <= y;
}

static inline bool sle32(int32_t x, int32_t y) {
  return x <= y;
}

static inline bool sle64(int64_t x, int64_t y) {
  return x <= y;
}

static inline uint8_t pow8(uint8_t x, uint8_t y) {
  uint8_t res = 1, rem = y;

  while (rem != 0) {
    if (rem & 1)
      res *= x;
    rem >>= 1;
    x *= x;
  }
  return res;
}

static inline uint16_t pow16(uint16_t x, uint16_t y) {
  uint16_t res = 1, rem = y;

  while (rem != 0) {
    if (rem & 1)
      res *= x;
    rem >>= 1;
    x *= x;
  }
  return res;
}

static inline uint32_t pow32(uint32_t x, uint32_t y) {
  uint32_t res = 1, rem = y;

  while (rem != 0) {
    if (rem & 1)
      res *= x;
    rem >>= 1;
    x *= x;
  }
  return res;
}

static inline uint64_t pow64(uint64_t x, uint64_t y) {
  uint64_t res = 1, rem = y;

  while (rem != 0) {
    if (rem & 1)
      res *= x;
    rem >>= 1;
    x *= x;
  }
  return res;
}

static inline bool itob_i8_bool(int8_t x) {
  return x;
}

static inline bool itob_i16_bool(int16_t x) {
  return x;
}

static inline bool itob_i32_bool(int32_t x) {
  return x;
}

static inline bool itob_i64_bool(int64_t x) {
  return x;
}

static inline int8_t btoi_bool_i8(bool x) {
  return x;
}

static inline int16_t btoi_bool_i16(bool x) {
  return x;
}

static inline int32_t btoi_bool_i32(bool x) {
  return x;
}

static inline int64_t btoi_bool_i64(bool x) {
  return x;
}

#define sext_i8_i8(x) ((int8_t) (int8_t) (x))
#define sext_i8_i16(x) ((int16_t) (int8_t) (x))
#define sext_i8_i32(x) ((int32_t) (int8_t) (x))
#define sext_i8_i64(x) ((int64_t) (int8_t) (x))
#define sext_i16_i8(x) ((int8_t) (int16_t) (x))
#define sext_i16_i16(x) ((int16_t) (int16_t) (x))
#define sext_i16_i32(x) ((int32_t) (int16_t) (x))
#define sext_i16_i64(x) ((int64_t) (int16_t) (x))
#define sext_i32_i8(x) ((int8_t) (int32_t) (x))
#define sext_i32_i16(x) ((int16_t) (int32_t) (x))
#define sext_i32_i32(x) ((int32_t) (int32_t) (x))
#define sext_i32_i64(x) ((int64_t) (int32_t) (x))
#define sext_i64_i8(x) ((int8_t) (int64_t) (x))
#define sext_i64_i16(x) ((int16_t) (int64_t) (x))
#define sext_i64_i32(x) ((int32_t) (int64_t) (x))
#define sext_i64_i64(x) ((int64_t) (int64_t) (x))
#define zext_i8_i8(x) ((int8_t) (uint8_t) (x))
#define zext_i8_i16(x) ((int16_t) (uint8_t) (x))
#define zext_i8_i32(x) ((int32_t) (uint8_t) (x))
#define zext_i8_i64(x) ((int64_t) (uint8_t) (x))
#define zext_i16_i8(x) ((int8_t) (uint16_t) (x))
#define zext_i16_i16(x) ((int16_t) (uint16_t) (x))
#define zext_i16_i32(x) ((int32_t) (uint16_t) (x))
#define zext_i16_i64(x) ((int64_t) (uint16_t) (x))
#define zext_i32_i8(x) ((int8_t) (uint32_t) (x))
#define zext_i32_i16(x) ((int16_t) (uint32_t) (x))
#define zext_i32_i32(x) ((int32_t) (uint32_t) (x))
#define zext_i32_i64(x) ((int64_t) (uint32_t) (x))
#define zext_i64_i8(x) ((int8_t) (uint64_t) (x))
#define zext_i64_i16(x) ((int16_t) (uint64_t) (x))
#define zext_i64_i32(x) ((int32_t) (uint64_t) (x))
#define zext_i64_i64(x) ((int64_t) (uint64_t) (x))

static int8_t abs8(int8_t x) {
  return (int8_t)abs(x);
}

static int16_t abs16(int16_t x) {
  return (int16_t)abs(x);
}

static int32_t abs32(int32_t x) {
  return abs(x);
}

static int64_t abs64(int64_t x) {
#if defined(__OPENCL_VERSION__)
  return abs(x);
#else
  return llabs(x);
#endif
}

#if defined(__OPENCL_VERSION__)
static int32_t futrts_popc8(int8_t x) {
  return popcount(x);
}

static int32_t futrts_popc16(int16_t x) {
  return popcount(x);
}

static int32_t futrts_popc32(int32_t x) {
  return popcount(x);
}

static int32_t futrts_popc64(int64_t x) {
  return popcount(x);
}
#elif defined(__CUDA_ARCH__)

static int32_t futrts_popc8(int8_t x) {
  return __popc(zext_i8_i32(x));
}

static int32_t futrts_popc16(int16_t x) {
  return __popc(zext_i16_i32(x));
}

static int32_t futrts_popc32(int32_t x) {
  return __popc(x);
}

static int32_t futrts_popc64(int64_t x) {
  return __popcll(x);
}

#else // Not OpenCL or CUDA, but plain C.

static int32_t futrts_popc8(uint8_t x) {
  int c = 0;
  for (; x; ++c) { x &= x - 1; }
  return c;
}

static int32_t futrts_popc16(uint16_t x) {
  int c = 0;
  for (; x; ++c) { x &= x - 1; }
  return c;
}

static int32_t futrts_popc32(uint32_t x) {
  int c = 0;
  for (; x; ++c) { x &= x - 1; }
  return c;
}

static int32_t futrts_popc64(uint64_t x) {
  int c = 0;
  for (; x; ++c) { x &= x - 1; }
  return c;
}
#endif

#if defined(__OPENCL_VERSION__)
static uint8_t futrts_mul_hi8(uint8_t a, uint8_t b) {
  return mul_hi(a, b);
}

static uint16_t futrts_mul_hi16(uint16_t a, uint16_t b) {
  return mul_hi(a, b);
}

static uint32_t futrts_mul_hi32(uint32_t a, uint32_t b) {
  return mul_hi(a, b);
}

static uint64_t futrts_mul_hi64(uint64_t a, uint64_t b) {
  return mul_hi(a, b);
}

#elif defined(__CUDA_ARCH__)

static uint8_t futrts_mul_hi8(uint8_t a, uint8_t b) {
  uint16_t aa = a;
  uint16_t bb = b;

  return aa * bb >> 8;
}

static uint16_t futrts_mul_hi16(uint16_t a, uint16_t b) {
  uint32_t aa = a;
  uint32_t bb = b;

  return aa * bb >> 16;
}

static uint32_t futrts_mul_hi32(uint32_t a, uint32_t b) {
  return mulhi(a, b);
}

static uint64_t futrts_mul_hi64(uint64_t a, uint64_t b) {
  return mul64hi(a, b);
}

#else // Not OpenCL or CUDA, but plain C.

static uint8_t futrts_mul_hi8(uint8_t a, uint8_t b) {
  uint16_t aa = a;
  uint16_t bb = b;

  return aa * bb >> 8;
}

static uint16_t futrts_mul_hi16(uint16_t a, uint16_t b) {
  uint32_t aa = a;
  uint32_t bb = b;

  return aa * bb >> 16;
}

static uint32_t futrts_mul_hi32(uint32_t a, uint32_t b) {
  uint64_t aa = a;
  uint64_t bb = b;

  return aa * bb >> 32;
}

static uint64_t futrts_mul_hi64(uint64_t a, uint64_t b) {
  __uint128_t aa = a;
  __uint128_t bb = b;

  return aa * bb >> 64;
}
#endif

#if defined(__OPENCL_VERSION__)
static uint8_t futrts_mad_hi8(uint8_t a, uint8_t b, uint8_t c) {
  return mad_hi(a, b, c);
}

static uint16_t futrts_mad_hi16(uint16_t a, uint16_t b, uint16_t c) {
  return mad_hi(a, b, c);
}

static uint32_t futrts_mad_hi32(uint32_t a, uint32_t b, uint32_t c) {
  return mad_hi(a, b, c);
}

static uint64_t futrts_mad_hi64(uint64_t a, uint64_t b, uint64_t c) {
  return mad_hi(a, b, c);
}

#else // Not OpenCL

static uint8_t futrts_mad_hi8(uint8_t a, uint8_t b, uint8_t c) {
  return futrts_mul_hi8(a, b) + c;
}

static uint16_t futrts_mad_hi16(uint16_t a, uint16_t b, uint16_t c) {
  return futrts_mul_hi16(a, b) + c;
}

static uint32_t futrts_mad_hi32(uint32_t a, uint32_t b, uint32_t c) {
  return futrts_mul_hi32(a, b) + c;
}

static uint64_t futrts_mad_hi64(uint64_t a, uint64_t b, uint64_t c) {
  return futrts_mul_hi64(a, b) + c;
}
#endif

#if defined(__OPENCL_VERSION__)
static int32_t futrts_clzz8(int8_t x) {
  return clz(x);
}

static int32_t futrts_clzz16(int16_t x) {
  return clz(x);
}

static int32_t futrts_clzz32(int32_t x) {
  return clz(x);
}

static int32_t futrts_clzz64(int64_t x) {
  return clz(x);
}

#elif defined(__CUDA_ARCH__)

static int32_t futrts_clzz8(int8_t x) {
  return __clz(zext_i8_i32(x)) - 24;
}

static int32_t futrts_clzz16(int16_t x) {
  return __clz(zext_i16_i32(x)) - 16;
}

static int32_t futrts_clzz32(int32_t x) {
  return __clz(x);
}

static int32_t futrts_clzz64(int64_t x) {
  return __clzll(x);
}

#else // Not OpenCL or CUDA, but plain C.

static int32_t futrts_clzz8(int8_t x) {
  return x == 0 ? 8 : __builtin_clz((uint32_t)zext_i8_i32(x)) - 24;
}

static int32_t futrts_clzz16(int16_t x) {
  return x == 0 ? 16 : __builtin_clz((uint32_t)zext_i16_i32(x)) - 16;
}

static int32_t futrts_clzz32(int32_t x) {
  return x == 0 ? 32 : __builtin_clz((uint32_t)x);
}

static int32_t futrts_clzz64(int64_t x) {
  return x == 0 ? 64 : __builtin_clzll((uint64_t)x);
}
#endif

#if defined(__OPENCL_VERSION__)
static int32_t futrts_ctzz8(int8_t x) {
  int i = 0;
  for (; i < 8 && (x & 1) == 0; i++, x >>= 1)
    ;
  return i;
}

static int32_t futrts_ctzz16(int16_t x) {
  int i = 0;
  for (; i < 16 && (x & 1) == 0; i++, x >>= 1)
    ;
  return i;
}

static int32_t futrts_ctzz32(int32_t x) {
  int i = 0;
  for (; i < 32 && (x & 1) == 0; i++, x >>= 1)
    ;
  return i;
}

static int32_t futrts_ctzz64(int64_t x) {
  int i = 0;
  for (; i < 64 && (x & 1) == 0; i++, x >>= 1)
    ;
  return i;
}

#elif defined(__CUDA_ARCH__)

static int32_t futrts_ctzz8(int8_t x) {
  int y = __ffs(x);
  return y == 0 ? 8 : y - 1;
}

static int32_t futrts_ctzz16(int16_t x) {
  int y = __ffs(x);
  return y == 0 ? 16 : y - 1;
}

static int32_t futrts_ctzz32(int32_t x) {
  int y = __ffs(x);
  return y == 0 ? 32 : y - 1;
}

static int32_t futrts_ctzz64(int64_t x) {
  int y = __ffsll(x);
  return y == 0 ? 64 : y - 1;
}

#else // Not OpenCL or CUDA, but plain C.

static int32_t futrts_ctzz8(int8_t x) {
  return x == 0 ? 8 : __builtin_ctz((uint32_t)x);
}

static int32_t futrts_ctzz16(int16_t x) {
  return x == 0 ? 16 : __builtin_ctz((uint32_t)x);
}

static int32_t futrts_ctzz32(int32_t x) {
  return x == 0 ? 32 : __builtin_ctz((uint32_t)x);
}

static int32_t futrts_ctzz64(int64_t x) {
  return x == 0 ? 64 : __builtin_ctzll((uint64_t)x);
}
#endif

static inline float fdiv32(float x, float y) {
  return x / y;
}

static inline float fadd32(float x, float y) {
  return x + y;
}

static inline float fsub32(float x, float y) {
  return x - y;
}

static inline float fmul32(float x, float y) {
  return x * y;
}

static inline bool cmplt32(float x, float y) {
  return x < y;
}

static inline bool cmple32(float x, float y) {
  return x <= y;
}

static inline float sitofp_i8_f32(int8_t x) {
  return (float) x;
}

static inline float sitofp_i16_f32(int16_t x) {
  return (float) x;
}

static inline float sitofp_i32_f32(int32_t x) {
  return (float) x;
}

static inline float sitofp_i64_f32(int64_t x) {
  return (float) x;
}

static inline float uitofp_i8_f32(uint8_t x) {
  return (float) x;
}

static inline float uitofp_i16_f32(uint16_t x) {
  return (float) x;
}

static inline float uitofp_i32_f32(uint32_t x) {
  return (float) x;
}

static inline float uitofp_i64_f32(uint64_t x) {
  return (float) x;
}

#ifdef __OPENCL_VERSION__
static inline float fabs32(float x) {
  return fabs(x);
}

static inline float fmax32(float x, float y) {
  return fmax(x, y);
}

static inline float fmin32(float x, float y) {
  return fmin(x, y);
}

static inline float fpow32(float x, float y) {
  return pow(x, y);
}

#else // Not OpenCL, but CUDA or plain C.

static inline float fabs32(float x) {
  return fabsf(x);
}

static inline float fmax32(float x, float y) {
  return fmaxf(x, y);
}

static inline float fmin32(float x, float y) {
  return fminf(x, y);
}

static inline float fpow32(float x, float y) {
  return powf(x, y);
}
#endif

static inline bool futrts_isnan32(float x) {
  return isnan(x);
}

static inline bool futrts_isinf32(float x) {
  return isinf(x);
}

static inline int8_t fptosi_f32_i8(float x) {
  if (futrts_isnan32(x) || futrts_isinf32(x)) {
    return 0;
  } else {
    return (int8_t) x;
  }
}

static inline int16_t fptosi_f32_i16(float x) {
  if (futrts_isnan32(x) || futrts_isinf32(x)) {
    return 0;
  } else {
    return (int16_t) x;
  }
}

static inline int32_t fptosi_f32_i32(float x) {
  if (futrts_isnan32(x) || futrts_isinf32(x)) {
    return 0;
  } else {
    return (int32_t) x;
  }
}

static inline int64_t fptosi_f32_i64(float x) {
  if (futrts_isnan32(x) || futrts_isinf32(x)) {
    return 0;
  } else {
    return (int64_t) x;
  };
}

static inline uint8_t fptoui_f32_i8(float x) {
  if (futrts_isnan32(x) || futrts_isinf32(x)) {
    return 0;
  } else {
    return (uint8_t) (int8_t) x;
  }
}

static inline uint16_t fptoui_f32_i16(float x) {
  if (futrts_isnan32(x) || futrts_isinf32(x)) {
    return 0;
  } else {
    return (uint16_t) (int16_t) x;
  }
}

static inline uint32_t fptoui_f32_i32(float x) {
  if (futrts_isnan32(x) || futrts_isinf32(x)) {
    return 0;
  } else {
    return (uint32_t) (int32_t) x;
  }
}

static inline uint64_t fptoui_f32_i64(float x) {
  if (futrts_isnan32(x) || futrts_isinf32(x)) {
    return 0;
  } else {
    return (uint64_t) (int64_t) x;
  }
}

static inline bool ftob_f32_bool(float x) {
  return x != 0;
}

static inline float btof_bool_f32(bool x) {
  return x ? 1 : 0;
}

#ifdef __OPENCL_VERSION__
static inline float futrts_log32(float x) {
  return log(x);
}

static inline float futrts_log2_32(float x) {
  return log2(x);
}

static inline float futrts_log10_32(float x) {
  return log10(x);
}

static inline float futrts_sqrt32(float x) {
  return sqrt(x);
}

static inline float futrts_exp32(float x) {
  return exp(x);
}

static inline float futrts_cos32(float x) {
  return cos(x);
}

static inline float futrts_sin32(float x) {
  return sin(x);
}

static inline float futrts_tan32(float x) {
  return tan(x);
}

static inline float futrts_acos32(float x) {
  return acos(x);
}

static inline float futrts_asin32(float x) {
  return asin(x);
}

static inline float futrts_atan32(float x) {
  return atan(x);
}

static inline float futrts_cosh32(float x) {
  return cosh(x);
}

static inline float futrts_sinh32(float x) {
  return sinh(x);
}

static inline float futrts_tanh32(float x) {
  return tanh(x);
}

static inline float futrts_acosh32(float x) {
  return acosh(x);
}

static inline float futrts_asinh32(float x) {
  return asinh(x);
}

static inline float futrts_atanh32(float x) {
  return atanh(x);
}

static inline float futrts_atan2_32(float x, float y) {
  return atan2(x, y);
}

static inline float futrts_hypot32(float x, float y) {
  return hypot(x, y);
}

static inline float futrts_gamma32(float x) {
  return tgamma(x);
}

static inline float futrts_lgamma32(float x) {
  return lgamma(x);
}

static inline float fmod32(float x, float y) {
  return fmod(x, y);
}

static inline float futrts_round32(float x) {
  return rint(x);
}

static inline float futrts_floor32(float x) {
  return floor(x);
}

static inline float futrts_ceil32(float x) {
  return ceil(x);
}

static inline float futrts_lerp32(float v0, float v1, float t) {
  return mix(v0, v1, t);
}

static inline float futrts_mad32(float a, float b, float c) {
  return mad(a, b, c);
}

static inline float futrts_fma32(float a, float b, float c) {
  return fma(a, b, c);
}

#else // Not OpenCL, but CUDA or plain C.

static inline float futrts_log32(float x) {
  return logf(x);
}

static inline float futrts_log2_32(float x) {
  return log2f(x);
}

static inline float futrts_log10_32(float x) {
  return log10f(x);
}

static inline float futrts_sqrt32(float x) {
  return sqrtf(x);
}

static inline float futrts_exp32(float x) {
  return expf(x);
}

static inline float futrts_cos32(float x) {
  return cosf(x);
}

static inline float futrts_sin32(float x) {
  return sinf(x);
}

static inline float futrts_tan32(float x) {
  return tanf(x);
}

static inline float futrts_acos32(float x) {
  return acosf(x);
}

static inline float futrts_asin32(float x) {
  return asinf(x);
}

static inline float futrts_atan32(float x) {
  return atanf(x);
}

static inline float futrts_cosh32(float x) {
  return coshf(x);
}

static inline float futrts_sinh32(float x) {
  return sinhf(x);
}

static inline float futrts_tanh32(float x) {
  return tanhf(x);
}

static inline float futrts_acosh32(float x) {
  return acoshf(x);
}

static inline float futrts_asinh32(float x) {
  return asinhf(x);
}

static inline float futrts_atanh32(float x) {
  return atanhf(x);
}

static inline float futrts_atan2_32(float x, float y) {
  return atan2f(x, y);
}

static inline float futrts_hypot32(float x, float y) {
  return hypotf(x, y);
}

static inline float futrts_gamma32(float x) {
  return tgammaf(x);
}

static inline float futrts_lgamma32(float x) {
  return lgammaf(x);
}

static inline float fmod32(float x, float y) {
  return fmodf(x, y);
}

static inline float futrts_round32(float x) {
  return rintf(x);
}

static inline float futrts_floor32(float x) {
  return floorf(x);
}

static inline float futrts_ceil32(float x) {
  return ceilf(x);
}

static inline float futrts_lerp32(float v0, float v1, float t) {
  return v0 + (v1 - v0) * t;
}

static inline float futrts_mad32(float a, float b, float c) {
  return a * b + c;
}

static inline float futrts_fma32(float a, float b, float c) {
  return fmaf(a, b, c);
}
#endif

static inline int32_t futrts_to_bits32(float x) {
  union {
    float f;
    int32_t t;
  } p;

  p.f = x;
  return p.t;
}

static inline float futrts_from_bits32(int32_t x) {
  union {
    int32_t f;
    float t;
  } p;

  p.f = x;
  return p.t;
}

static inline float fsignum32(float x) {
  return futrts_isnan32(x) ? x : (x > 0) - (x < 0);
}

#ifdef FUTHARK_F64_ENABLED

static inline double fdiv64(double x, double y) {
  return x / y;
}

static inline double fadd64(double x, double y) {
  return x + y;
}

static inline double fsub64(double x, double y) {
  return x - y;
}

static inline double fmul64(double x, double y) {
  return x * y;
}

static inline bool cmplt64(double x, double y) {
  return x < y;
}

static inline bool cmple64(double x, double y) {
  return x <= y;
}

static inline double sitofp_i8_f64(int8_t x) {
  return (double) x;
}

static inline double sitofp_i16_f64(int16_t x) {
  return (double) x;
}

static inline double sitofp_i32_f64(int32_t x) {
  return (double) x;
}

static inline double sitofp_i64_f64(int64_t x) {
  return (double) x;
}

static inline double uitofp_i8_f64(uint8_t x) {
  return (double) x;
}

static inline double uitofp_i16_f64(uint16_t x) {
  return (double) x;
}

static inline double uitofp_i32_f64(uint32_t x) {
  return (double) x;
}

static inline double uitofp_i64_f64(uint64_t x) {
  return (double) x;
}

static inline double fabs64(double x) {
  return fabs(x);
}

static inline double fmax64(double x, double y) {
  return fmax(x, y);
}

static inline double fmin64(double x, double y) {
  return fmin(x, y);
}

static inline double fpow64(double x, double y) {
  return pow(x, y);
}

static inline double futrts_log64(double x) {
  return log(x);
}

static inline double futrts_log2_64(double x) {
  return log2(x);
}

static inline double futrts_log10_64(double x) {
  return log10(x);
}

static inline double futrts_sqrt64(double x) {
  return sqrt(x);
}

static inline double futrts_exp64(double x) {
  return exp(x);
}

static inline double futrts_cos64(double x) {
  return cos(x);
}

static inline double futrts_sin64(double x) {
  return sin(x);
}

static inline double futrts_tan64(double x) {
  return tan(x);
}

static inline double futrts_acos64(double x) {
  return acos(x);
}

static inline double futrts_asin64(double x) {
  return asin(x);
}

static inline double futrts_atan64(double x) {
  return atan(x);
}

static inline double futrts_cosh64(double x) {
  return cosh(x);
}

static inline double futrts_sinh64(double x) {
  return sinh(x);
}

static inline double futrts_tanh64(double x) {
  return tanh(x);
}

static inline double futrts_acosh64(double x) {
  return acosh(x);
}

static inline double futrts_asinh64(double x) {
  return asinh(x);
}

static inline double futrts_atanh64(double x) {
  return atanh(x);
}

static inline double futrts_atan2_64(double x, double y) {
  return atan2(x, y);
}

static inline double futrts_hypot64(double x, double y) {
  return hypot(x, y);
}

static inline double futrts_gamma64(double x) {
  return tgamma(x);
}

static inline double futrts_lgamma64(double x) {
  return lgamma(x);
}

static inline double futrts_fma64(double a, double b, double c) {
  return fma(a, b, c);
}

static inline double futrts_round64(double x) {
  return rint(x);
}

static inline double futrts_ceil64(double x) {
  return ceil(x);
}

static inline double futrts_floor64(double x) {
  return floor(x);
}

static inline bool futrts_isnan64(double x) {
  return isnan(x);
}

static inline bool futrts_isinf64(double x) {
  return isinf(x);
}

static inline int8_t fptosi_f64_i8(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (int8_t) x;
  }
}

static inline int16_t fptosi_f64_i16(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (int16_t) x;
  }
}

static inline int32_t fptosi_f64_i32(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (int32_t) x;
  }
}

static inline int64_t fptosi_f64_i64(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (int64_t) x;
  }
}

static inline uint8_t fptoui_f64_i8(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (uint8_t) (int8_t) x;
  }
}

static inline uint16_t fptoui_f64_i16(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (uint16_t) (int16_t) x;
  }
}

static inline uint32_t fptoui_f64_i32(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (uint32_t) (int32_t) x;
  }
}

static inline uint64_t fptoui_f64_i64(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (uint64_t) (int64_t) x;
  }
}

static inline bool ftob_f64_bool(double x) {
  return x != 0;
}

static inline double btof_bool_f64(bool x) {
  return x ? 1 : 0;
}

static inline int64_t futrts_to_bits64(double x) {
  union {
    double f;
    int64_t t;
  } p;

  p.f = x;
  return p.t;
}

static inline double futrts_from_bits64(int64_t x) {
  union {
    int64_t f;
    double t;
  } p;

  p.f = x;
  return p.t;
}

static inline double fmod64(double x, double y) {
  return fmod(x, y);
}

static inline double fsignum64(double x) {
  return futrts_isnan64(x) ? x : (x > 0) - (x < 0);
}

static inline double futrts_lerp64(double v0, double v1, double t) {
#ifdef __OPENCL_VERSION__
  return mix(v0, v1, t);
#else
  return v0 + (v1 - v0) * t;
#endif
}

static inline double futrts_mad64(double a, double b, double c) {
#ifdef __OPENCL_VERSION__
  return mad(a, b, c);
#else
  return a * b + c;
#endif
}

static inline float fpconv_f32_f32(float x) {
  return (float) x;
}

static inline double fpconv_f32_f64(float x) {
  return (double) x;
}

static inline float fpconv_f64_f32(double x) {
  return (float) x;
}

static inline double fpconv_f64_f64(double x) {
  return (double) x;
}

#endif

// End of scalar.h.
// Start of scalar_f16.h.

// Half-precision is emulated if needed (e.g. in straight C) with the
// native type used if possible.  The emulation works by typedef'ing
// 'float' to 'f16', and then implementing all operations on single
// precision.  To cut down on duplication, we use the same code for
// those Futhark functions that require just operators or casts.  The
// in-memory representation for arrays will still be 16 bits even
// under emulation, so the compiler will have to be careful when
// generating reads or writes.

#if !defined(cl_khr_fp16) && !(defined(__CUDA_ARCH__) && __CUDA_ARCH__ >= 600)
#define EMULATE_F16
#endif

#if !defined(EMULATE_F16) && defined(__OPENCL_VERSION__)
#pragma OPENCL EXTENSION cl_khr_fp16 : enable
#endif

#ifdef EMULATE_F16

// Note that the half-precision storage format is still 16 bits - the
// compiler will have to be real careful!
typedef float f16;

#else

#ifdef __CUDA_ARCH__
#include <cuda_fp16.h>
#endif

typedef half f16;

#endif

// Some of these functions convert to single precision because half
// precision versions are not available.

static inline f16 fadd16(f16 x, f16 y) {
  return x + y;
}

static inline f16 fsub16(f16 x, f16 y) {
  return x - y;
}

static inline f16 fmul16(f16 x, f16 y) {
  return x * y;
}

static inline bool cmplt16(f16 x, f16 y) {
  return x < y;
}

static inline bool cmple16(f16 x, f16 y) {
  return x <= y;
}

static inline f16 sitofp_i8_f16(int8_t x) {
  return (f16) x;
}

static inline f16 sitofp_i16_f16(int16_t x) {
  return (f16) x;
}

static inline f16 sitofp_i32_f16(int32_t x) {
  return (f16) x;
}

static inline f16 sitofp_i64_f16(int64_t x) {
  return (f16) x;
}

static inline f16 uitofp_i8_f16(uint8_t x) {
  return (f16) x;
}

static inline f16 uitofp_i16_f16(uint16_t x) {
  return (f16) x;
}

static inline f16 uitofp_i32_f16(uint32_t x) {
  return (f16) x;
}

static inline f16 uitofp_i64_f16(uint64_t x) {
  return (f16) x;
}

static inline int8_t fptosi_f16_i8(f16 x) {
  return (int8_t) (float) x;
}

static inline int16_t fptosi_f16_i16(f16 x) {
  return (int16_t) x;
}

static inline int32_t fptosi_f16_i32(f16 x) {
  return (int32_t) x;
}

static inline int64_t fptosi_f16_i64(f16 x) {
  return (int64_t) x;
}

static inline uint8_t fptoui_f16_i8(f16 x) {
  return (uint8_t) (float) x;
}

static inline uint16_t fptoui_f16_i16(f16 x) {
  return (uint16_t) x;
}

static inline uint32_t fptoui_f16_i32(f16 x) {
  return (uint32_t) x;
}

static inline uint64_t fptoui_f16_i64(f16 x) {
  return (uint64_t) x;
}

static inline bool ftob_f16_bool(f16 x) {
  return x != (f16)0;
}

static inline f16 btof_bool_f16(bool x) {
  return x ? 1 : 0;
}

#ifndef EMULATE_F16

#ifdef __OPENCL_VERSION__
static inline f16 fabs16(f16 x) {
  return fabs(x);
}

static inline f16 fmax16(f16 x, f16 y) {
  return fmax(x, y);
}

static inline f16 fmin16(f16 x, f16 y) {
  return fmin(x, y);
}

static inline f16 fpow16(f16 x, f16 y) {
  return pow(x, y);
}

#else // Assuming CUDA.

static inline f16 fabs16(f16 x) {
  return fabsf(x);
}

static inline f16 fmax16(f16 x, f16 y) {
  return fmaxf(x, y);
}

static inline f16 fmin16(f16 x, f16 y) {
  return fminf(x, y);
}

static inline f16 fpow16(f16 x, f16 y) {
  return powf(x, y);
}
#endif

static inline bool futrts_isnan16(f16 x) {
  return isnan((float)x);
}

static inline bool futrts_isinf16(f16 x) {
  return isinf((float)x);
}

#ifdef __OPENCL_VERSION__
static inline f16 futrts_log16(f16 x) {
  return log(x);
}

static inline f16 futrts_log2_16(f16 x) {
  return log2(x);
}

static inline f16 futrts_log10_16(f16 x) {
  return log10(x);
}

static inline f16 futrts_sqrt16(f16 x) {
  return sqrt(x);
}

static inline f16 futrts_exp16(f16 x) {
  return exp(x);
}

static inline f16 futrts_cos16(f16 x) {
  return cos(x);
}

static inline f16 futrts_sin16(f16 x) {
  return sin(x);
}

static inline f16 futrts_tan16(f16 x) {
  return tan(x);
}

static inline f16 futrts_acos16(f16 x) {
  return acos(x);
}

static inline f16 futrts_asin16(f16 x) {
  return asin(x);
}

static inline f16 futrts_atan16(f16 x) {
  return atan(x);
}

static inline f16 futrts_cosh16(f16 x) {
  return cosh(x);
}

static inline f16 futrts_sinh16(f16 x) {
  return sinh(x);
}

static inline f16 futrts_tanh16(f16 x) {
  return tanh(x);
}

static inline f16 futrts_acosh16(f16 x) {
  return acosh(x);
}

static inline f16 futrts_asinh16(f16 x) {
  return asinh(x);
}

static inline f16 futrts_atanh16(f16 x) {
  return atanh(x);
}

static inline f16 futrts_atan2_16(f16 x, f16 y) {
  return atan2(x, y);
}

static inline f16 futrts_hypot16(f16 x, f16 y) {
  return hypot(x, y);
}

static inline f16 futrts_gamma16(f16 x) {
  return tgamma(x);
}

static inline f16 futrts_lgamma16(f16 x) {
  return lgamma(x);
}

static inline f16 fmod16(f16 x, f16 y) {
  return fmod(x, y);
}

static inline f16 futrts_round16(f16 x) {
  return rint(x);
}

static inline f16 futrts_floor16(f16 x) {
  return floor(x);
}

static inline f16 futrts_ceil16(f16 x) {
  return ceil(x);
}

static inline f16 futrts_lerp16(f16 v0, f16 v1, f16 t) {
  return mix(v0, v1, t);
}

static inline f16 futrts_mad16(f16 a, f16 b, f16 c) {
  return mad(a, b, c);
}

static inline f16 futrts_fma16(f16 a, f16 b, f16 c) {
  return fma(a, b, c);
}

#else // Assume CUDA.

static inline f16 futrts_log16(f16 x) {
  return hlog(x);
}

static inline f16 futrts_log2_16(f16 x) {
  return hlog2(x);
}

static inline f16 futrts_log10_16(f16 x) {
  return hlog10(x);
}

static inline f16 futrts_sqrt16(f16 x) {
  return hsqrt(x);
}

static inline f16 futrts_exp16(f16 x) {
  return hexp(x);
}

static inline f16 futrts_cos16(f16 x) {
  return hcos(x);
}

static inline f16 futrts_sin16(f16 x) {
  return hsin(x);
}

static inline f16 futrts_tan16(f16 x) {
  return tanf(x);
}

static inline f16 futrts_acos16(f16 x) {
  return acosf(x);
}

static inline f16 futrts_asin16(f16 x) {
  return asinf(x);
}

static inline f16 futrts_atan16(f16 x) {
  return atanf(x);
}

static inline f16 futrts_cosh16(f16 x) {
  return coshf(x);
}

static inline f16 futrts_sinh16(f16 x) {
  return sinhf(x);
}

static inline f16 futrts_tanh16(f16 x) {
  return tanhf(x);
}

static inline f16 futrts_acosh16(f16 x) {
  return acoshf(x);
}

static inline f16 futrts_asinh16(f16 x) {
  return asinhf(x);
}

static inline f16 futrts_atanh16(f16 x) {
  return atanhf(x);
}

static inline f16 futrts_atan2_16(f16 x, f16 y) {
  return atan2f(x, y);
}

static inline f16 futrts_hypot16(f16 x, f16 y) {
  return hypotf(x, y);
}

static inline f16 futrts_gamma16(f16 x) {
  return tgammaf(x);
}

static inline f16 futrts_lgamma16(f16 x) {
  return lgammaf(x);
}

static inline f16 fmod16(f16 x, f16 y) {
  return fmodf(x, y);
}

static inline f16 futrts_round16(f16 x) {
  return rintf(x);
}

static inline f16 futrts_floor16(f16 x) {
  return hfloor(x);
}

static inline f16 futrts_ceil16(f16 x) {
  return hceil(x);
}

static inline f16 futrts_lerp16(f16 v0, f16 v1, f16 t) {
  return v0 + (v1 - v0) * t;
}

static inline f16 futrts_mad16(f16 a, f16 b, f16 c) {
  return a * b + c;
}

static inline f16 futrts_fma16(f16 a, f16 b, f16 c) {
  return fmaf(a, b, c);
}

#endif

// The CUDA __half type cannot be put in unions for some reason, so we
// use bespoke conversion functions instead.
#ifdef __CUDA_ARCH__
static inline int16_t futrts_to_bits16(f16 x) {
  return __half_as_ushort(x);
}
static inline f16 futrts_from_bits16(int16_t x) {
  return __ushort_as_half(x);
}
#else
static inline int16_t futrts_to_bits16(f16 x) {
  union {
    f16 f;
    int16_t t;
  } p;

  p.f = x;
  return p.t;
}

static inline f16 futrts_from_bits16(int16_t x) {
  union {
    int16_t f;
    f16 t;
  } p;

  p.f = x;
  return p.t;
}
#endif

#else // No native f16 - emulate.

static inline f16 fabs16(f16 x) {
  return fabs32(x);
}

static inline f16 fmax16(f16 x, f16 y) {
  return fmax32(x, y);
}

static inline f16 fmin16(f16 x, f16 y) {
  return fmin32(x, y);
}

static inline f16 fpow16(f16 x, f16 y) {
  return fpow32(x, y);
}

static inline bool futrts_isnan16(f16 x) {
  return futrts_isnan32(x);
}

static inline bool futrts_isinf16(f16 x) {
  return futrts_isinf32(x);
}

static inline f16 futrts_log16(f16 x) {
  return futrts_log32(x);
}

static inline f16 futrts_log2_16(f16 x) {
  return futrts_log2_32(x);
}

static inline f16 futrts_log10_16(f16 x) {
  return futrts_log10_32(x);
}

static inline f16 futrts_sqrt16(f16 x) {
  return futrts_sqrt32(x);
}

static inline f16 futrts_exp16(f16 x) {
  return futrts_exp32(x);
}

static inline f16 futrts_cos16(f16 x) {
  return futrts_cos32(x);
}

static inline f16 futrts_sin16(f16 x) {
  return futrts_sin32(x);
}

static inline f16 futrts_tan16(f16 x) {
  return futrts_tan32(x);
}

static inline f16 futrts_acos16(f16 x) {
  return futrts_acos32(x);
}

static inline f16 futrts_asin16(f16 x) {
  return futrts_asin32(x);
}

static inline f16 futrts_atan16(f16 x) {
  return futrts_atan32(x);
}

static inline f16 futrts_cosh16(f16 x) {
  return futrts_cosh32(x);
}

static inline f16 futrts_sinh16(f16 x) {
  return futrts_sinh32(x);
}

static inline f16 futrts_tanh16(f16 x) {
  return futrts_tanh32(x);
}

static inline f16 futrts_acosh16(f16 x) {
  return futrts_acosh32(x);
}

static inline f16 futrts_asinh16(f16 x) {
  return futrts_asinh32(x);
}

static inline f16 futrts_atanh16(f16 x) {
  return futrts_atanh32(x);
}

static inline f16 futrts_atan2_16(f16 x, f16 y) {
  return futrts_atan2_32(x, y);
}

static inline f16 futrts_hypot16(f16 x, f16 y) {
  return futrts_hypot32(x, y);
}

static inline f16 futrts_gamma16(f16 x) {
  return futrts_gamma32(x);
}

static inline f16 futrts_lgamma16(f16 x) {
  return futrts_lgamma32(x);
}

static inline f16 fmod16(f16 x, f16 y) {
  return fmod32(x, y);
}

static inline f16 futrts_round16(f16 x) {
  return futrts_round32(x);
}

static inline f16 futrts_floor16(f16 x) {
  return futrts_floor32(x);
}

static inline f16 futrts_ceil16(f16 x) {
  return futrts_ceil32(x);
}

static inline f16 futrts_lerp16(f16 v0, f16 v1, f16 t) {
  return futrts_lerp32(v0, v1, t);
}

static inline f16 futrts_mad16(f16 a, f16 b, f16 c) {
  return futrts_mad32(a, b, c);
}

static inline f16 futrts_fma16(f16 a, f16 b, f16 c) {
  return futrts_fma32(a, b, c);
}

// Even when we are using an OpenCL that does not support cl_khr_fp16,
// it must still support vload_half for actually creating a
// half-precision number, which can then be efficiently converted to a
// float.  Similarly for vstore_half.
#ifdef __OPENCL_VERSION__

static inline int16_t futrts_to_bits16(f16 x) {
  int16_t y;
  // Violating strict aliasing here.
  vstore_half((float)x, 0, (half*)&y);
  return y;
}

static inline f16 futrts_from_bits16(int16_t x) {
  return (f16)vload_half(0, (half*)&x);
}

#else

static inline int16_t futrts_to_bits16(f16 x) {
  return (int16_t)float2halfbits(x);
}

static inline f16 futrts_from_bits16(int16_t x) {
  return halfbits2float((uint16_t)x);
}

static inline f16 fsignum16(f16 x) {
  return futrts_isnan16(x) ? x : (x > 0) - (x < 0);
}

#endif

#endif

static inline float fpconv_f16_f16(f16 x) {
  return x;
}

static inline float fpconv_f16_f32(f16 x) {
  return x;
}

static inline f16 fpconv_f32_f16(float x) {
  return x;
}

#ifdef FUTHARK_F64_ENABLED

static inline double fpconv_f16_f64(f16 x) {
  return (double) x;
}

static inline f16 fpconv_f64_f16(double x) {
  return (f16) x;
}

#endif


// End of scalar_f16.h.

static int init_constants(struct futhark_context *);
static int free_constants(struct futhark_context *);
static int32_t mainzistatic_array_realtype_30812[3] = {2, 0, 0};
struct memblock {
    int *references;
    unsigned char *mem;
    int64_t size;
    const char *desc;
};
struct futhark_context_config {
    int debugging;
    int in_use;
};
struct futhark_context_config *futhark_context_config_new(void)
{
    struct futhark_context_config *cfg =
                                  (struct futhark_context_config *) malloc(sizeof(struct futhark_context_config));
    
    if (cfg == NULL)
        return NULL;
    cfg->in_use = 0;
    cfg->debugging = 0;
    return cfg;
}
void futhark_context_config_free(struct futhark_context_config *cfg)
{
    assert(!cfg->in_use);
    free(cfg);
}
void futhark_context_config_set_debugging(struct futhark_context_config *cfg,
                                          int detail)
{
    cfg->debugging = detail;
}
void futhark_context_config_set_profiling(struct futhark_context_config *cfg,
                                          int flag)
{
    (void) cfg;
    (void) flag;
}
void futhark_context_config_set_logging(struct futhark_context_config *cfg,
                                        int detail)
{
    // Does nothing for this backend.
    (void) cfg;
    (void) detail;
}
struct futhark_context {
    struct futhark_context_config *cfg;
    int detail_memory;
    int debugging;
    int profiling;
    int logging;
    lock_t lock;
    char *error;
    FILE *log;
    int profiling_paused;
    int64_t peak_mem_usage_default;
    int64_t cur_mem_usage_default;
    struct {
        int dummy;
    } constants;
    struct memblock mainzistatic_array_30725;
};
struct futhark_context *futhark_context_new(struct futhark_context_config *cfg)
{
    assert(!cfg->in_use);
    
    struct futhark_context *ctx =
                           (struct futhark_context *) malloc(sizeof(struct futhark_context));
    
    if (ctx == NULL)
        return NULL;
    ctx->cfg = cfg;
    ctx->cfg->in_use = 1;
    ctx->detail_memory = cfg->debugging;
    ctx->debugging = cfg->debugging;
    ctx->profiling = cfg->debugging;
    ctx->logging = cfg->debugging;
    ctx->error = NULL;
    ctx->log = stderr;
    create_lock(&ctx->lock);
    ctx->peak_mem_usage_default = 0;
    ctx->cur_mem_usage_default = 0;
    ctx->mainzistatic_array_30725 = (struct memblock) {NULL,
                                                       (char *) mainzistatic_array_realtype_30812,
                                                       0};
    init_constants(ctx);
    return ctx;
}
void futhark_context_free(struct futhark_context *ctx)
{
    free_constants(ctx);
    free_lock(&ctx->lock);
    ctx->cfg->in_use = 0;
    free(ctx);
}
int futhark_context_sync(struct futhark_context *ctx)
{
    (void) ctx;
    return 0;
}
static const char *tuning_param_names[0];
static const char *tuning_param_vars[0];
static const char *tuning_param_classes[0];
int futhark_context_config_set_tuning_param(struct futhark_context_config *cfg,
                                            const char *param_name,
                                            size_t param_value)
{
    (void) cfg;
    (void) param_name;
    (void) param_value;
    return 1;
}
static int memblock_unref(struct futhark_context *ctx, struct memblock *block,
                          const char *desc)
{
    if (block->references != NULL) {
        *block->references -= 1;
        if (ctx->detail_memory)
            fprintf(ctx->log,
                    "Unreferencing block %s (allocated as %s) in %s: %d references remaining.\n",
                    desc, block->desc, "default space", *block->references);
        if (*block->references == 0) {
            ctx->cur_mem_usage_default -= block->size;
            free(block->mem);
            free(block->references);
            if (ctx->detail_memory)
                fprintf(ctx->log,
                        "%lld bytes freed (now allocated: %lld bytes)\n",
                        (long long) block->size,
                        (long long) ctx->cur_mem_usage_default);
        }
        block->references = NULL;
    }
    return 0;
}
static int memblock_alloc(struct futhark_context *ctx, struct memblock *block,
                          int64_t size, const char *desc)
{
    if (size < 0)
        futhark_panic(1,
                      "Negative allocation of %lld bytes attempted for %s in %s.\n",
                      (long long) size, desc, "default space",
                      ctx->cur_mem_usage_default);
    
    int ret = memblock_unref(ctx, block, desc);
    
    if (ret != FUTHARK_SUCCESS)
        return ret;
    if (ctx->detail_memory)
        fprintf(ctx->log,
                "Allocating %lld bytes for %s in %s (then allocated: %lld bytes)",
                (long long) size, desc, "default space",
                (long long) ctx->cur_mem_usage_default + size);
    if (ctx->cur_mem_usage_default > ctx->peak_mem_usage_default) {
        ctx->peak_mem_usage_default = ctx->cur_mem_usage_default;
        if (ctx->detail_memory)
            fprintf(ctx->log, " (new peak).\n");
    } else if (ctx->detail_memory)
        fprintf(ctx->log, ".\n");
    block->mem = (unsigned char *) malloc((size_t) size);
    if (ctx->error == NULL) {
        block->references = (int *) malloc(sizeof(int));
        *block->references = 1;
        block->size = size;
        block->desc = desc;
        ctx->cur_mem_usage_default += size;
        return FUTHARK_SUCCESS;
    } else {
        char *old_error = ctx->error;
        
        ctx->error =
            msgprintf("Failed to allocate memory in %s.\nAttempted allocation: %12lld bytes\nCurrently allocated:  %12lld bytes\n%s",
                      "default space", (long long) size,
                      (long long) ctx->cur_mem_usage_default, old_error);
        free(old_error);
        return FUTHARK_OUT_OF_MEMORY;
    }
}
static int memblock_set(struct futhark_context *ctx, struct memblock *lhs,
                        struct memblock *rhs, const char *lhs_desc)
{
    int ret = memblock_unref(ctx, lhs, lhs_desc);
    
    if (rhs->references != NULL)
        (*rhs->references)++;
    *lhs = *rhs;
    return ret;
}
int futhark_get_tuning_param_count(void)
{
    return sizeof(tuning_param_names) / sizeof(tuning_param_names[0]);
}
const char *futhark_get_tuning_param_name(int i)
{
    return tuning_param_names[i];
}
const char *futhark_get_tuning_param_class(int i)
{
    return tuning_param_classes[i];
}
char *futhark_context_report(struct futhark_context *ctx)
{
    if (futhark_context_sync(ctx) != 0)
        return NULL;
    
    struct str_builder builder;
    
    str_builder_init(&builder);
    if (ctx->detail_memory || ctx->profiling || ctx->logging) {
        { }
    }
    if (ctx->profiling) { }
    return builder.str;
}
char *futhark_context_get_error(struct futhark_context *ctx)
{
    char *error = ctx->error;
    
    ctx->error = NULL;
    return error;
}
void futhark_context_set_logging_file(struct futhark_context *ctx, FILE *f)
{
    ctx->log = f;
}
void futhark_context_pause_profiling(struct futhark_context *ctx)
{
    ctx->profiling_paused = 1;
}
void futhark_context_unpause_profiling(struct futhark_context *ctx)
{
    ctx->profiling_paused = 0;
}
int futhark_context_clear_caches(struct futhark_context *ctx)
{
    lock_lock(&ctx->lock);
    ctx->peak_mem_usage_default = 0;
    lock_unlock(&ctx->lock);
    return ctx->error != NULL;
}

static int futrts_entry_main(struct futhark_context *ctx,
                             struct memblock *mem_out_p_30775,
                             struct memblock *mem_out_p_30776,
                             struct memblock *mem_out_p_30777,
                             struct memblock *mem_out_p_30778,
                             struct memblock *mem_out_p_30779,
                             struct memblock *mem_out_p_30780,
                             struct memblock *mem_out_p_30781,
                             struct memblock xps_mem_29549,
                             struct memblock yps_mem_29550,
                             struct memblock zzps_mem_29551,
                             struct memblock ms_mem_29552,
                             struct memblock xvs_mem_29553,
                             struct memblock yvs_mem_29554,
                             struct memblock zzvs_mem_29555, int64_t n_21239,
                             int32_t n_steps_21240, float epsilon_21241,
                             float time_step_21242);

static int init_constants(struct futhark_context *ctx)
{
    (void) ctx;
    
    int err = 0;
    
    
  cleanup:
    return err;
}
static int free_constants(struct futhark_context *ctx)
{
    (void) ctx;
    return 0;
}
struct futhark_f32_1d {
    struct memblock mem;
    int64_t shape[1];
};
struct futhark_f32_1d *futhark_new_f32_1d(struct futhark_context *ctx, const
                                          float *data, int64_t dim0)
{
    struct futhark_f32_1d *bad = NULL;
    struct futhark_f32_1d *arr =
                          (struct futhark_f32_1d *) malloc(sizeof(struct futhark_f32_1d));
    
    if (arr == NULL)
        return bad;
    lock_lock(&ctx->lock);
    arr->mem.references = NULL;
    if (memblock_alloc(ctx, &arr->mem, dim0 * 4, "arr->mem"))
        return NULL;
    arr->shape[0] = dim0;
    if ((size_t) dim0 * 4 > 0)
        memmove(arr->mem.mem + 0, data + 0, (size_t) dim0 * 4);
    lock_unlock(&ctx->lock);
    return arr;
}
struct futhark_f32_1d *futhark_new_raw_f32_1d(struct futhark_context *ctx, const
                                              unsigned char *data,
                                              int64_t offset, int64_t dim0)
{
    struct futhark_f32_1d *bad = NULL;
    struct futhark_f32_1d *arr =
                          (struct futhark_f32_1d *) malloc(sizeof(struct futhark_f32_1d));
    
    if (arr == NULL)
        return bad;
    lock_lock(&ctx->lock);
    arr->mem.references = NULL;
    if (memblock_alloc(ctx, &arr->mem, dim0 * 4, "arr->mem"))
        return NULL;
    arr->shape[0] = dim0;
    if ((size_t) dim0 * 4 > 0)
        memmove(arr->mem.mem + 0, data + offset, (size_t) dim0 * 4);
    lock_unlock(&ctx->lock);
    return arr;
}
int futhark_free_f32_1d(struct futhark_context *ctx, struct futhark_f32_1d *arr)
{
    lock_lock(&ctx->lock);
    if (memblock_unref(ctx, &arr->mem, "arr->mem") != 0)
        return 1;
    lock_unlock(&ctx->lock);
    free(arr);
    return 0;
}
int futhark_values_f32_1d(struct futhark_context *ctx,
                          struct futhark_f32_1d *arr, float *data)
{
    lock_lock(&ctx->lock);
    if ((size_t) arr->shape[0] * 4 > 0)
        memmove(data + 0, arr->mem.mem + 0, (size_t) arr->shape[0] * 4);
    lock_unlock(&ctx->lock);
    return 0;
}
unsigned char *futhark_values_raw_f32_1d(struct futhark_context *ctx,
                                         struct futhark_f32_1d *arr)
{
    (void) ctx;
    return arr->mem.mem;
}
const int64_t *futhark_shape_f32_1d(struct futhark_context *ctx,
                                    struct futhark_f32_1d *arr)
{
    (void) ctx;
    return arr->shape;
}

static int futrts_entry_main(struct futhark_context *ctx,
                             struct memblock *mem_out_p_30775,
                             struct memblock *mem_out_p_30776,
                             struct memblock *mem_out_p_30777,
                             struct memblock *mem_out_p_30778,
                             struct memblock *mem_out_p_30779,
                             struct memblock *mem_out_p_30780,
                             struct memblock *mem_out_p_30781,
                             struct memblock xps_mem_29549,
                             struct memblock yps_mem_29550,
                             struct memblock zzps_mem_29551,
                             struct memblock ms_mem_29552,
                             struct memblock xvs_mem_29553,
                             struct memblock yvs_mem_29554,
                             struct memblock zzvs_mem_29555, int64_t n_21239,
                             int32_t n_steps_21240, float epsilon_21241,
                             float time_step_21242)
{
    (void) ctx;
    
    int err = 0;
    size_t mem_29637_cached_sizze_30782 = 0;
    unsigned char *mem_29637 = NULL;
    size_t mem_29640_cached_sizze_30783 = 0;
    unsigned char *mem_29640 = NULL;
    size_t mem_29643_cached_sizze_30784 = 0;
    unsigned char *mem_29643 = NULL;
    size_t mem_29646_cached_sizze_30785 = 0;
    unsigned char *mem_29646 = NULL;
    size_t mem_29649_cached_sizze_30786 = 0;
    unsigned char *mem_29649 = NULL;
    size_t mem_29755_cached_sizze_30787 = 0;
    unsigned char *mem_29755 = NULL;
    size_t mem_29758_cached_sizze_30788 = 0;
    unsigned char *mem_29758 = NULL;
    size_t mem_29761_cached_sizze_30789 = 0;
    unsigned char *mem_29761 = NULL;
    size_t mem_29764_cached_sizze_30790 = 0;
    unsigned char *mem_29764 = NULL;
    size_t mem_29767_cached_sizze_30791 = 0;
    unsigned char *mem_29767 = NULL;
    size_t mem_29770_cached_sizze_30792 = 0;
    unsigned char *mem_29770 = NULL;
    size_t mem_29773_cached_sizze_30793 = 0;
    unsigned char *mem_29773 = NULL;
    size_t mem_29872_cached_sizze_30794 = 0;
    unsigned char *mem_29872 = NULL;
    size_t mem_29874_cached_sizze_30795 = 0;
    unsigned char *mem_29874 = NULL;
    size_t mem_29877_cached_sizze_30796 = 0;
    unsigned char *mem_29877 = NULL;
    size_t mem_29879_cached_sizze_30797 = 0;
    unsigned char *mem_29879 = NULL;
    size_t mem_29882_cached_sizze_30798 = 0;
    unsigned char *mem_29882 = NULL;
    size_t mem_29885_cached_sizze_30799 = 0;
    unsigned char *mem_29885 = NULL;
    size_t mem_29888_cached_sizze_30800 = 0;
    unsigned char *mem_29888 = NULL;
    size_t mem_29891_cached_sizze_30801 = 0;
    unsigned char *mem_29891 = NULL;
    size_t mem_29990_cached_sizze_30802 = 0;
    unsigned char *mem_29990 = NULL;
    size_t mem_30005_cached_sizze_30803 = 0;
    unsigned char *mem_30005 = NULL;
    size_t mem_30008_cached_sizze_30804 = 0;
    unsigned char *mem_30008 = NULL;
    size_t mem_30011_cached_sizze_30805 = 0;
    unsigned char *mem_30011 = NULL;
    size_t mem_30050_cached_sizze_30806 = 0;
    unsigned char *mem_30050 = NULL;
    size_t mem_30065_cached_sizze_30807 = 0;
    unsigned char *mem_30065 = NULL;
    size_t mem_30081_cached_sizze_30808 = 0;
    unsigned char *mem_30081 = NULL;
    size_t mem_30181_cached_sizze_30809 = 0;
    unsigned char *mem_30181 = NULL;
    size_t mem_30183_cached_sizze_30810 = 0;
    unsigned char *mem_30183 = NULL;
    size_t mem_30438_cached_sizze_30811 = 0;
    unsigned char *mem_30438 = NULL;
    struct memblock mem_30590;
    
    mem_30590.references = NULL;
    
    struct memblock mem_30586;
    
    mem_30586.references = NULL;
    
    struct memblock mem_30582;
    
    mem_30582.references = NULL;
    
    struct memblock mem_30578;
    
    mem_30578.references = NULL;
    
    struct memblock mem_30574;
    
    mem_30574.references = NULL;
    
    struct memblock mem_30570;
    
    mem_30570.references = NULL;
    
    struct memblock mem_30566;
    
    mem_30566.references = NULL;
    
    struct memblock mem_param_tmp_30648;
    
    mem_param_tmp_30648.references = NULL;
    
    struct memblock mem_param_tmp_30647;
    
    mem_param_tmp_30647.references = NULL;
    
    struct memblock mem_param_tmp_30646;
    
    mem_param_tmp_30646.references = NULL;
    
    struct memblock mem_param_tmp_30645;
    
    mem_param_tmp_30645.references = NULL;
    
    struct memblock mem_param_tmp_30644;
    
    mem_param_tmp_30644.references = NULL;
    
    struct memblock mem_param_tmp_30643;
    
    mem_param_tmp_30643.references = NULL;
    
    struct memblock mem_param_tmp_30642;
    
    mem_param_tmp_30642.references = NULL;
    
    struct memblock mem_30456;
    
    mem_30456.references = NULL;
    
    struct memblock mem_30453;
    
    mem_30453.references = NULL;
    
    struct memblock mem_30450;
    
    mem_30450.references = NULL;
    
    struct memblock mem_30447;
    
    mem_30447.references = NULL;
    
    struct memblock mem_30444;
    
    mem_30444.references = NULL;
    
    struct memblock mem_30441;
    
    mem_30441.references = NULL;
    
    struct memblock mem_param_tmp_30739;
    
    mem_param_tmp_30739.references = NULL;
    
    struct memblock mem_param_tmp_30738;
    
    mem_param_tmp_30738.references = NULL;
    
    struct memblock mem_param_tmp_30737;
    
    mem_param_tmp_30737.references = NULL;
    
    struct memblock mem_param_tmp_30736;
    
    mem_param_tmp_30736.references = NULL;
    
    struct memblock mem_param_tmp_30735;
    
    mem_param_tmp_30735.references = NULL;
    
    struct memblock mem_param_tmp_30734;
    
    mem_param_tmp_30734.references = NULL;
    
    struct memblock mem_param_tmp_30733;
    
    mem_param_tmp_30733.references = NULL;
    
    struct memblock mem_param_tmp_30732;
    
    mem_param_tmp_30732.references = NULL;
    
    struct memblock mem_30334;
    
    mem_30334.references = NULL;
    
    struct memblock mem_30331;
    
    mem_30331.references = NULL;
    
    struct memblock mem_30328;
    
    mem_30328.references = NULL;
    
    struct memblock mem_30325;
    
    mem_30325.references = NULL;
    
    struct memblock mem_30322;
    
    mem_30322.references = NULL;
    
    struct memblock mem_30318;
    
    mem_30318.references = NULL;
    
    struct memblock mem_30315;
    
    mem_30315.references = NULL;
    
    struct memblock mem_30312;
    
    mem_30312.references = NULL;
    
    struct memblock mem_param_30310;
    
    mem_param_30310.references = NULL;
    
    struct memblock mem_param_30305;
    
    mem_param_30305.references = NULL;
    
    struct memblock mem_param_30300;
    
    mem_param_30300.references = NULL;
    
    struct memblock mem_param_30295;
    
    mem_param_30295.references = NULL;
    
    struct memblock mem_param_30287;
    
    mem_param_30287.references = NULL;
    
    struct memblock mem_param_30282;
    
    mem_param_30282.references = NULL;
    
    struct memblock mem_param_30277;
    
    mem_param_30277.references = NULL;
    
    struct memblock mem_param_30272;
    
    mem_param_30272.references = NULL;
    
    struct memblock ext_mem_30394;
    
    ext_mem_30394.references = NULL;
    
    struct memblock ext_mem_30395;
    
    ext_mem_30395.references = NULL;
    
    struct memblock ext_mem_30396;
    
    ext_mem_30396.references = NULL;
    
    struct memblock ext_mem_30397;
    
    ext_mem_30397.references = NULL;
    
    struct memblock ext_mem_30398;
    
    ext_mem_30398.references = NULL;
    
    struct memblock ext_mem_30399;
    
    ext_mem_30399.references = NULL;
    
    struct memblock ext_mem_30400;
    
    ext_mem_30400.references = NULL;
    
    struct memblock ext_mem_30401;
    
    ext_mem_30401.references = NULL;
    
    struct memblock mem_30117;
    
    mem_30117.references = NULL;
    
    struct memblock mem_30114;
    
    mem_30114.references = NULL;
    
    struct memblock mem_30111;
    
    mem_30111.references = NULL;
    
    struct memblock mem_30109;
    
    mem_30109.references = NULL;
    
    struct memblock mem_30105;
    
    mem_30105.references = NULL;
    
    struct memblock mem_30102;
    
    mem_30102.references = NULL;
    
    struct memblock mem_30099;
    
    mem_30099.references = NULL;
    
    struct memblock mem_30096;
    
    mem_30096.references = NULL;
    
    struct memblock mem_29752;
    
    mem_29752.references = NULL;
    
    struct memblock mem_param_tmp_30664;
    
    mem_param_tmp_30664.references = NULL;
    
    struct memblock mem_param_tmp_30663;
    
    mem_param_tmp_30663.references = NULL;
    
    struct memblock mem_29715;
    
    mem_29715.references = NULL;
    
    struct memblock mem_29712;
    
    mem_29712.references = NULL;
    
    struct memblock mem_param_29632;
    
    mem_param_29632.references = NULL;
    
    struct memblock mem_param_29627;
    
    mem_param_29627.references = NULL;
    
    struct memblock ext_mem_29740;
    
    ext_mem_29740.references = NULL;
    
    struct memblock ext_mem_29741;
    
    ext_mem_29741.references = NULL;
    
    struct memblock mem_param_29593;
    
    mem_param_29593.references = NULL;
    
    struct memblock mem_param_29588;
    
    mem_param_29588.references = NULL;
    
    struct memblock mem_param_29583;
    
    mem_param_29583.references = NULL;
    
    struct memblock mem_param_29578;
    
    mem_param_29578.references = NULL;
    
    struct memblock mem_param_29573;
    
    mem_param_29573.references = NULL;
    
    struct memblock mem_param_29568;
    
    mem_param_29568.references = NULL;
    
    struct memblock mem_param_29563;
    
    mem_param_29563.references = NULL;
    
    struct memblock ext_mem_30529;
    
    ext_mem_30529.references = NULL;
    
    struct memblock ext_mem_30530;
    
    ext_mem_30530.references = NULL;
    
    struct memblock ext_mem_30531;
    
    ext_mem_30531.references = NULL;
    
    struct memblock ext_mem_30532;
    
    ext_mem_30532.references = NULL;
    
    struct memblock ext_mem_30533;
    
    ext_mem_30533.references = NULL;
    
    struct memblock ext_mem_30534;
    
    ext_mem_30534.references = NULL;
    
    struct memblock ext_mem_30535;
    
    ext_mem_30535.references = NULL;
    
    struct memblock mem_29610;
    
    mem_29610.references = NULL;
    
    struct memblock mem_29558;
    
    mem_29558.references = NULL;
    
    struct memblock mem_out_30639;
    
    mem_out_30639.references = NULL;
    
    struct memblock mem_out_30638;
    
    mem_out_30638.references = NULL;
    
    struct memblock mem_out_30637;
    
    mem_out_30637.references = NULL;
    
    struct memblock mem_out_30636;
    
    mem_out_30636.references = NULL;
    
    struct memblock mem_out_30635;
    
    mem_out_30635.references = NULL;
    
    struct memblock mem_out_30634;
    
    mem_out_30634.references = NULL;
    
    struct memblock mem_out_30633;
    
    mem_out_30633.references = NULL;
    
    bool loop_nonempty_27002 = slt32(0, n_steps_21240);
    bool cond_27003 = n_21239 == (int64_t) 0;
    int32_t iters_27004;
    
    if (cond_27003) {
        iters_27004 = 0;
    } else {
        iters_27004 = 16;
    }
    
    bool loop_nonempty_27005 = slt32(0, iters_27004);
    int64_t i_27006 = sub64(n_21239, (int64_t) 1);
    bool x_27007 = sle64((int64_t) 0, i_27006);
    bool y_27008 = slt64(i_27006, n_21239);
    bool bounds_check_27009 = x_27007 && y_27008;
    bool loop_not_taken_27010 = !loop_nonempty_27005;
    bool protect_assert_disj_27011 = bounds_check_27009 || loop_not_taken_27010;
    bool loop_not_taken_27012 = !loop_nonempty_27002;
    bool protect_assert_disj_27013 = protect_assert_disj_27011 ||
         loop_not_taken_27012;
    bool index_certs_27014;
    
    if (!protect_assert_disj_27013) {
        ctx->error = msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                               "Index [", (long long) i_27006,
                               "] out of bounds for array of shape [",
                               (long long) n_21239, "].",
                               "-> #0  /prelude/array.fut:26:29-34\n   #1  sample_programs/lib/github.com/diku-dk/sorts/radix_sort.fut:25:24-35\n   #2  sample_programs/lib/github.com/diku-dk/sorts/radix_sort.fut:53:31-62\n   #3  /prelude/functional.fut:9:42-44\n   #4  sample_programs/lib/github.com/diku-dk/sorts/radix_sort.fut:59:3-61:47\n   #5  sample_programs/lib/github.com/diku-dk/sorts/radix_sort.fut:68:3-51\n   #6  sample_programs/octree.fut:197:5-79\n   #7  sample_programs/nbody.fut:62:5-25\n   #8  sample_programs/nbody.fut:69:26-57\n   #9  sample_programs/nbody.fut:75:5-49\n   #10 sample_programs/nbody.fut:102:17-75\n   #11 sample_programs/nbody.fut:89:1-106:46\n");
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t k_27015 = mul64((int64_t) 2, i_27006);
    int64_t conc_tmp_27016 = i_27006 + i_27006;
    bool dim_match_27017 = k_27015 == conc_tmp_27016;
    bool protect_assert_disj_27018 = loop_not_taken_27012 || dim_match_27017;
    bool empty_or_match_cert_27019;
    
    if (!protect_assert_disj_27018) {
        ctx->error = msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                               "Value of (core language) shape (",
                               (long long) conc_tmp_27016,
                               ") cannot match shape of type `*[",
                               (long long) k_27015, "]t`.",
                               "-> #0  /prelude/array.fut:73:66-82\n   #1  sample_programs/radixtree.fut:76:26-78:55\n   #2  sample_programs/octree.fut:199:16-36\n   #3  sample_programs/nbody.fut:62:5-25\n   #4  sample_programs/nbody.fut:69:26-57\n   #5  sample_programs/nbody.fut:75:5-49\n   #6  sample_programs/nbody.fut:102:17-75\n   #7  sample_programs/nbody.fut:89:1-106:46\n");
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    bool y_27020 = slt64((int64_t) 0, i_27006);
    bool protect_assert_disj_27021 = loop_not_taken_27012 || y_27020;
    bool index_certs_27022;
    
    if (!protect_assert_disj_27021) {
        ctx->error = msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                               "Index [", (long long) (int64_t) 0,
                               "] out of bounds for array of shape [",
                               (long long) i_27006, "].",
                               "-> #0  sample_programs/octree.fut:26:20-28\n   #1  sample_programs/octree.fut:201:16-38\n   #2  sample_programs/nbody.fut:62:5-25\n   #3  sample_programs/nbody.fut:69:26-57\n   #4  sample_programs/nbody.fut:75:5-49\n   #5  sample_programs/nbody.fut:102:17-75\n   #6  sample_programs/nbody.fut:89:1-106:46\n");
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t i_27023 = sub64(i_27006, (int64_t) 1);
    bool x_27024 = sle64((int64_t) 0, i_27023);
    bool y_27025 = slt64(i_27023, i_27006);
    bool bounds_check_27026 = x_27024 && y_27025;
    bool protect_assert_disj_27027 = loop_not_taken_27012 || bounds_check_27026;
    bool index_certs_27028;
    
    if (!protect_assert_disj_27027) {
        ctx->error = msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                               "Index [", (long long) i_27023,
                               "] out of bounds for array of shape [",
                               (long long) i_27006, "].",
                               "-> #0  /prelude/array.fut:26:29-34\n   #1  sample_programs/octree.fut:41:23-37\n   #2  sample_programs/octree.fut:201:16-38\n   #3  sample_programs/nbody.fut:62:5-25\n   #4  sample_programs/nbody.fut:69:26-57\n   #5  sample_programs/nbody.fut:75:5-49\n   #6  sample_programs/nbody.fut:102:17-75\n   #7  sample_programs/nbody.fut:89:1-106:46\n");
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    bool empty_slice_27029 = i_27023 == (int64_t) 0;
    bool i_lte_j_27030 = sle64((int64_t) 1, i_27006);
    bool y_27031 = bounds_check_27026 && i_lte_j_27030;
    bool ok_or_empty_27032 = empty_slice_27029 || y_27031;
    bool protect_assert_disj_27033 = loop_not_taken_27012 || ok_or_empty_27032;
    bool index_certs_27034;
    
    if (!protect_assert_disj_27033) {
        ctx->error = msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                               "Index [", (long long) (int64_t) 1,
                               ":] out of bounds for array of shape [",
                               (long long) i_27006, "].",
                               "-> #0  /prelude/array.fut:31:29-33\n   #1  sample_programs/octree.fut:43:46-56\n   #2  sample_programs/octree.fut:201:16-38\n   #3  sample_programs/nbody.fut:62:5-25\n   #4  sample_programs/nbody.fut:69:26-57\n   #5  sample_programs/nbody.fut:75:5-49\n   #6  sample_programs/nbody.fut:102:17-75\n   #7  sample_programs/nbody.fut:89:1-106:46\n");
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t binop_y_29556 = (int64_t) 8 * n_21239;
    int64_t bytes_29557 = smax64((int64_t) 0, binop_y_29556);
    
    if (memblock_alloc(ctx, &mem_29558, bytes_29557, "mem_29558")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_30640 = 0; i_30640 < n_21239; i_30640++) {
        int64_t x_30641 = (int64_t) 0 + i_30640 * (int64_t) 1;
        
        ((int64_t *) mem_29558.mem)[i_30640] = x_30641;
    }
    
    bool bounds_invalid_upwards_28033 = slt64(i_27006, (int64_t) 0);
    bool valid_28034 = !bounds_invalid_upwards_28033;
    bool protect_assert_disj_28385 = loop_not_taken_27012 || valid_28034;
    bool range_valid_c_28035;
    
    if (!protect_assert_disj_28385) {
        ctx->error = msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s",
                               "Range ", (long long) (int64_t) 0, "..",
                               (long long) (int64_t) 1, "..<",
                               (long long) i_27006, " is invalid.",
                               "-> #0  /prelude/array.fut:90:3-10\n   #1  /prelude/array.fut:195:11-16\n   #2  sample_programs/radixtree.fut:70:40-58\n   #3  sample_programs/octree.fut:199:16-36\n   #4  sample_programs/nbody.fut:62:5-25\n   #5  sample_programs/nbody.fut:69:26-57\n   #6  sample_programs/nbody.fut:75:5-49\n   #7  sample_programs/nbody.fut:102:17-75\n   #8  sample_programs/nbody.fut:89:1-106:46\n");
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int32_t i64_res_28164 = sext_i64_i32(n_21239);
    int64_t binop_y_29608 = (int64_t) 4 * n_21239;
    int64_t bytes_29609 = smax64((int64_t) 0, binop_y_29608);
    
    if (memblock_alloc(ctx, &mem_29610, bytes_29609, "mem_29610")) {
        err = 1;
        goto cleanup;
    }
    if (mem_29637_cached_sizze_30782 < bytes_29557) {
        err = lexical_realloc(&ctx->error, &mem_29637,
                              &mem_29637_cached_sizze_30782, bytes_29557);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_29640_cached_sizze_30783 < bytes_29557) {
        err = lexical_realloc(&ctx->error, &mem_29640,
                              &mem_29640_cached_sizze_30783, bytes_29557);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_29643_cached_sizze_30784 < bytes_29557) {
        err = lexical_realloc(&ctx->error, &mem_29643,
                              &mem_29643_cached_sizze_30784, bytes_29557);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_29646_cached_sizze_30785 < bytes_29557) {
        err = lexical_realloc(&ctx->error, &mem_29646,
                              &mem_29646_cached_sizze_30785, bytes_29557);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_29649_cached_sizze_30786 < bytes_29609) {
        err = lexical_realloc(&ctx->error, &mem_29649,
                              &mem_29649_cached_sizze_30786, bytes_29609);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_29755_cached_sizze_30787 < bytes_29609) {
        err = lexical_realloc(&ctx->error, &mem_29755,
                              &mem_29755_cached_sizze_30787, bytes_29609);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_29758_cached_sizze_30788 < bytes_29609) {
        err = lexical_realloc(&ctx->error, &mem_29758,
                              &mem_29758_cached_sizze_30788, bytes_29609);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_29761_cached_sizze_30789 < bytes_29609) {
        err = lexical_realloc(&ctx->error, &mem_29761,
                              &mem_29761_cached_sizze_30789, bytes_29609);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_29764_cached_sizze_30790 < bytes_29609) {
        err = lexical_realloc(&ctx->error, &mem_29764,
                              &mem_29764_cached_sizze_30790, bytes_29609);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_29767_cached_sizze_30791 < bytes_29609) {
        err = lexical_realloc(&ctx->error, &mem_29767,
                              &mem_29767_cached_sizze_30791, bytes_29609);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_29770_cached_sizze_30792 < bytes_29609) {
        err = lexical_realloc(&ctx->error, &mem_29770,
                              &mem_29770_cached_sizze_30792, bytes_29609);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_29773_cached_sizze_30793 < bytes_29609) {
        err = lexical_realloc(&ctx->error, &mem_29773,
                              &mem_29773_cached_sizze_30793, bytes_29609);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    
    int64_t binop_y_29870 = (int64_t) 4 * i_27006;
    int64_t bytes_29871 = smax64((int64_t) 0, binop_y_29870);
    
    if (mem_29872_cached_sizze_30794 < bytes_29871) {
        err = lexical_realloc(&ctx->error, &mem_29872,
                              &mem_29872_cached_sizze_30794, bytes_29871);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    
    int64_t bytes_29873 = smax64((int64_t) 0, i_27006);
    
    if (mem_29874_cached_sizze_30795 < bytes_29873) {
        err = lexical_realloc(&ctx->error, &mem_29874,
                              &mem_29874_cached_sizze_30795, bytes_29873);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_29877_cached_sizze_30796 < bytes_29871) {
        err = lexical_realloc(&ctx->error, &mem_29877,
                              &mem_29877_cached_sizze_30796, bytes_29871);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_29879_cached_sizze_30797 < bytes_29873) {
        err = lexical_realloc(&ctx->error, &mem_29879,
                              &mem_29879_cached_sizze_30797, bytes_29873);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_29882_cached_sizze_30798 < bytes_29871) {
        err = lexical_realloc(&ctx->error, &mem_29882,
                              &mem_29882_cached_sizze_30798, bytes_29871);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_29885_cached_sizze_30799 < bytes_29871) {
        err = lexical_realloc(&ctx->error, &mem_29885,
                              &mem_29885_cached_sizze_30799, bytes_29871);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    
    int64_t binop_y_29886 = (int64_t) 8 * i_27006;
    int64_t bytes_29887 = smax64((int64_t) 0, binop_y_29886);
    
    if (mem_29888_cached_sizze_30800 < bytes_29887) {
        err = lexical_realloc(&ctx->error, &mem_29888,
                              &mem_29888_cached_sizze_30800, bytes_29887);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_29891_cached_sizze_30801 < bytes_29887) {
        err = lexical_realloc(&ctx->error, &mem_29891,
                              &mem_29891_cached_sizze_30801, bytes_29887);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_29990_cached_sizze_30802 < bytes_29871) {
        err = lexical_realloc(&ctx->error, &mem_29990,
                              &mem_29990_cached_sizze_30802, bytes_29871);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_30005_cached_sizze_30803 < bytes_29871) {
        err = lexical_realloc(&ctx->error, &mem_30005,
                              &mem_30005_cached_sizze_30803, bytes_29871);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_30008_cached_sizze_30804 < bytes_29871) {
        err = lexical_realloc(&ctx->error, &mem_30008,
                              &mem_30008_cached_sizze_30804, bytes_29871);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_30011_cached_sizze_30805 < bytes_29871) {
        err = lexical_realloc(&ctx->error, &mem_30011,
                              &mem_30011_cached_sizze_30805, bytes_29871);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_30050_cached_sizze_30806 < bytes_29871) {
        err = lexical_realloc(&ctx->error, &mem_30050,
                              &mem_30050_cached_sizze_30806, bytes_29871);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_30181_cached_sizze_30809 < (int64_t) 32) {
        err = lexical_realloc(&ctx->error, &mem_30181,
                              &mem_30181_cached_sizze_30809, (int64_t) 32);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_30183_cached_sizze_30810 < (int64_t) 12) {
        err = lexical_realloc(&ctx->error, &mem_30183,
                              &mem_30183_cached_sizze_30810, (int64_t) 12);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_30438_cached_sizze_30811 < (int64_t) 12) {
        err = lexical_realloc(&ctx->error, &mem_30438,
                              &mem_30438_cached_sizze_30811, (int64_t) 12);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (memblock_set(ctx, &mem_param_29563, &ms_mem_29552, "ms_mem_29552") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_29568, &xps_mem_29549, "xps_mem_29549") !=
        0)
        return 1;
    if (memblock_set(ctx, &mem_param_29573, &yps_mem_29550, "yps_mem_29550") !=
        0)
        return 1;
    if (memblock_set(ctx, &mem_param_29578, &zzps_mem_29551,
                     "zzps_mem_29551") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_29583, &xvs_mem_29553, "xvs_mem_29553") !=
        0)
        return 1;
    if (memblock_set(ctx, &mem_param_29588, &yvs_mem_29554, "yvs_mem_29554") !=
        0)
        return 1;
    if (memblock_set(ctx, &mem_param_29593, &zzvs_mem_29555,
                     "zzvs_mem_29555") != 0)
        return 1;
    for (int32_t _i_27043 = 0; _i_27043 < n_steps_21240; _i_27043++) {
        float defunc_2_reduce_res_27909;
        float defunc_2_reduce_res_27930;
        float redout_29328;
        float redout_29329;
        
        redout_29328 = -INFINITY;
        redout_29329 = INFINITY;
        for (int64_t i_29330 = 0; i_29330 < n_21239; i_29330++) {
            float x_27934;
            
            x_27934 = ((float *) mem_param_29568.mem)[i_29330];
            
            float defunc_1_op_res_27912 = fmax32(x_27934, redout_29328);
            float defunc_1_op_res_27933 = fmin32(x_27934, redout_29329);
            float redout_tmp_30656 = defunc_1_op_res_27912;
            float redout_tmp_30657 = defunc_1_op_res_27933;
            
            redout_29328 = redout_tmp_30656;
            redout_29329 = redout_tmp_30657;
        }
        defunc_2_reduce_res_27909 = redout_29328;
        defunc_2_reduce_res_27930 = redout_29329;
        
        float defunc_2_reduce_res_27916;
        float defunc_2_reduce_res_27937;
        float redout_29331;
        float redout_29332;
        
        redout_29331 = -INFINITY;
        redout_29332 = INFINITY;
        for (int64_t i_29333 = 0; i_29333 < n_21239; i_29333++) {
            float x_27941;
            
            x_27941 = ((float *) mem_param_29573.mem)[i_29333];
            
            float defunc_1_op_res_27919 = fmax32(x_27941, redout_29331);
            float defunc_1_op_res_27940 = fmin32(x_27941, redout_29332);
            float redout_tmp_30658 = defunc_1_op_res_27919;
            float redout_tmp_30659 = defunc_1_op_res_27940;
            
            redout_29331 = redout_tmp_30658;
            redout_29332 = redout_tmp_30659;
        }
        defunc_2_reduce_res_27916 = redout_29331;
        defunc_2_reduce_res_27937 = redout_29332;
        
        float defunc_2_reduce_res_27923;
        float defunc_2_reduce_res_27944;
        float redout_29334;
        float redout_29335;
        
        redout_29334 = -INFINITY;
        redout_29335 = INFINITY;
        for (int64_t i_29336 = 0; i_29336 < n_21239; i_29336++) {
            float x_27948;
            
            x_27948 = ((float *) mem_param_29578.mem)[i_29336];
            
            float defunc_1_op_res_27926 = fmax32(x_27948, redout_29334);
            float defunc_1_op_res_27947 = fmin32(x_27948, redout_29335);
            float redout_tmp_30660 = defunc_1_op_res_27926;
            float redout_tmp_30661 = defunc_1_op_res_27947;
            
            redout_29334 = redout_tmp_30660;
            redout_29335 = redout_tmp_30661;
        }
        defunc_2_reduce_res_27923 = redout_29334;
        defunc_2_reduce_res_27944 = redout_29335;
        
        float y_27057 = defunc_2_reduce_res_27909 - defunc_2_reduce_res_27930;
        float y_27058 = defunc_2_reduce_res_27916 - defunc_2_reduce_res_27937;
        float y_27059 = defunc_2_reduce_res_27923 - defunc_2_reduce_res_27944;
        
        for (int64_t i_29339 = 0; i_29339 < n_21239; i_29339++) {
            float x_27061;
            
            x_27061 = ((float *) mem_param_29568.mem)[i_29339];
            
            float x_27062;
            
            x_27062 = ((float *) mem_param_29573.mem)[i_29339];
            
            float x_27063;
            
            x_27063 = ((float *) mem_param_29578.mem)[i_29339];
            
            float x_27064 = x_27061 - defunc_2_reduce_res_27930;
            float defunc_0_f_res_27065 = x_27064 / y_27057;
            float x_27066 = x_27062 - defunc_2_reduce_res_27937;
            float defunc_0_f_res_27067 = x_27066 / y_27058;
            float x_27068 = x_27063 - defunc_2_reduce_res_27944;
            float defunc_0_f_res_27069 = x_27068 / y_27059;
            float max_arg_27070 = 1024.0F * defunc_0_f_res_27065;
            float max_res_27071 = fmax32(0.0F, max_arg_27070);
            float min_res_27072 = fmin32(1023.0F, max_res_27071);
            float max_arg_27073 = 1024.0F * defunc_0_f_res_27067;
            float max_res_27074 = fmax32(0.0F, max_arg_27073);
            float min_res_27075 = fmin32(1023.0F, max_res_27074);
            float max_arg_27076 = 1024.0F * defunc_0_f_res_27069;
            float max_res_27077 = fmax32(0.0F, max_arg_27076);
            float min_res_27078 = fmin32(1023.0F, max_res_27077);
            int32_t unsign_arg_27950 = fptoui_f32_i32(min_res_27072);
            int32_t x_27952 = mul32(65537, unsign_arg_27950);
            int32_t v_27953 = -16776961 & x_27952;
            int32_t x_27954 = mul32(257, v_27953);
            int32_t v_27955 = 251719695 & x_27954;
            int32_t x_27956 = mul32(17, v_27955);
            int32_t v_27957 = -1022611261 & x_27956;
            int32_t x_27958 = mul32(5, v_27957);
            int32_t v_27959 = 1227133513 & x_27958;
            int32_t unsign_arg_27961 = fptoui_f32_i32(min_res_27075);
            int32_t x_27963 = mul32(65537, unsign_arg_27961);
            int32_t v_27964 = -16776961 & x_27963;
            int32_t x_27965 = mul32(257, v_27964);
            int32_t v_27966 = 251719695 & x_27965;
            int32_t x_27967 = mul32(17, v_27966);
            int32_t v_27968 = -1022611261 & x_27967;
            int32_t x_27969 = mul32(5, v_27968);
            int32_t v_27970 = 1227133513 & x_27969;
            int32_t unsign_arg_27972 = fptoui_f32_i32(min_res_27078);
            int32_t x_27974 = mul32(65537, unsign_arg_27972);
            int32_t v_27975 = -16776961 & x_27974;
            int32_t x_27976 = mul32(257, v_27975);
            int32_t v_27977 = 251719695 & x_27976;
            int32_t x_27978 = mul32(17, v_27977);
            int32_t v_27979 = -1022611261 & x_27978;
            int32_t x_27980 = mul32(5, v_27979);
            int32_t v_27981 = 1227133513 & x_27980;
            int32_t x_27085 = mul32(4, v_27959);
            int32_t y_27086 = mul32(2, v_27970);
            int32_t x_27087 = add32(x_27085, y_27086);
            int32_t defunc_0_g_res_27088 = add32(x_27087, v_27981);
            
            ((int32_t *) mem_29610.mem)[i_29339] = defunc_0_g_res_27088;
        }
        if (memblock_set(ctx, &mem_param_29627, &mem_29610, "mem_29610") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_29632, &mem_29558, "mem_29558") != 0)
            return 1;
        for (int32_t i_27092 = 0; i_27092 < iters_27004; i_27092++) {
            int32_t defunc_2_radix_sort_step_arg_27095 = mul32(2, i_27092);
            int32_t defunc_0_get_bit_arg_27096 = add32(1,
                                                       defunc_2_radix_sort_step_arg_27095);
            int64_t discard_29361;
            int64_t discard_29362;
            int64_t discard_29363;
            int64_t discard_29364;
            int64_t scanacc_29346;
            int64_t scanacc_29347;
            int64_t scanacc_29348;
            int64_t scanacc_29349;
            
            scanacc_29346 = (int64_t) 0;
            scanacc_29347 = (int64_t) 0;
            scanacc_29348 = (int64_t) 0;
            scanacc_29349 = (int64_t) 0;
            for (int64_t i_29355 = 0; i_29355 < n_21239; i_29355++) {
                int32_t x_27098;
                
                x_27098 = ((int32_t *) mem_param_29627.mem)[i_29355];
                
                int32_t unsign_arg_27989 = ashr32(x_27098,
                                                  defunc_0_get_bit_arg_27096);
                int32_t unsign_arg_27992 = 1 & unsign_arg_27989;
                int32_t x_27101 = mul32(2, unsign_arg_27992);
                int32_t unsign_arg_27995 = ashr32(x_27098,
                                                  defunc_2_radix_sort_step_arg_27095);
                int32_t unsign_arg_27998 = 1 & unsign_arg_27995;
                int32_t defunc_0_f_res_27104 = add32(x_27101, unsign_arg_27998);
                bool cond_27110 = defunc_0_f_res_27104 == 0;
                int64_t defunc_0_f_res_27111 = btoi_bool_i64(cond_27110);
                int64_t defunc_0_f_res_27112;
                int64_t defunc_0_f_res_27113;
                int64_t defunc_0_f_res_27114;
                
                if (cond_27110) {
                    defunc_0_f_res_27112 = (int64_t) 0;
                    defunc_0_f_res_27113 = (int64_t) 0;
                    defunc_0_f_res_27114 = (int64_t) 0;
                } else {
                    bool cond_28864 = defunc_0_f_res_27104 == 1;
                    int64_t defunc_0_f_res_f_res_28865 =
                            btoi_bool_i64(cond_28864);
                    int64_t defunc_0_f_res_f_res_28866;
                    int64_t defunc_0_f_res_f_res_28867;
                    
                    if (cond_28864) {
                        defunc_0_f_res_f_res_28866 = (int64_t) 0;
                        defunc_0_f_res_f_res_28867 = (int64_t) 0;
                    } else {
                        bool cond_28868 = defunc_0_f_res_27104 == 2;
                        int64_t defunc_0_f_res_f_res_f_res_28869 =
                                btoi_bool_i64(cond_28868);
                        bool cond_neg_28870 = !cond_28868;
                        int64_t defunc_0_f_res_f_res_f_res_28871 =
                                btoi_bool_i64(cond_neg_28870);
                        
                        defunc_0_f_res_f_res_28866 =
                            defunc_0_f_res_f_res_f_res_28869;
                        defunc_0_f_res_f_res_28867 =
                            defunc_0_f_res_f_res_f_res_28871;
                    }
                    defunc_0_f_res_27112 = defunc_0_f_res_f_res_28865;
                    defunc_0_f_res_27113 = defunc_0_f_res_f_res_28866;
                    defunc_0_f_res_27114 = defunc_0_f_res_f_res_28867;
                }
                
                int64_t defunc_1_op_res_27135 = add64(defunc_0_f_res_27111,
                                                      scanacc_29346);
                int64_t defunc_1_op_res_27136 = add64(defunc_0_f_res_27112,
                                                      scanacc_29347);
                int64_t defunc_1_op_res_27137 = add64(defunc_0_f_res_27113,
                                                      scanacc_29348);
                int64_t defunc_1_op_res_27138 = add64(defunc_0_f_res_27114,
                                                      scanacc_29349);
                
                ((int64_t *) mem_29637)[i_29355] = defunc_1_op_res_27135;
                ((int64_t *) mem_29640)[i_29355] = defunc_1_op_res_27136;
                ((int64_t *) mem_29643)[i_29355] = defunc_1_op_res_27137;
                ((int64_t *) mem_29646)[i_29355] = defunc_1_op_res_27138;
                ((int32_t *) mem_29649)[i_29355] = defunc_0_f_res_27104;
                
                int64_t scanacc_tmp_30667 = defunc_1_op_res_27135;
                int64_t scanacc_tmp_30668 = defunc_1_op_res_27136;
                int64_t scanacc_tmp_30669 = defunc_1_op_res_27137;
                int64_t scanacc_tmp_30670 = defunc_1_op_res_27138;
                
                scanacc_29346 = scanacc_tmp_30667;
                scanacc_29347 = scanacc_tmp_30668;
                scanacc_29348 = scanacc_tmp_30669;
                scanacc_29349 = scanacc_tmp_30670;
            }
            discard_29361 = scanacc_29346;
            discard_29362 = scanacc_29347;
            discard_29363 = scanacc_29348;
            discard_29364 = scanacc_29349;
            
            int64_t last_res_27143;
            
            last_res_27143 = ((int64_t *) mem_29637)[i_27006];
            
            int64_t last_res_27144;
            
            last_res_27144 = ((int64_t *) mem_29640)[i_27006];
            
            int64_t last_res_27145;
            
            last_res_27145 = ((int64_t *) mem_29643)[i_27006];
            if (memblock_alloc(ctx, &mem_29712, bytes_29557, "mem_29712")) {
                err = 1;
                goto cleanup;
            }
            if (n_21239 * (int64_t) 8 > 0)
                memmove(mem_29712.mem + (int64_t) 0, mem_param_29632.mem +
                        (int64_t) 0, n_21239 * (int64_t) 8);
            if (memblock_alloc(ctx, &mem_29715, bytes_29609, "mem_29715")) {
                err = 1;
                goto cleanup;
            }
            if (n_21239 * (int64_t) 4 > 0)
                memmove(mem_29715.mem + (int64_t) 0, mem_param_29627.mem +
                        (int64_t) 0, n_21239 * (int64_t) 4);
            for (int64_t write_iter_29365 = 0; write_iter_29365 < n_21239;
                 write_iter_29365++) {
                int32_t write_iv_29368;
                
                write_iv_29368 = ((int32_t *) mem_29649)[write_iter_29365];
                
                int64_t write_iv_29369;
                
                write_iv_29369 = ((int64_t *) mem_29637)[write_iter_29365];
                
                int64_t write_iv_29370;
                
                write_iv_29370 = ((int64_t *) mem_29640)[write_iter_29365];
                
                int64_t write_iv_29371;
                
                write_iv_29371 = ((int64_t *) mem_29643)[write_iter_29365];
                
                int64_t write_iv_29372;
                
                write_iv_29372 = ((int64_t *) mem_29646)[write_iter_29365];
                
                bool match_lit_27152 = 0 == write_iv_29368;
                int64_t defunc_1_f_res_27153;
                
                if (match_lit_27152) {
                    int64_t case_res_27154 = sub64(write_iv_29369, (int64_t) 1);
                    
                    defunc_1_f_res_27153 = case_res_27154;
                } else {
                    bool match_lit_28885 = 1 == write_iv_29368;
                    int64_t x_28886;
                    
                    if (match_lit_28885) {
                        int64_t x_28887 = add64(last_res_27143, write_iv_29370);
                        int64_t case_res_28888 = sub64(x_28887, (int64_t) 1);
                        
                        x_28886 = case_res_28888;
                    } else {
                        bool match_lit_28889 = 2 == write_iv_29368;
                        int64_t x_28890;
                        
                        if (match_lit_28889) {
                            int64_t x_28891 = add64(last_res_27143,
                                                    last_res_27144);
                            int64_t x_28892 = add64(x_28891, write_iv_29371);
                            int64_t case_res_28893 = sub64(x_28892,
                                                           (int64_t) 1);
                            
                            x_28890 = case_res_28893;
                        } else {
                            int64_t x_28894 = add64(last_res_27143,
                                                    last_res_27144);
                            int64_t x_28895 = add64(last_res_27145, x_28894);
                            int64_t x_28896 = add64(x_28895, write_iv_29372);
                            int64_t defunc_1_f_res_res_28897 = sub64(x_28896,
                                                                     (int64_t) 1);
                            
                            x_28890 = defunc_1_f_res_res_28897;
                        }
                        x_28886 = x_28890;
                    }
                    defunc_1_f_res_27153 = x_28886;
                }
                if (sle64((int64_t) 0, defunc_1_f_res_27153) &&
                    slt64(defunc_1_f_res_27153, n_21239)) {
                    if ((int64_t) 4 > 0)
                        memmove(mem_29715.mem + defunc_1_f_res_27153 *
                                (int64_t) 4, mem_param_29627.mem +
                                ((int64_t) 0 + (int64_t) 1 * write_iter_29365) *
                                (int64_t) 4, (int64_t) 4);
                }
                if (sle64((int64_t) 0, defunc_1_f_res_27153) &&
                    slt64(defunc_1_f_res_27153, n_21239)) {
                    if ((int64_t) 8 > 0)
                        memmove(mem_29712.mem + defunc_1_f_res_27153 *
                                (int64_t) 8, mem_param_29632.mem +
                                ((int64_t) 0 + (int64_t) 1 * write_iter_29365) *
                                (int64_t) 8, (int64_t) 8);
                }
            }
            if (memblock_set(ctx, &mem_param_tmp_30663, &mem_29715,
                             "mem_29715") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_30664, &mem_29712,
                             "mem_29712") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_29627, &mem_param_tmp_30663,
                             "mem_param_tmp_30663") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_29632, &mem_param_tmp_30664,
                             "mem_param_tmp_30664") != 0)
                return 1;
        }
        if (memblock_set(ctx, &ext_mem_29741, &mem_param_29627,
                         "mem_param_29627") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_29740, &mem_param_29632,
                         "mem_param_29632") != 0)
            return 1;
        if (memblock_alloc(ctx, &mem_29752, bytes_29609, "mem_29752")) {
            err = 1;
            goto cleanup;
        }
        for (int64_t i_29393 = 0; i_29393 < n_21239; i_29393++) {
            int64_t x_27182;
            
            x_27182 = ((int64_t *) ext_mem_29740.mem)[i_29393];
            
            bool x_27183 = sle64((int64_t) 0, x_27182);
            bool y_27184 = slt64(x_27182, n_21239);
            bool bounds_check_27185 = x_27183 && y_27184;
            bool index_certs_27186;
            
            if (!bounds_check_27185) {
                ctx->error =
                    msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                              "Index [", (long long) x_27182,
                              "] out of bounds for array of shape [",
                              (long long) n_21239, "].",
                              "-> #0  sample_programs/lib/github.com/diku-dk/sorts/radix_sort.fut:62:28-32\n   #1  /prelude/functional.fut:9:42-44\n   #2  sample_programs/lib/github.com/diku-dk/sorts/radix_sort.fut:59:3-62:33\n   #3  sample_programs/lib/github.com/diku-dk/sorts/radix_sort.fut:68:3-51\n   #4  sample_programs/octree.fut:197:5-79\n   #5  sample_programs/nbody.fut:62:5-25\n   #6  sample_programs/nbody.fut:69:26-57\n   #7  sample_programs/nbody.fut:75:5-49\n   #8  sample_programs/nbody.fut:102:17-75\n   #9  sample_programs/nbody.fut:89:1-106:46\n");
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            float defunc_0_f_res_27188;
            
            defunc_0_f_res_27188 = ((float *) mem_param_29568.mem)[x_27182];
            
            float defunc_0_f_res_27189;
            
            defunc_0_f_res_27189 = ((float *) mem_param_29573.mem)[x_27182];
            
            float defunc_0_f_res_27190;
            
            defunc_0_f_res_27190 = ((float *) mem_param_29578.mem)[x_27182];
            
            float x_27198 = defunc_0_f_res_27188 - defunc_2_reduce_res_27930;
            float defunc_0_f_res_27199 = x_27198 / y_27057;
            float x_27200 = defunc_0_f_res_27189 - defunc_2_reduce_res_27937;
            float defunc_0_f_res_27201 = x_27200 / y_27058;
            float x_27202 = defunc_0_f_res_27190 - defunc_2_reduce_res_27944;
            float defunc_0_f_res_27203 = x_27202 / y_27059;
            float max_arg_27204 = 1024.0F * defunc_0_f_res_27199;
            float max_res_27205 = fmax32(0.0F, max_arg_27204);
            float min_res_27206 = fmin32(1023.0F, max_res_27205);
            float max_arg_27207 = 1024.0F * defunc_0_f_res_27201;
            float max_res_27208 = fmax32(0.0F, max_arg_27207);
            float min_res_27209 = fmin32(1023.0F, max_res_27208);
            float max_arg_27210 = 1024.0F * defunc_0_f_res_27203;
            float max_res_27211 = fmax32(0.0F, max_arg_27210);
            float min_res_27212 = fmin32(1023.0F, max_res_27211);
            int32_t unsign_arg_28000 = fptoui_f32_i32(min_res_27206);
            int32_t x_28002 = mul32(65537, unsign_arg_28000);
            int32_t v_28003 = -16776961 & x_28002;
            int32_t x_28004 = mul32(257, v_28003);
            int32_t v_28005 = 251719695 & x_28004;
            int32_t x_28006 = mul32(17, v_28005);
            int32_t v_28007 = -1022611261 & x_28006;
            int32_t x_28008 = mul32(5, v_28007);
            int32_t v_28009 = 1227133513 & x_28008;
            int32_t unsign_arg_28011 = fptoui_f32_i32(min_res_27209);
            int32_t x_28013 = mul32(65537, unsign_arg_28011);
            int32_t v_28014 = -16776961 & x_28013;
            int32_t x_28015 = mul32(257, v_28014);
            int32_t v_28016 = 251719695 & x_28015;
            int32_t x_28017 = mul32(17, v_28016);
            int32_t v_28018 = -1022611261 & x_28017;
            int32_t x_28019 = mul32(5, v_28018);
            int32_t v_28020 = 1227133513 & x_28019;
            int32_t unsign_arg_28022 = fptoui_f32_i32(min_res_27212);
            int32_t x_28024 = mul32(65537, unsign_arg_28022);
            int32_t v_28025 = -16776961 & x_28024;
            int32_t x_28026 = mul32(257, v_28025);
            int32_t v_28027 = 251719695 & x_28026;
            int32_t x_28028 = mul32(17, v_28027);
            int32_t v_28029 = -1022611261 & x_28028;
            int32_t x_28030 = mul32(5, v_28029);
            int32_t v_28031 = 1227133513 & x_28030;
            int32_t x_27219 = mul32(4, v_28009);
            int32_t y_27220 = mul32(2, v_28020);
            int32_t x_27221 = add32(x_27219, y_27220);
            int32_t defunc_0_g_res_27222 = add32(x_27221, v_28031);
            
            if ((int64_t) 4 > 0)
                memmove(mem_29752.mem + i_29393 * (int64_t) 4,
                        mem_param_29563.mem + ((int64_t) 0 + (int64_t) 1 *
                                               x_27182) * (int64_t) 4,
                        (int64_t) 4);
            if ((int64_t) 4 > 0)
                memmove(mem_29755 + i_29393 * (int64_t) 4, mem_param_29568.mem +
                        ((int64_t) 0 + (int64_t) 1 * x_27182) * (int64_t) 4,
                        (int64_t) 4);
            if ((int64_t) 4 > 0)
                memmove(mem_29758 + i_29393 * (int64_t) 4, mem_param_29573.mem +
                        ((int64_t) 0 + (int64_t) 1 * x_27182) * (int64_t) 4,
                        (int64_t) 4);
            if ((int64_t) 4 > 0)
                memmove(mem_29761 + i_29393 * (int64_t) 4, mem_param_29578.mem +
                        ((int64_t) 0 + (int64_t) 1 * x_27182) * (int64_t) 4,
                        (int64_t) 4);
            if ((int64_t) 4 > 0)
                memmove(mem_29764 + i_29393 * (int64_t) 4, mem_param_29583.mem +
                        ((int64_t) 0 + (int64_t) 1 * x_27182) * (int64_t) 4,
                        (int64_t) 4);
            if ((int64_t) 4 > 0)
                memmove(mem_29767 + i_29393 * (int64_t) 4, mem_param_29588.mem +
                        ((int64_t) 0 + (int64_t) 1 * x_27182) * (int64_t) 4,
                        (int64_t) 4);
            if ((int64_t) 4 > 0)
                memmove(mem_29770 + i_29393 * (int64_t) 4, mem_param_29593.mem +
                        ((int64_t) 0 + (int64_t) 1 * x_27182) * (int64_t) 4,
                        (int64_t) 4);
            ((int32_t *) mem_29773)[i_29393] = defunc_0_g_res_27222;
        }
        if (memblock_unref(ctx, &ext_mem_29740, "ext_mem_29740") != 0)
            return 1;
        for (int64_t i_29418 = 0; i_29418 < i_27006; i_29418++) {
            int32_t i64_res_27234 = sext_i64_i32(i_29418);
            int32_t lifted_delta_arg_27235 = add32(1, i64_res_27234);
            bool cond_28163 = sle32(0, lifted_delta_arg_27235);
            bool cond_t_res_28165 = slt32(lifted_delta_arg_27235,
                                          i64_res_28164);
            bool x_28166 = cond_28163 && cond_t_res_28165;
            int32_t lifted_delta_res_28167;
            
            if (x_28166) {
                int64_t i_28168 = sext_i32_i64(i64_res_27234);
                bool x_28169 = sle64((int64_t) 0, i_28168);
                bool y_28170 = slt64(i_28168, n_21239);
                bool bounds_check_28171 = x_28169 && y_28170;
                bool index_certs_28172;
                
                if (!bounds_check_28171) {
                    ctx->error =
                        msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                  "Index [", (long long) i_28168,
                                  "] out of bounds for array of shape [",
                                  (long long) n_21239, "].",
                                  "-> #0  sample_programs/radixtree.fut:19:19-22\n   #1  sample_programs/radixtree.fut:31:22-33\n   #2  /prelude/soacs.fut:59:3-10\n   #3  /prelude/array.fut:195:3-17\n   #4  sample_programs/radixtree.fut:70:40-58\n   #5  sample_programs/octree.fut:199:16-36\n   #6  sample_programs/nbody.fut:62:5-25\n   #7  sample_programs/nbody.fut:69:26-57\n   #8  sample_programs/nbody.fut:75:5-49\n   #9  sample_programs/nbody.fut:102:17-75\n   #10 sample_programs/nbody.fut:89:1-106:46\n");
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int32_t Li_28173;
                
                Li_28173 = ((int32_t *) mem_29773)[i_28168];
                
                int64_t j_28174 = sext_i32_i64(lifted_delta_arg_27235);
                bool x_28175 = sle64((int64_t) 0, j_28174);
                bool y_28176 = slt64(j_28174, n_21239);
                bool bounds_check_28177 = x_28175 && y_28176;
                bool index_certs_28178;
                
                if (!bounds_check_28177) {
                    ctx->error =
                        msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                  "Index [", (long long) j_28174,
                                  "] out of bounds for array of shape [",
                                  (long long) n_21239, "].",
                                  "-> #0  sample_programs/radixtree.fut:20:19-22\n   #1  sample_programs/radixtree.fut:31:22-33\n   #2  /prelude/soacs.fut:59:3-10\n   #3  /prelude/array.fut:195:3-17\n   #4  sample_programs/radixtree.fut:70:40-58\n   #5  sample_programs/octree.fut:199:16-36\n   #6  sample_programs/nbody.fut:62:5-25\n   #7  sample_programs/nbody.fut:69:26-57\n   #8  sample_programs/nbody.fut:75:5-49\n   #9  sample_programs/nbody.fut:102:17-75\n   #10 sample_programs/nbody.fut:89:1-106:46\n");
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int32_t Lj_28179;
                
                Lj_28179 = ((int32_t *) mem_29773)[j_28174];
                
                bool cond_28180 = Li_28173 == Lj_28179;
                int32_t lifted_delta_res_t_res_28181;
                
                if (cond_28180) {
                    int32_t clzz_arg_28182 = i64_res_27234 ^
                            lifted_delta_arg_27235;
                    int32_t clzz_res_28183;
                    
                    clzz_res_28183 = futrts_clzz32(clzz_arg_28182);
                    
                    int32_t lifted_delta_res_t_res_t_res_28184 = add32(32,
                                                                       clzz_res_28183);
                    
                    lifted_delta_res_t_res_28181 =
                        lifted_delta_res_t_res_t_res_28184;
                } else {
                    int32_t clzz_arg_28898 = Li_28173 ^ Lj_28179;
                    int32_t clzz_res_28899;
                    
                    clzz_res_28899 = futrts_clzz32(clzz_arg_28898);
                    lifted_delta_res_t_res_28181 = clzz_res_28899;
                }
                lifted_delta_res_28167 = lifted_delta_res_t_res_28181;
            } else {
                lifted_delta_res_28167 = -1;
            }
            
            int32_t lifted_delta_arg_27237 = sub32(i64_res_27234, 1);
            bool cond_28191 = sle32(0, lifted_delta_arg_27237);
            bool cond_t_res_28193 = slt32(lifted_delta_arg_27237,
                                          i64_res_28164);
            bool x_28194 = cond_28191 && cond_t_res_28193;
            int32_t lifted_delta_res_28195;
            
            if (x_28194) {
                int64_t i_28196 = sext_i32_i64(i64_res_27234);
                bool x_28197 = sle64((int64_t) 0, i_28196);
                bool y_28198 = slt64(i_28196, n_21239);
                bool bounds_check_28199 = x_28197 && y_28198;
                bool index_certs_28200;
                
                if (!bounds_check_28199) {
                    ctx->error =
                        msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                  "Index [", (long long) i_28196,
                                  "] out of bounds for array of shape [",
                                  (long long) n_21239, "].",
                                  "-> #0  sample_programs/radixtree.fut:19:19-22\n   #1  sample_programs/radixtree.fut:31:37-48\n   #2  /prelude/soacs.fut:59:3-10\n   #3  /prelude/array.fut:195:3-17\n   #4  sample_programs/radixtree.fut:70:40-58\n   #5  sample_programs/octree.fut:199:16-36\n   #6  sample_programs/nbody.fut:62:5-25\n   #7  sample_programs/nbody.fut:69:26-57\n   #8  sample_programs/nbody.fut:75:5-49\n   #9  sample_programs/nbody.fut:102:17-75\n   #10 sample_programs/nbody.fut:89:1-106:46\n");
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int32_t Li_28201;
                
                Li_28201 = ((int32_t *) mem_29773)[i_28196];
                
                int64_t j_28202 = sext_i32_i64(lifted_delta_arg_27237);
                bool x_28203 = sle64((int64_t) 0, j_28202);
                bool y_28204 = slt64(j_28202, n_21239);
                bool bounds_check_28205 = x_28203 && y_28204;
                bool index_certs_28206;
                
                if (!bounds_check_28205) {
                    ctx->error =
                        msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                  "Index [", (long long) j_28202,
                                  "] out of bounds for array of shape [",
                                  (long long) n_21239, "].",
                                  "-> #0  sample_programs/radixtree.fut:20:19-22\n   #1  sample_programs/radixtree.fut:31:37-48\n   #2  /prelude/soacs.fut:59:3-10\n   #3  /prelude/array.fut:195:3-17\n   #4  sample_programs/radixtree.fut:70:40-58\n   #5  sample_programs/octree.fut:199:16-36\n   #6  sample_programs/nbody.fut:62:5-25\n   #7  sample_programs/nbody.fut:69:26-57\n   #8  sample_programs/nbody.fut:75:5-49\n   #9  sample_programs/nbody.fut:102:17-75\n   #10 sample_programs/nbody.fut:89:1-106:46\n");
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int32_t Lj_28207;
                
                Lj_28207 = ((int32_t *) mem_29773)[j_28202];
                
                bool cond_28208 = Li_28201 == Lj_28207;
                int32_t lifted_delta_res_t_res_28209;
                
                if (cond_28208) {
                    int32_t clzz_arg_28210 = i64_res_27234 ^
                            lifted_delta_arg_27237;
                    int32_t clzz_res_28211;
                    
                    clzz_res_28211 = futrts_clzz32(clzz_arg_28210);
                    
                    int32_t lifted_delta_res_t_res_t_res_28212 = add32(32,
                                                                       clzz_res_28211);
                    
                    lifted_delta_res_t_res_28209 =
                        lifted_delta_res_t_res_t_res_28212;
                } else {
                    int32_t clzz_arg_28900 = Li_28201 ^ Lj_28207;
                    int32_t clzz_res_28901;
                    
                    clzz_res_28901 = futrts_clzz32(clzz_arg_28900);
                    lifted_delta_res_t_res_28209 = clzz_res_28901;
                }
                lifted_delta_res_28195 = lifted_delta_res_t_res_28209;
            } else {
                lifted_delta_res_28195 = -1;
            }
            
            int32_t sgn_arg_27239 = sub32(lifted_delta_res_28167,
                                          lifted_delta_res_28195);
            int32_t sgn_res_27240 = (sgn_arg_27239 > 0) - (sgn_arg_27239 < 0);
            int32_t lifted_delta_arg_27241 = sub32(i64_res_27234,
                                                   sgn_res_27240);
            bool cond_28219 = sle32(0, lifted_delta_arg_27241);
            bool cond_t_res_28221 = slt32(lifted_delta_arg_27241,
                                          i64_res_28164);
            bool x_28222 = cond_28219 && cond_t_res_28221;
            int32_t lifted_delta_res_28223;
            
            if (x_28222) {
                int64_t i_28224 = sext_i32_i64(i64_res_27234);
                bool x_28225 = sle64((int64_t) 0, i_28224);
                bool y_28226 = slt64(i_28224, n_21239);
                bool bounds_check_28227 = x_28225 && y_28226;
                bool index_certs_28228;
                
                if (!bounds_check_28227) {
                    ctx->error =
                        msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                  "Index [", (long long) i_28224,
                                  "] out of bounds for array of shape [",
                                  (long long) n_21239, "].",
                                  "-> #0  sample_programs/radixtree.fut:19:19-22\n   #1  sample_programs/radixtree.fut:34:21-32\n   #2  /prelude/soacs.fut:59:3-10\n   #3  /prelude/array.fut:195:3-17\n   #4  sample_programs/radixtree.fut:70:40-58\n   #5  sample_programs/octree.fut:199:16-36\n   #6  sample_programs/nbody.fut:62:5-25\n   #7  sample_programs/nbody.fut:69:26-57\n   #8  sample_programs/nbody.fut:75:5-49\n   #9  sample_programs/nbody.fut:102:17-75\n   #10 sample_programs/nbody.fut:89:1-106:46\n");
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int32_t Li_28229;
                
                Li_28229 = ((int32_t *) mem_29773)[i_28224];
                
                int64_t j_28230 = sext_i32_i64(lifted_delta_arg_27241);
                bool x_28231 = sle64((int64_t) 0, j_28230);
                bool y_28232 = slt64(j_28230, n_21239);
                bool bounds_check_28233 = x_28231 && y_28232;
                bool index_certs_28234;
                
                if (!bounds_check_28233) {
                    ctx->error =
                        msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                  "Index [", (long long) j_28230,
                                  "] out of bounds for array of shape [",
                                  (long long) n_21239, "].",
                                  "-> #0  sample_programs/radixtree.fut:20:19-22\n   #1  sample_programs/radixtree.fut:34:21-32\n   #2  /prelude/soacs.fut:59:3-10\n   #3  /prelude/array.fut:195:3-17\n   #4  sample_programs/radixtree.fut:70:40-58\n   #5  sample_programs/octree.fut:199:16-36\n   #6  sample_programs/nbody.fut:62:5-25\n   #7  sample_programs/nbody.fut:69:26-57\n   #8  sample_programs/nbody.fut:75:5-49\n   #9  sample_programs/nbody.fut:102:17-75\n   #10 sample_programs/nbody.fut:89:1-106:46\n");
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int32_t Lj_28235;
                
                Lj_28235 = ((int32_t *) mem_29773)[j_28230];
                
                bool cond_28236 = Li_28229 == Lj_28235;
                int32_t lifted_delta_res_t_res_28237;
                
                if (cond_28236) {
                    int32_t clzz_arg_28238 = i64_res_27234 ^
                            lifted_delta_arg_27241;
                    int32_t clzz_res_28239;
                    
                    clzz_res_28239 = futrts_clzz32(clzz_arg_28238);
                    
                    int32_t lifted_delta_res_t_res_t_res_28240 = add32(32,
                                                                       clzz_res_28239);
                    
                    lifted_delta_res_t_res_28237 =
                        lifted_delta_res_t_res_t_res_28240;
                } else {
                    int32_t clzz_arg_28902 = Li_28229 ^ Lj_28235;
                    int32_t clzz_res_28903;
                    
                    clzz_res_28903 = futrts_clzz32(clzz_arg_28902);
                    lifted_delta_res_t_res_28237 = clzz_res_28903;
                }
                lifted_delta_res_28223 = lifted_delta_res_t_res_28237;
            } else {
                lifted_delta_res_28223 = -1;
            }
            
            int32_t y_27243 = mul32(2, sgn_res_27240);
            int32_t lifted_delta_arg_27244 = add32(i64_res_27234, y_27243);
            bool cond_28247 = sle32(0, lifted_delta_arg_27244);
            bool cond_t_res_28249 = slt32(lifted_delta_arg_27244,
                                          i64_res_28164);
            bool x_28250 = cond_28247 && cond_t_res_28249;
            int32_t lifted_delta_res_28251;
            
            if (x_28250) {
                int64_t i_28252 = sext_i32_i64(i64_res_27234);
                bool x_28253 = sle64((int64_t) 0, i_28252);
                bool y_28254 = slt64(i_28252, n_21239);
                bool bounds_check_28255 = x_28253 && y_28254;
                bool index_certs_28256;
                
                if (!bounds_check_28255) {
                    ctx->error =
                        msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                  "Index [", (long long) i_28252,
                                  "] out of bounds for array of shape [",
                                  (long long) n_21239, "].",
                                  "-> #0  sample_programs/radixtree.fut:19:19-22\n   #1  sample_programs/radixtree.fut:36:23-41\n   #2  /prelude/soacs.fut:59:3-10\n   #3  /prelude/array.fut:195:3-17\n   #4  sample_programs/radixtree.fut:70:40-58\n   #5  sample_programs/octree.fut:199:16-36\n   #6  sample_programs/nbody.fut:62:5-25\n   #7  sample_programs/nbody.fut:69:26-57\n   #8  sample_programs/nbody.fut:75:5-49\n   #9  sample_programs/nbody.fut:102:17-75\n   #10 sample_programs/nbody.fut:89:1-106:46\n");
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int32_t Li_28257;
                
                Li_28257 = ((int32_t *) mem_29773)[i_28252];
                
                int64_t j_28258 = sext_i32_i64(lifted_delta_arg_27244);
                bool x_28259 = sle64((int64_t) 0, j_28258);
                bool y_28260 = slt64(j_28258, n_21239);
                bool bounds_check_28261 = x_28259 && y_28260;
                bool index_certs_28262;
                
                if (!bounds_check_28261) {
                    ctx->error =
                        msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                  "Index [", (long long) j_28258,
                                  "] out of bounds for array of shape [",
                                  (long long) n_21239, "].",
                                  "-> #0  sample_programs/radixtree.fut:20:19-22\n   #1  sample_programs/radixtree.fut:36:23-41\n   #2  /prelude/soacs.fut:59:3-10\n   #3  /prelude/array.fut:195:3-17\n   #4  sample_programs/radixtree.fut:70:40-58\n   #5  sample_programs/octree.fut:199:16-36\n   #6  sample_programs/nbody.fut:62:5-25\n   #7  sample_programs/nbody.fut:69:26-57\n   #8  sample_programs/nbody.fut:75:5-49\n   #9  sample_programs/nbody.fut:102:17-75\n   #10 sample_programs/nbody.fut:89:1-106:46\n");
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int32_t Lj_28263;
                
                Lj_28263 = ((int32_t *) mem_29773)[j_28258];
                
                bool cond_28264 = Li_28257 == Lj_28263;
                int32_t lifted_delta_res_t_res_28265;
                
                if (cond_28264) {
                    int32_t clzz_arg_28266 = i64_res_27234 ^
                            lifted_delta_arg_27244;
                    int32_t clzz_res_28267;
                    
                    clzz_res_28267 = futrts_clzz32(clzz_arg_28266);
                    
                    int32_t lifted_delta_res_t_res_t_res_28268 = add32(32,
                                                                       clzz_res_28267);
                    
                    lifted_delta_res_t_res_28265 =
                        lifted_delta_res_t_res_t_res_28268;
                } else {
                    int32_t clzz_arg_28904 = Li_28257 ^ Lj_28263;
                    int32_t clzz_res_28905;
                    
                    clzz_res_28905 = futrts_clzz32(clzz_arg_28904);
                    lifted_delta_res_t_res_28265 = clzz_res_28905;
                }
                lifted_delta_res_28251 = lifted_delta_res_t_res_28265;
            } else {
                lifted_delta_res_28251 = -1;
            }
            
            bool loop_cond_27246 = slt32(lifted_delta_res_28223,
                                         lifted_delta_res_28251);
            bool l_max_27247;
            int32_t l_max_27248;
            bool loop_while_27249;
            int32_t l_max_27250;
            
            loop_while_27249 = loop_cond_27246;
            l_max_27250 = 2;
            while (loop_while_27249) {
                int32_t loopres_27251 = mul32(2, l_max_27250);
                int32_t y_27252 = mul32(sgn_res_27240, loopres_27251);
                int32_t lifted_delta_arg_27253 = add32(i64_res_27234, y_27252);
                bool cond_28275 = sle32(0, lifted_delta_arg_27253);
                bool cond_t_res_28277 = slt32(lifted_delta_arg_27253,
                                              i64_res_28164);
                bool x_28278 = cond_28275 && cond_t_res_28277;
                int32_t lifted_delta_res_28279;
                
                if (x_28278) {
                    int64_t i_28280 = sext_i32_i64(i64_res_27234);
                    bool x_28281 = sle64((int64_t) 0, i_28280);
                    bool y_28282 = slt64(i_28280, n_21239);
                    bool bounds_check_28283 = x_28281 && y_28282;
                    bool index_certs_28284;
                    
                    if (!bounds_check_28283) {
                        ctx->error =
                            msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                      "Index [", (long long) i_28280,
                                      "] out of bounds for array of shape [",
                                      (long long) n_21239, "].",
                                      "-> #0  sample_programs/radixtree.fut:19:19-22\n   #1  sample_programs/radixtree.fut:36:23-41\n   #2  /prelude/soacs.fut:59:3-10\n   #3  /prelude/array.fut:195:3-17\n   #4  sample_programs/radixtree.fut:70:40-58\n   #5  sample_programs/octree.fut:199:16-36\n   #6  sample_programs/nbody.fut:62:5-25\n   #7  sample_programs/nbody.fut:69:26-57\n   #8  sample_programs/nbody.fut:75:5-49\n   #9  sample_programs/nbody.fut:102:17-75\n   #10 sample_programs/nbody.fut:89:1-106:46\n");
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int32_t Li_28285;
                    
                    Li_28285 = ((int32_t *) mem_29773)[i_28280];
                    
                    int64_t j_28286 = sext_i32_i64(lifted_delta_arg_27253);
                    bool x_28287 = sle64((int64_t) 0, j_28286);
                    bool y_28288 = slt64(j_28286, n_21239);
                    bool bounds_check_28289 = x_28287 && y_28288;
                    bool index_certs_28290;
                    
                    if (!bounds_check_28289) {
                        ctx->error =
                            msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                      "Index [", (long long) j_28286,
                                      "] out of bounds for array of shape [",
                                      (long long) n_21239, "].",
                                      "-> #0  sample_programs/radixtree.fut:20:19-22\n   #1  sample_programs/radixtree.fut:36:23-41\n   #2  /prelude/soacs.fut:59:3-10\n   #3  /prelude/array.fut:195:3-17\n   #4  sample_programs/radixtree.fut:70:40-58\n   #5  sample_programs/octree.fut:199:16-36\n   #6  sample_programs/nbody.fut:62:5-25\n   #7  sample_programs/nbody.fut:69:26-57\n   #8  sample_programs/nbody.fut:75:5-49\n   #9  sample_programs/nbody.fut:102:17-75\n   #10 sample_programs/nbody.fut:89:1-106:46\n");
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int32_t Lj_28291;
                    
                    Lj_28291 = ((int32_t *) mem_29773)[j_28286];
                    
                    bool cond_28292 = Li_28285 == Lj_28291;
                    int32_t lifted_delta_res_t_res_28293;
                    
                    if (cond_28292) {
                        int32_t clzz_arg_28294 = i64_res_27234 ^
                                lifted_delta_arg_27253;
                        int32_t clzz_res_28295;
                        
                        clzz_res_28295 = futrts_clzz32(clzz_arg_28294);
                        
                        int32_t lifted_delta_res_t_res_t_res_28296 = add32(32,
                                                                           clzz_res_28295);
                        
                        lifted_delta_res_t_res_28293 =
                            lifted_delta_res_t_res_t_res_28296;
                    } else {
                        int32_t clzz_arg_28906 = Li_28285 ^ Lj_28291;
                        int32_t clzz_res_28907;
                        
                        clzz_res_28907 = futrts_clzz32(clzz_arg_28906);
                        lifted_delta_res_t_res_28293 = clzz_res_28907;
                    }
                    lifted_delta_res_28279 = lifted_delta_res_t_res_28293;
                } else {
                    lifted_delta_res_28279 = -1;
                }
                
                bool loop_cond_27255 = slt32(lifted_delta_res_28223,
                                             lifted_delta_res_28279);
                bool loop_while_tmp_30694 = loop_cond_27255;
                int32_t l_max_tmp_30695 = loopres_27251;
                
                loop_while_27249 = loop_while_tmp_30694;
                l_max_27250 = l_max_tmp_30695;
            }
            l_max_27247 = loop_while_27249;
            l_max_27248 = l_max_27250;
            
            int32_t loop_init_27256 = sdiv32(l_max_27248, 2);
            bool loop_cond_27257 = slt32(0, loop_init_27256);
            bool l_27258;
            int32_t l_27259;
            int32_t l_27260;
            bool loop_while_27261;
            int32_t l_27262;
            int32_t t_27263;
            
            loop_while_27261 = loop_cond_27257;
            l_27262 = 0;
            t_27263 = loop_init_27256;
            while (loop_while_27261) {
                int32_t x_27264 = add32(l_27262, t_27263);
                int32_t y_27265 = mul32(sgn_res_27240, x_27264);
                int32_t lifted_delta_arg_27266 = add32(i64_res_27234, y_27265);
                bool cond_28303 = sle32(0, lifted_delta_arg_27266);
                bool cond_t_res_28305 = slt32(lifted_delta_arg_27266,
                                              i64_res_28164);
                bool x_28306 = cond_28303 && cond_t_res_28305;
                int32_t lifted_delta_res_28307;
                
                if (x_28306) {
                    int64_t i_28308 = sext_i32_i64(i64_res_27234);
                    bool x_28309 = sle64((int64_t) 0, i_28308);
                    bool y_28310 = slt64(i_28308, n_21239);
                    bool bounds_check_28311 = x_28309 && y_28310;
                    bool index_certs_28312;
                    
                    if (!bounds_check_28311) {
                        ctx->error =
                            msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                      "Index [", (long long) i_28308,
                                      "] out of bounds for array of shape [",
                                      (long long) n_21239, "].",
                                      "-> #0  sample_programs/radixtree.fut:19:19-22\n   #1  sample_programs/radixtree.fut:42:23-41\n   #2  /prelude/soacs.fut:59:3-10\n   #3  /prelude/array.fut:195:3-17\n   #4  sample_programs/radixtree.fut:70:40-58\n   #5  sample_programs/octree.fut:199:16-36\n   #6  sample_programs/nbody.fut:62:5-25\n   #7  sample_programs/nbody.fut:69:26-57\n   #8  sample_programs/nbody.fut:75:5-49\n   #9  sample_programs/nbody.fut:102:17-75\n   #10 sample_programs/nbody.fut:89:1-106:46\n");
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int32_t Li_28313;
                    
                    Li_28313 = ((int32_t *) mem_29773)[i_28308];
                    
                    int64_t j_28314 = sext_i32_i64(lifted_delta_arg_27266);
                    bool x_28315 = sle64((int64_t) 0, j_28314);
                    bool y_28316 = slt64(j_28314, n_21239);
                    bool bounds_check_28317 = x_28315 && y_28316;
                    bool index_certs_28318;
                    
                    if (!bounds_check_28317) {
                        ctx->error =
                            msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                      "Index [", (long long) j_28314,
                                      "] out of bounds for array of shape [",
                                      (long long) n_21239, "].",
                                      "-> #0  sample_programs/radixtree.fut:20:19-22\n   #1  sample_programs/radixtree.fut:42:23-41\n   #2  /prelude/soacs.fut:59:3-10\n   #3  /prelude/array.fut:195:3-17\n   #4  sample_programs/radixtree.fut:70:40-58\n   #5  sample_programs/octree.fut:199:16-36\n   #6  sample_programs/nbody.fut:62:5-25\n   #7  sample_programs/nbody.fut:69:26-57\n   #8  sample_programs/nbody.fut:75:5-49\n   #9  sample_programs/nbody.fut:102:17-75\n   #10 sample_programs/nbody.fut:89:1-106:46\n");
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int32_t Lj_28319;
                    
                    Lj_28319 = ((int32_t *) mem_29773)[j_28314];
                    
                    bool cond_28320 = Li_28313 == Lj_28319;
                    int32_t lifted_delta_res_t_res_28321;
                    
                    if (cond_28320) {
                        int32_t clzz_arg_28322 = i64_res_27234 ^
                                lifted_delta_arg_27266;
                        int32_t clzz_res_28323;
                        
                        clzz_res_28323 = futrts_clzz32(clzz_arg_28322);
                        
                        int32_t lifted_delta_res_t_res_t_res_28324 = add32(32,
                                                                           clzz_res_28323);
                        
                        lifted_delta_res_t_res_28321 =
                            lifted_delta_res_t_res_t_res_28324;
                    } else {
                        int32_t clzz_arg_28908 = Li_28313 ^ Lj_28319;
                        int32_t clzz_res_28909;
                        
                        clzz_res_28909 = futrts_clzz32(clzz_arg_28908);
                        lifted_delta_res_t_res_28321 = clzz_res_28909;
                    }
                    lifted_delta_res_28307 = lifted_delta_res_t_res_28321;
                } else {
                    lifted_delta_res_28307 = -1;
                }
                
                bool cond_27268 = slt32(lifted_delta_res_28223,
                                        lifted_delta_res_28307);
                int32_t loopres_27269;
                
                if (cond_27268) {
                    loopres_27269 = x_27264;
                } else {
                    loopres_27269 = l_27262;
                }
                
                int32_t loopres_27270;
                
                if (cond_27268) {
                    int32_t loopres_t_res_27271 = sdiv32(t_27263, 2);
                    
                    loopres_27270 = loopres_t_res_27271;
                } else {
                    int32_t loopres_f_res_28910 = sdiv32(t_27263, 2);
                    
                    loopres_27270 = loopres_f_res_28910;
                }
                
                bool loop_cond_27273 = slt32(0, loopres_27270);
                bool loop_while_tmp_30696 = loop_cond_27273;
                int32_t l_tmp_30697 = loopres_27269;
                int32_t t_tmp_30698 = loopres_27270;
                
                loop_while_27261 = loop_while_tmp_30696;
                l_27262 = l_tmp_30697;
                t_27263 = t_tmp_30698;
            }
            l_27258 = loop_while_27261;
            l_27259 = l_27262;
            l_27260 = t_27263;
            
            int32_t y_27274 = mul32(sgn_res_27240, l_27259);
            int32_t j_27275 = add32(i64_res_27234, y_27274);
            bool cond_28331 = sle32(0, j_27275);
            bool cond_t_res_28333 = slt32(j_27275, i64_res_28164);
            bool x_28334 = cond_28331 && cond_t_res_28333;
            int32_t lifted_delta_res_28335;
            
            if (x_28334) {
                int64_t i_28336 = sext_i32_i64(i64_res_27234);
                bool x_28337 = sle64((int64_t) 0, i_28336);
                bool y_28338 = slt64(i_28336, n_21239);
                bool bounds_check_28339 = x_28337 && y_28338;
                bool index_certs_28340;
                
                if (!bounds_check_28339) {
                    ctx->error =
                        msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                  "Index [", (long long) i_28336,
                                  "] out of bounds for array of shape [",
                                  (long long) n_21239, "].",
                                  "-> #0  sample_programs/radixtree.fut:19:19-22\n   #1  sample_programs/radixtree.fut:48:22-32\n   #2  /prelude/soacs.fut:59:3-10\n   #3  /prelude/array.fut:195:3-17\n   #4  sample_programs/radixtree.fut:70:40-58\n   #5  sample_programs/octree.fut:199:16-36\n   #6  sample_programs/nbody.fut:62:5-25\n   #7  sample_programs/nbody.fut:69:26-57\n   #8  sample_programs/nbody.fut:75:5-49\n   #9  sample_programs/nbody.fut:102:17-75\n   #10 sample_programs/nbody.fut:89:1-106:46\n");
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int32_t Li_28341;
                
                Li_28341 = ((int32_t *) mem_29773)[i_28336];
                
                int64_t j_28342 = sext_i32_i64(j_27275);
                bool x_28343 = sle64((int64_t) 0, j_28342);
                bool y_28344 = slt64(j_28342, n_21239);
                bool bounds_check_28345 = x_28343 && y_28344;
                bool index_certs_28346;
                
                if (!bounds_check_28345) {
                    ctx->error =
                        msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                  "Index [", (long long) j_28342,
                                  "] out of bounds for array of shape [",
                                  (long long) n_21239, "].",
                                  "-> #0  sample_programs/radixtree.fut:20:19-22\n   #1  sample_programs/radixtree.fut:48:22-32\n   #2  /prelude/soacs.fut:59:3-10\n   #3  /prelude/array.fut:195:3-17\n   #4  sample_programs/radixtree.fut:70:40-58\n   #5  sample_programs/octree.fut:199:16-36\n   #6  sample_programs/nbody.fut:62:5-25\n   #7  sample_programs/nbody.fut:69:26-57\n   #8  sample_programs/nbody.fut:75:5-49\n   #9  sample_programs/nbody.fut:102:17-75\n   #10 sample_programs/nbody.fut:89:1-106:46\n");
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int32_t Lj_28347;
                
                Lj_28347 = ((int32_t *) mem_29773)[j_28342];
                
                bool cond_28348 = Li_28341 == Lj_28347;
                int32_t lifted_delta_res_t_res_28349;
                
                if (cond_28348) {
                    int32_t clzz_arg_28350 = i64_res_27234 ^ j_27275;
                    int32_t clzz_res_28351;
                    
                    clzz_res_28351 = futrts_clzz32(clzz_arg_28350);
                    
                    int32_t lifted_delta_res_t_res_t_res_28352 = add32(32,
                                                                       clzz_res_28351);
                    
                    lifted_delta_res_t_res_28349 =
                        lifted_delta_res_t_res_t_res_28352;
                } else {
                    int32_t clzz_arg_28911 = Li_28341 ^ Lj_28347;
                    int32_t clzz_res_28912;
                    
                    clzz_res_28912 = futrts_clzz32(clzz_arg_28911);
                    lifted_delta_res_t_res_28349 = clzz_res_28912;
                }
                lifted_delta_res_28335 = lifted_delta_res_t_res_28349;
            } else {
                lifted_delta_res_28335 = -1;
            }
            
            bool loop_cond_27277 = sle32(1, l_27259);
            bool s_27278;
            int32_t s_27279;
            int32_t s_27280;
            bool loop_while_27281;
            int32_t s_27282;
            int32_t q_27283;
            
            loop_while_27281 = loop_cond_27277;
            s_27282 = 0;
            q_27283 = 1;
            while (loop_while_27281) {
                int32_t div_rounding_up_arg_27284 = mul32(2, q_27283);
                int32_t x_27285 = add32(l_27259, div_rounding_up_arg_27284);
                int32_t x_27286 = sub32(x_27285, 1);
                bool zzero_27287 = div_rounding_up_arg_27284 == 0;
                bool nonzzero_27288 = !zzero_27287;
                bool nonzzero_cert_27289;
                
                if (!nonzzero_27288) {
                    ctx->error = msgprintf("Error: %s\n\nBacktrace:\n%s",
                                           "division by zero",
                                           "-> #0  sample_programs/radixtree.fut:8:33-47\n   #1  sample_programs/radixtree.fut:51:26-50\n   #2  /prelude/soacs.fut:59:3-10\n   #3  /prelude/array.fut:195:3-17\n   #4  sample_programs/radixtree.fut:70:40-58\n   #5  sample_programs/octree.fut:199:16-36\n   #6  sample_programs/nbody.fut:62:5-25\n   #7  sample_programs/nbody.fut:69:26-57\n   #8  sample_programs/nbody.fut:75:5-49\n   #9  sample_programs/nbody.fut:102:17-75\n   #10 sample_programs/nbody.fut:89:1-106:46\n");
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int32_t div_rounding_up_res_27290 = sdiv32(x_27286,
                                                           div_rounding_up_arg_27284);
                int32_t x_27291 = add32(s_27282, div_rounding_up_res_27290);
                int32_t y_27292 = mul32(sgn_res_27240, x_27291);
                int32_t lifted_delta_arg_27293 = add32(i64_res_27234, y_27292);
                bool cond_28359 = sle32(0, lifted_delta_arg_27293);
                bool cond_t_res_28361 = slt32(lifted_delta_arg_27293,
                                              i64_res_28164);
                bool x_28362 = cond_28359 && cond_t_res_28361;
                int32_t lifted_delta_res_28363;
                
                if (x_28362) {
                    int64_t i_28364 = sext_i32_i64(i64_res_27234);
                    bool x_28365 = sle64((int64_t) 0, i_28364);
                    bool y_28366 = slt64(i_28364, n_21239);
                    bool bounds_check_28367 = x_28365 && y_28366;
                    bool index_certs_28368;
                    
                    if (!bounds_check_28367) {
                        ctx->error =
                            msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                      "Index [", (long long) i_28364,
                                      "] out of bounds for array of shape [",
                                      (long long) n_21239, "].",
                                      "-> #0  sample_programs/radixtree.fut:19:19-22\n   #1  sample_programs/radixtree.fut:52:24-42\n   #2  /prelude/soacs.fut:59:3-10\n   #3  /prelude/array.fut:195:3-17\n   #4  sample_programs/radixtree.fut:70:40-58\n   #5  sample_programs/octree.fut:199:16-36\n   #6  sample_programs/nbody.fut:62:5-25\n   #7  sample_programs/nbody.fut:69:26-57\n   #8  sample_programs/nbody.fut:75:5-49\n   #9  sample_programs/nbody.fut:102:17-75\n   #10 sample_programs/nbody.fut:89:1-106:46\n");
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int32_t Li_28369;
                    
                    Li_28369 = ((int32_t *) mem_29773)[i_28364];
                    
                    int64_t j_28370 = sext_i32_i64(lifted_delta_arg_27293);
                    bool x_28371 = sle64((int64_t) 0, j_28370);
                    bool y_28372 = slt64(j_28370, n_21239);
                    bool bounds_check_28373 = x_28371 && y_28372;
                    bool index_certs_28374;
                    
                    if (!bounds_check_28373) {
                        ctx->error =
                            msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                      "Index [", (long long) j_28370,
                                      "] out of bounds for array of shape [",
                                      (long long) n_21239, "].",
                                      "-> #0  sample_programs/radixtree.fut:20:19-22\n   #1  sample_programs/radixtree.fut:52:24-42\n   #2  /prelude/soacs.fut:59:3-10\n   #3  /prelude/array.fut:195:3-17\n   #4  sample_programs/radixtree.fut:70:40-58\n   #5  sample_programs/octree.fut:199:16-36\n   #6  sample_programs/nbody.fut:62:5-25\n   #7  sample_programs/nbody.fut:69:26-57\n   #8  sample_programs/nbody.fut:75:5-49\n   #9  sample_programs/nbody.fut:102:17-75\n   #10 sample_programs/nbody.fut:89:1-106:46\n");
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int32_t Lj_28375;
                    
                    Lj_28375 = ((int32_t *) mem_29773)[j_28370];
                    
                    bool cond_28376 = Li_28369 == Lj_28375;
                    int32_t lifted_delta_res_t_res_28377;
                    
                    if (cond_28376) {
                        int32_t clzz_arg_28378 = i64_res_27234 ^
                                lifted_delta_arg_27293;
                        int32_t clzz_res_28379;
                        
                        clzz_res_28379 = futrts_clzz32(clzz_arg_28378);
                        
                        int32_t lifted_delta_res_t_res_t_res_28380 = add32(32,
                                                                           clzz_res_28379);
                        
                        lifted_delta_res_t_res_28377 =
                            lifted_delta_res_t_res_t_res_28380;
                    } else {
                        int32_t clzz_arg_28913 = Li_28369 ^ Lj_28375;
                        int32_t clzz_res_28914;
                        
                        clzz_res_28914 = futrts_clzz32(clzz_arg_28913);
                        lifted_delta_res_t_res_28377 = clzz_res_28914;
                    }
                    lifted_delta_res_28363 = lifted_delta_res_t_res_28377;
                } else {
                    lifted_delta_res_28363 = -1;
                }
                
                bool cond_27295 = slt32(lifted_delta_res_28335,
                                        lifted_delta_res_28363);
                int32_t loopres_27296;
                
                if (cond_27295) {
                    loopres_27296 = x_27291;
                } else {
                    loopres_27296 = s_27282;
                }
                
                bool loop_cond_27297 = sle32(div_rounding_up_arg_27284,
                                             l_27259);
                bool loop_while_tmp_30699 = loop_cond_27297;
                int32_t s_tmp_30700 = loopres_27296;
                int32_t q_tmp_30701 = div_rounding_up_arg_27284;
                
                loop_while_27281 = loop_while_tmp_30699;
                s_27282 = s_tmp_30700;
                q_27283 = q_tmp_30701;
            }
            s_27278 = loop_while_27281;
            s_27279 = s_27282;
            s_27280 = q_27283;
            
            int32_t y_27298 = mul32(sgn_res_27240, s_27279);
            int32_t x_27299 = add32(i64_res_27234, y_27298);
            int32_t min_res_27300 = smin32(0, sgn_res_27240);
            int32_t gamma_27301 = add32(x_27299, min_res_27300);
            int32_t min_res_27302 = smin32(i64_res_27234, j_27275);
            bool cond_27303 = min_res_27302 == gamma_27301;
            int8_t defunc_0_f_res_27304 = btoi_bool_i8(cond_27303);
            int32_t defunc_0_f_res_27305;
            
            if (cond_27303) {
                defunc_0_f_res_27305 = -1;
            } else {
                defunc_0_f_res_27305 = gamma_27301;
            }
            
            int32_t max_res_27306 = smax32(i64_res_27234, j_27275);
            int32_t y_27307 = add32(1, gamma_27301);
            bool cond_27308 = max_res_27306 == y_27307;
            int8_t defunc_0_f_res_27309 = btoi_bool_i8(cond_27308);
            int32_t defunc_0_f_res_27310;
            
            if (cond_27308) {
                defunc_0_f_res_27310 = -1;
            } else {
                defunc_0_f_res_27310 = y_27307;
            }
            
            int64_t defunc_0_g_res_27324 = sext_i32_i64(defunc_0_f_res_27305);
            int64_t defunc_0_g_res_27321 = sext_i32_i64(defunc_0_f_res_27310);
            
            ((int32_t *) mem_29872)[i_29418] = lifted_delta_res_28335;
            ((int8_t *) mem_29874)[i_29418] = defunc_0_f_res_27304;
            ((int32_t *) mem_29877)[i_29418] = gamma_27301;
            ((int8_t *) mem_29879)[i_29418] = defunc_0_f_res_27309;
            ((int32_t *) mem_29882)[i_29418] = y_27307;
            ((int32_t *) mem_29885)[i_29418] = i64_res_27234;
            ((int64_t *) mem_29888)[i_29418] = defunc_0_g_res_27324;
            ((int64_t *) mem_29891)[i_29418] = defunc_0_g_res_27321;
        }
        for (int64_t i_30702 = 0; i_30702 < i_27006; i_30702++) {
            ((int32_t *) mem_29990)[i_30702] = -1;
        }
        for (int64_t write_iter_29427 = 0; write_iter_29427 < i_27006;
             write_iter_29427++) {
            int64_t write_iv_29429;
            
            write_iv_29429 = ((int64_t *) mem_29888)[write_iter_29427];
            
            int64_t write_iv_29431;
            
            write_iv_29431 = ((int64_t *) mem_29891)[write_iter_29427];
            if (sle64((int64_t) 0, write_iv_29429) && slt64(write_iv_29429,
                                                            i_27006)) {
                if ((int64_t) 4 > 0)
                    memmove(mem_29990 + write_iv_29429 * (int64_t) 4,
                            mem_29885 + ((int64_t) 0 + (int64_t) 1 *
                                         write_iter_29427) * (int64_t) 4,
                            (int64_t) 4);
            }
            if (sle64((int64_t) 0, write_iv_29431) && slt64(write_iv_29431,
                                                            i_27006)) {
                if ((int64_t) 4 > 0)
                    memmove(mem_29990 + write_iv_29431 * (int64_t) 4,
                            mem_29885 + ((int64_t) 0 + (int64_t) 1 *
                                         write_iter_29427) * (int64_t) 4,
                            (int64_t) 4);
            }
        }
        
        int32_t root_delta_27331;
        
        root_delta_27331 = ((int32_t *) mem_29872)[(int64_t) 0];
        
        int32_t discard_29446;
        int32_t scanacc_29438 = 0;
        
        for (int64_t i_29442 = 0; i_29442 < i_27006; i_29442++) {
            int32_t x_27334;
            
            x_27334 = ((int32_t *) mem_29872)[i_29442];
            
            int8_t x_27335;
            
            x_27335 = ((int8_t *) mem_29874)[i_29442];
            
            int32_t x_27336;
            
            x_27336 = ((int32_t *) mem_29877)[i_29442];
            
            int8_t x_27337;
            
            x_27337 = ((int8_t *) mem_29879)[i_29442];
            
            int32_t x_27338;
            
            x_27338 = ((int32_t *) mem_29882)[i_29442];
            
            bool match_constr_28050 = (int8_t) 1 == x_27335;
            int32_t lifted_get_delta_res_28051;
            
            if (match_constr_28050) {
                lifted_get_delta_res_28051 = 66;
            } else {
                int64_t i_28915 = sext_i32_i64(x_27336);
                int32_t lifted_get_delta_res_res_28916;
                
                lifted_get_delta_res_res_28916 =
                    ((int32_t *) mem_29872)[i_28915];
                lifted_get_delta_res_28051 = lifted_get_delta_res_res_28916;
            }
            
            int32_t x_28056 = sdiv32(lifted_get_delta_res_28051, 3);
            int32_t y_28057 = sdiv32(x_27334, 3);
            int32_t lifted_edge_res_28058 = sub32(x_28056, y_28057);
            bool match_constr_28069 = (int8_t) 1 == x_27337;
            int32_t lifted_get_delta_res_28070;
            
            if (match_constr_28069) {
                lifted_get_delta_res_28070 = 66;
            } else {
                int64_t i_28917 = sext_i32_i64(x_27338);
                int32_t lifted_get_delta_res_res_28918;
                
                lifted_get_delta_res_res_28918 =
                    ((int32_t *) mem_29872)[i_28917];
                lifted_get_delta_res_28070 = lifted_get_delta_res_res_28918;
            }
            
            int32_t x_28075 = sdiv32(lifted_get_delta_res_28070, 3);
            int32_t lifted_edge_res_28077 = sub32(x_28075, y_28057);
            bool bool_arg_27346 = slt32(0, lifted_edge_res_28058);
            int32_t bool_res_27347 = btoi_bool_i32(bool_arg_27346);
            bool bool_arg_27348 = slt32(0, lifted_edge_res_28077);
            int32_t bool_res_27349 = btoi_bool_i32(bool_arg_27348);
            int32_t defunc_0_f_res_27350 = add32(bool_res_27347,
                                                 bool_res_27349);
            int32_t defunc_1_op_res_27354 = add32(defunc_0_f_res_27350,
                                                  scanacc_29438);
            
            ((int32_t *) mem_30005)[i_29442] = defunc_1_op_res_27354;
            ((int32_t *) mem_30008)[i_29442] = lifted_edge_res_28058;
            ((int32_t *) mem_30011)[i_29442] = lifted_edge_res_28077;
            
            int32_t scanacc_tmp_30704 = defunc_1_op_res_27354;
            
            scanacc_29438 = scanacc_tmp_30704;
        }
        discard_29446 = scanacc_29438;
        
        int32_t last_res_27356;
        
        last_res_27356 = ((int32_t *) mem_30005)[i_27023];
        
        int64_t i32_res_27357 = sext_i32_i64(last_res_27356);
        int64_t sizze_27358 = add64((int64_t) 1, i32_res_27357);
        
        for (int64_t i_29449 = 0; i_29449 < i_27006; i_29449++) {
            int64_t i_p_o_29534 = add64((int64_t) -1, i_29449);
            int64_t rot_i_29535 = smod64(i_p_o_29534, i_27006);
            int32_t x_27361;
            
            x_27361 = ((int32_t *) mem_30005)[rot_i_29535];
            
            int32_t defunc_0_f_res_27362 = add32(1, x_27361);
            
            ((int32_t *) mem_30050)[i_29449] = defunc_0_f_res_27362;
        }
        ((int32_t *) mem_30050)[(int64_t) 0] = 1;
        
        int64_t binop_y_30063 = (int64_t) 4 * sizze_27358;
        int64_t bytes_30064 = smax64((int64_t) 0, binop_y_30063);
        
        if (mem_30065_cached_sizze_30807 < bytes_30064) {
            err = lexical_realloc(&ctx->error, &mem_30065,
                                  &mem_30065_cached_sizze_30807, bytes_30064);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        for (int64_t i_30709 = 0; i_30709 < sizze_27358; i_30709++) {
            ((int32_t *) mem_30065)[i_30709] = 0;
        }
        for (int64_t iter_29451 = 0; iter_29451 < i_27023; iter_29451++) {
            int64_t slice_29533 = (int64_t) 1 + iter_29451;
            int32_t pixel_29453;
            
            pixel_29453 = ((int32_t *) mem_30050)[slice_29533];
            
            int64_t i32_res_27367 = sext_i32_i64(pixel_29453);
            bool less_than_zzero_29455 = slt64(i32_res_27367, (int64_t) 0);
            bool greater_than_sizze_29456 = sle64(sizze_27358, i32_res_27367);
            bool outside_bounds_dim_29457 = less_than_zzero_29455 ||
                 greater_than_sizze_29456;
            
            if (!outside_bounds_dim_29457) {
                int32_t read_hist_29459;
                
                read_hist_29459 = ((int32_t *) mem_30065)[i32_res_27367];
                
                int32_t defunc_1_f_res_27372 = add32(1, read_hist_29459);
                
                ((int32_t *) mem_30065)[i32_res_27367] = defunc_1_f_res_27372;
            }
        }
        if (mem_30081_cached_sizze_30808 < bytes_30064) {
            err = lexical_realloc(&ctx->error, &mem_30081,
                                  &mem_30081_cached_sizze_30808, bytes_30064);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        
        int32_t discard_29467;
        int32_t scanacc_29463 = 0;
        
        for (int64_t i_29465 = 0; i_29465 < sizze_27358; i_29465++) {
            int32_t x_27379;
            
            x_27379 = ((int32_t *) mem_30065)[i_29465];
            
            int32_t defunc_1_op_res_27378 = add32(x_27379, scanacc_29463);
            
            ((int32_t *) mem_30081)[i_29465] = defunc_1_op_res_27378;
            
            int32_t scanacc_tmp_30711 = defunc_1_op_res_27378;
            
            scanacc_29463 = scanacc_tmp_30711;
        }
        discard_29467 = scanacc_29463;
        
        int32_t y_27381 = sdiv32(root_delta_27331, 3);
        
        if (memblock_alloc(ctx, &mem_30096, bytes_30064, "mem_30096")) {
            err = 1;
            goto cleanup;
        }
        if (memblock_alloc(ctx, &mem_30099, bytes_30064, "mem_30099")) {
            err = 1;
            goto cleanup;
        }
        if (memblock_alloc(ctx, &mem_30102, bytes_30064, "mem_30102")) {
            err = 1;
            goto cleanup;
        }
        if (memblock_alloc(ctx, &mem_30105, bytes_30064, "mem_30105")) {
            err = 1;
            goto cleanup;
        }
        
        int64_t binop_y_30107 = (int64_t) 32 * sizze_27358;
        int64_t bytes_30108 = smax64((int64_t) 0, binop_y_30107);
        
        if (memblock_alloc(ctx, &mem_30109, bytes_30108, "mem_30109")) {
            err = 1;
            goto cleanup;
        }
        
        int64_t bytes_30110 = smax64((int64_t) 0, sizze_27358);
        
        if (memblock_alloc(ctx, &mem_30111, bytes_30110, "mem_30111")) {
            err = 1;
            goto cleanup;
        }
        if (memblock_alloc(ctx, &mem_30114, bytes_30064, "mem_30114")) {
            err = 1;
            goto cleanup;
        }
        if (memblock_alloc(ctx, &mem_30117, bytes_30064, "mem_30117")) {
            err = 1;
            goto cleanup;
        }
        for (int64_t i_29484 = 0; i_29484 < sizze_27358; i_29484++) {
            int32_t x_27391;
            
            x_27391 = ((int32_t *) mem_30081)[i_29484];
            
            int32_t i64_res_27392 = sext_i64_i32(i_29484);
            int64_t rp_27393 = sext_i32_i64(x_27391);
            bool x_27394 = sle64((int64_t) 0, rp_27393);
            bool y_27395 = slt64(rp_27393, i_27006);
            bool bounds_check_27396 = x_27394 && y_27395;
            bool index_certs_27397;
            
            if (!bounds_check_27396) {
                ctx->error =
                    msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                              "Index [", (long long) rp_27393,
                              "] out of bounds for array of shape [",
                              (long long) i_27006, "].",
                              "-> #0  sample_programs/octree.fut:51:31-40\n   #1  /prelude/soacs.fut:67:19-23\n   #2  /prelude/soacs.fut:67:3-37\n   #3  sample_programs/octree.fut:48:5-163:28\n   #4  sample_programs/octree.fut:201:16-38\n   #5  sample_programs/nbody.fut:62:5-25\n   #6  sample_programs/nbody.fut:69:26-57\n   #7  sample_programs/nbody.fut:75:5-49\n   #8  sample_programs/nbody.fut:102:17-75\n   #9  sample_programs/nbody.fut:89:1-106:46\n");
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int32_t defunc_1_f_res_27398;
            
            defunc_1_f_res_27398 = ((int32_t *) mem_29872)[rp_27393];
            
            int8_t defunc_1_f_res_27399;
            
            defunc_1_f_res_27399 = ((int8_t *) mem_29874)[rp_27393];
            
            int8_t defunc_1_f_res_27401;
            
            defunc_1_f_res_27401 = ((int8_t *) mem_29879)[rp_27393];
            
            int32_t beginning_27405;
            
            beginning_27405 = ((int32_t *) mem_30050)[rp_27393];
            
            bool is_left_t_res_27409 = beginning_27405 == i64_res_27392;
            int32_t defunc_1_f_res_27403;
            
            defunc_1_f_res_27403 = ((int32_t *) mem_30008)[rp_27393];
            
            bool cond_27408 = slt32(0, defunc_1_f_res_27403);
            bool x_27410 = cond_27408 && is_left_t_res_27409;
            int32_t child_27415;
            
            if (x_27410) {
                int32_t defunc_1_f_res_27400;
                
                defunc_1_f_res_27400 = ((int32_t *) mem_29877)[rp_27393];
                child_27415 = defunc_1_f_res_27400;
            } else {
                int32_t defunc_1_f_res_28919;
                
                defunc_1_f_res_28919 = ((int32_t *) mem_29882)[rp_27393];
                child_27415 = defunc_1_f_res_28919;
            }
            
            bool cond_27411 = i64_res_27392 == 0;
            int32_t x_27406 = sdiv32(defunc_1_f_res_27398, 3);
            int32_t node_level_27407 = sub32(x_27406, y_27381);
            int32_t tree_level_27412;
            
            if (cond_27411) {
                tree_level_27412 = 0;
            } else {
                int32_t y_28921;
                
                if (x_27410) {
                    y_28921 = defunc_1_f_res_27403;
                } else {
                    int32_t defunc_1_f_res_28922;
                    
                    defunc_1_f_res_28922 = ((int32_t *) mem_30011)[rp_27393];
                    y_28921 = defunc_1_f_res_28922;
                }
                
                int32_t tree_level_f_res_28923 = add32(node_level_27407,
                                                       y_28921);
                
                tree_level_27412 = tree_level_f_res_28923;
            }
            
            bool cond_27416 = !cond_27411;
            bool eq_x_y_27417 = (int8_t) 1 == defunc_1_f_res_27399;
            bool eq_x_zz_27418 = (int8_t) 1 == defunc_1_f_res_27401;
            bool p_and_eq_x_y_27419 = x_27410 && eq_x_y_27417;
            bool not_p_27420 = !x_27410;
            bool p_and_eq_x_y_27421 = eq_x_zz_27418 && not_p_27420;
            bool match_constr_27422 = p_and_eq_x_y_27419 || p_and_eq_x_y_27421;
            bool x_27423 = cond_27416 && match_constr_27422;
            float defunc_1_f_res_27424;
            float defunc_1_f_res_27425;
            float defunc_1_f_res_27426;
            float defunc_1_f_res_27427;
            
            if (x_27423) {
                int64_t i_27428 = sext_i32_i64(child_27415);
                bool x_27429 = sle64((int64_t) 0, i_27428);
                bool y_27430 = slt64(i_27428, n_21239);
                bool bounds_check_27431 = x_27429 && y_27430;
                bool index_certs_27432;
                
                if (!bounds_check_27431) {
                    ctx->error =
                        msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                  "Index [", (long long) i_27428,
                                  "] out of bounds for array of shape [",
                                  (long long) n_21239, "].",
                                  "-> #0  sample_programs/octree.fut:76:31-45\n   #1  /prelude/soacs.fut:67:19-23\n   #2  /prelude/soacs.fut:67:3-37\n   #3  sample_programs/octree.fut:48:5-163:28\n   #4  sample_programs/octree.fut:201:16-38\n   #5  sample_programs/nbody.fut:62:5-25\n   #6  sample_programs/nbody.fut:69:26-57\n   #7  sample_programs/nbody.fut:75:5-49\n   #8  sample_programs/nbody.fut:102:17-75\n   #9  sample_programs/nbody.fut:89:1-106:46\n");
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                float defunc_1_f_res_t_res_27433;
                
                defunc_1_f_res_t_res_27433 = ((float *) mem_29752.mem)[i_27428];
                
                float defunc_1_f_res_t_res_27434;
                
                defunc_1_f_res_t_res_27434 = ((float *) mem_29755)[i_27428];
                
                float defunc_1_f_res_t_res_27435;
                
                defunc_1_f_res_t_res_27435 = ((float *) mem_29758)[i_27428];
                
                float defunc_1_f_res_t_res_27436;
                
                defunc_1_f_res_t_res_27436 = ((float *) mem_29761)[i_27428];
                
                float zt_res_27437 = defunc_1_f_res_t_res_27433 *
                      defunc_1_f_res_t_res_27434;
                float zt_res_27438 = defunc_1_f_res_t_res_27433 *
                      defunc_1_f_res_t_res_27435;
                float zt_res_27439 = defunc_1_f_res_t_res_27433 *
                      defunc_1_f_res_t_res_27436;
                
                defunc_1_f_res_27424 = defunc_1_f_res_t_res_27433;
                defunc_1_f_res_27425 = zt_res_27437;
                defunc_1_f_res_27426 = zt_res_27438;
                defunc_1_f_res_27427 = zt_res_27439;
            } else {
                defunc_1_f_res_27424 = 0.0F;
                defunc_1_f_res_27425 = 0.0F;
                defunc_1_f_res_27426 = 0.0F;
                defunc_1_f_res_27427 = 0.0F;
            }
            
            int32_t parent_27440;
            
            if (cond_27411) {
                parent_27440 = -1;
            } else {
                bool parentzq_28949;
                int32_t parentzq_28950;
                int32_t parentzq_28951;
                bool loop_while_28952;
                int32_t parentzq_28953;
                int32_t ridx_28954;
                
                loop_while_28952 = 1;
                parentzq_28953 = -1;
                ridx_28954 = x_27391;
                while (loop_while_28952) {
                    int64_t ridx_28955 = sext_i32_i64(ridx_28954);
                    bool x_28956 = sle64((int64_t) 0, ridx_28955);
                    bool y_28957 = slt64(ridx_28955, i_27006);
                    bool bounds_check_28958 = x_28956 && y_28957;
                    bool index_certs_28959;
                    
                    if (!bounds_check_28958) {
                        ctx->error =
                            msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                      "Index [", (long long) ridx_28955,
                                      "] out of bounds for array of shape [",
                                      (long long) i_27006, "].",
                                      "-> #0  sample_programs/octree.fut:88:41-52\n   #1  /prelude/soacs.fut:67:19-23\n   #2  /prelude/soacs.fut:67:3-37\n   #3  sample_programs/octree.fut:48:5-163:28\n   #4  sample_programs/octree.fut:201:16-38\n   #5  sample_programs/nbody.fut:62:5-25\n   #6  sample_programs/nbody.fut:69:26-57\n   #7  sample_programs/nbody.fut:75:5-49\n   #8  sample_programs/nbody.fut:102:17-75\n   #9  sample_programs/nbody.fut:89:1-106:46\n");
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int32_t parent_ridx_28960;
                    
                    parent_ridx_28960 = ((int32_t *) mem_29990)[ridx_28955];
                    
                    bool cond_28961 = parent_ridx_28960 == -1;
                    int32_t loopres_28962;
                    
                    if (cond_28961) {
                        loopres_28962 = 0;
                    } else {
                        int64_t parent_ridx_28963 =
                                sext_i32_i64(parent_ridx_28960);
                        bool x_28964 = sle64((int64_t) 0, parent_ridx_28963);
                        bool y_28965 = slt64(parent_ridx_28963, i_27006);
                        bool bounds_check_28966 = x_28964 && y_28965;
                        bool index_certs_28967;
                        
                        if (!bounds_check_28966) {
                            ctx->error =
                                msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                          "Index [",
                                          (long long) parent_ridx_28963,
                                          "] out of bounds for array of shape [",
                                          (long long) i_27006, "].",
                                          "-> #0  sample_programs/octree.fut:96:36-54\n   #1  /prelude/soacs.fut:67:19-23\n   #2  /prelude/soacs.fut:67:3-37\n   #3  sample_programs/octree.fut:48:5-163:28\n   #4  sample_programs/octree.fut:201:16-38\n   #5  sample_programs/nbody.fut:62:5-25\n   #6  sample_programs/nbody.fut:69:26-57\n   #7  sample_programs/nbody.fut:75:5-49\n   #8  sample_programs/nbody.fut:102:17-75\n   #9  sample_programs/nbody.fut:89:1-106:46\n");
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int32_t lifted_unpack_arg_28968;
                        
                        lifted_unpack_arg_28968 =
                            ((int32_t *) mem_29877)[parent_ridx_28963];
                        
                        int32_t loopres_f_res_28969;
                        
                        loopres_f_res_28969 =
                            ((int32_t *) mem_30008)[parent_ridx_28963];
                        
                        int32_t loopres_f_res_28970;
                        
                        loopres_f_res_28970 =
                            ((int32_t *) mem_30011)[parent_ridx_28963];
                        
                        bool is_left_28971 = lifted_unpack_arg_28968 ==
                             ridx_28954;
                        bool eq_x_y_28972 = 0 == loopres_f_res_28969;
                        bool eq_x_zz_28973 = 0 == loopres_f_res_28970;
                        bool p_and_eq_x_y_28974 = is_left_28971 && eq_x_y_28972;
                        bool not_p_28975 = !is_left_28971;
                        bool p_and_eq_x_y_28976 = eq_x_zz_28973 && not_p_28975;
                        bool cond_28977 = p_and_eq_x_y_28974 ||
                             p_and_eq_x_y_28976;
                        bool cond_28978 = !cond_28977;
                        int32_t loopres_f_res_28979;
                        
                        if (cond_28978) {
                            int32_t start_28980;
                            
                            start_28980 =
                                ((int32_t *) mem_30050)[parent_ridx_28963];
                            
                            int32_t loopres_f_res_t_res_28981;
                            
                            if (is_left_28971) {
                                loopres_f_res_t_res_28981 = start_28980;
                            } else {
                                bool bool_arg_28982 = slt32(0,
                                                            loopres_f_res_28969);
                                int32_t bool_res_28983 =
                                        btoi_bool_i32(bool_arg_28982);
                                int32_t loopres_f_res_t_res_f_res_28984 =
                                        add32(start_28980, bool_res_28983);
                                
                                loopres_f_res_t_res_28981 =
                                    loopres_f_res_t_res_f_res_28984;
                            }
                            loopres_f_res_28979 = loopres_f_res_t_res_28981;
                        } else {
                            loopres_f_res_28979 = parentzq_28953;
                        }
                        loopres_28962 = loopres_f_res_28979;
                    }
                    
                    bool loop_cond_28985 = loopres_28962 == -1;
                    bool loop_while_tmp_30721 = loop_cond_28985;
                    int32_t parentzq_tmp_30722 = loopres_28962;
                    int32_t ridx_tmp_30723 = parent_ridx_28960;
                    
                    loop_while_28952 = loop_while_tmp_30721;
                    parentzq_28953 = parentzq_tmp_30722;
                    ridx_28954 = ridx_tmp_30723;
                }
                parentzq_28949 = loop_while_28952;
                parentzq_28950 = parentzq_28953;
                parentzq_28951 = ridx_28954;
                parent_27440 = parentzq_28950;
            }
            for (int64_t i_30724 = 0; i_30724 < (int64_t) 8; i_30724++) {
                ((int32_t *) mem_30181)[i_30724] = -1;
            }
            
            struct memblock mainzistatic_array_30725 =
                            ctx->mainzistatic_array_30725;
            
            if ((int64_t) 12 > 0)
                memmove(mem_30183 + (int64_t) 0, mainzistatic_array_30725.mem +
                        (int64_t) 0, (int64_t) 12);
            if (!x_27423) {
                int32_t ridx_29076;
                
                if (cond_27411) {
                    ridx_29076 = 0;
                } else {
                    ridx_29076 = child_27415;
                }
                
                bool arrzq_29077;
                int32_t arrzq_29080;
                int32_t arrzq_29081;
                int32_t arrzq_29082;
                bool loop_while_29083;
                int32_t child_idx_29086;
                int32_t ridx_29087;
                int32_t lvl_29088;
                
                loop_while_29083 = 1;
                child_idx_29086 = 0;
                ridx_29087 = ridx_29076;
                lvl_29088 = 0;
                while (loop_while_29083) {
                    int64_t lvl_29089 = sext_i32_i64(lvl_29088);
                    bool x_29090 = sle64((int64_t) 0, lvl_29089);
                    bool y_29091 = slt64(lvl_29089, (int64_t) 3);
                    bool bounds_check_29092 = x_29090 && y_29091;
                    bool index_certs_29093;
                    
                    if (!bounds_check_29092) {
                        ctx->error =
                            msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                      "Index [", (long long) lvl_29089,
                                      "] out of bounds for array of shape [",
                                      (long long) (int64_t) 3, "].",
                                      "-> #0  sample_programs/octree.fut:131:25-37\n   #1  /prelude/soacs.fut:67:19-23\n   #2  /prelude/soacs.fut:67:3-37\n   #3  sample_programs/octree.fut:48:5-163:28\n   #4  sample_programs/octree.fut:201:16-38\n   #5  sample_programs/nbody.fut:62:5-25\n   #6  sample_programs/nbody.fut:69:26-57\n   #7  sample_programs/nbody.fut:75:5-49\n   #8  sample_programs/nbody.fut:102:17-75\n   #9  sample_programs/nbody.fut:89:1-106:46\n");
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int32_t x_29095;
                    
                    x_29095 = ((int32_t *) mem_30183)[lvl_29089];
                    
                    bool cond_29096 = x_29095 == 2;
                    int32_t loopres_29099;
                    int32_t loopres_29100;
                    int32_t loopres_29101;
                    
                    if (cond_29096) {
                        int64_t ridx_29102 = sext_i32_i64(ridx_29087);
                        bool x_29103 = sle64((int64_t) 0, ridx_29102);
                        bool y_29104 = slt64(ridx_29102, i_27006);
                        bool bounds_check_29105 = x_29103 && y_29104;
                        bool index_certs_29106;
                        
                        if (!bounds_check_29105) {
                            ctx->error =
                                msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                          "Index [", (long long) ridx_29102,
                                          "] out of bounds for array of shape [",
                                          (long long) i_27006, "].",
                                          "-> #0  sample_programs/octree.fut:132:27-37\n   #1  /prelude/soacs.fut:67:19-23\n   #2  /prelude/soacs.fut:67:3-37\n   #3  sample_programs/octree.fut:48:5-163:28\n   #4  sample_programs/octree.fut:201:16-38\n   #5  sample_programs/nbody.fut:62:5-25\n   #6  sample_programs/nbody.fut:69:26-57\n   #7  sample_programs/nbody.fut:75:5-49\n   #8  sample_programs/nbody.fut:102:17-75\n   #9  sample_programs/nbody.fut:89:1-106:46\n");
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int32_t x_29107;
                        
                        x_29107 = ((int32_t *) mem_30008)[ridx_29102];
                        
                        bool cond_29108 = x_29107 == 0;
                        bool cond_29109 = !cond_29108;
                        int32_t loopres_t_res_29112;
                        int32_t loopres_t_res_29113;
                        int32_t loopres_t_res_29114;
                        
                        if (cond_29109) {
                            int64_t child_idx_29115 =
                                    sext_i32_i64(child_idx_29086);
                            bool x_29116 = sle64((int64_t) 0, child_idx_29115);
                            bool y_29117 = slt64(child_idx_29115, (int64_t) 8);
                            bool bounds_check_29118 = x_29116 && y_29117;
                            bool index_certs_29119;
                            
                            if (!bounds_check_29118) {
                                ctx->error =
                                    msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                              "Index [",
                                              (long long) child_idx_29115,
                                              "] out of bounds for array of shape [",
                                              (long long) (int64_t) 8, "].",
                                              "-> #0  sample_programs/octree.fut:134:26-137:65\n   #1  /prelude/soacs.fut:67:19-23\n   #2  /prelude/soacs.fut:67:3-37\n   #3  sample_programs/octree.fut:48:5-163:28\n   #4  sample_programs/octree.fut:201:16-38\n   #5  sample_programs/nbody.fut:62:5-25\n   #6  sample_programs/nbody.fut:69:26-57\n   #7  sample_programs/nbody.fut:75:5-49\n   #8  sample_programs/nbody.fut:102:17-75\n   #9  sample_programs/nbody.fut:89:1-106:46\n");
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            if ((int64_t) 4 > 0)
                                memmove(mem_30181 + child_idx_29115 *
                                        (int64_t) 4, mem_30050 + ((int64_t) 0 +
                                                                  (int64_t) 1 *
                                                                  ridx_29102) *
                                        (int64_t) 4, (int64_t) 4);
                            
                            int32_t child_idx_29122 = add32(1, child_idx_29086);
                            
                            ((int32_t *) mem_30183)[lvl_29089] = 1;
                            loopres_t_res_29112 = child_idx_29122;
                            loopres_t_res_29113 = ridx_29087;
                            loopres_t_res_29114 = lvl_29088;
                        } else {
                            int32_t lifted_unpack_arg_29124;
                            
                            lifted_unpack_arg_29124 =
                                ((int32_t *) mem_29877)[ridx_29102];
                            
                            int32_t lvl_29125 = add32(1, lvl_29088);
                            int64_t lvl_29126 = sext_i32_i64(lvl_29125);
                            bool x_29127 = sle64((int64_t) 0, lvl_29126);
                            bool y_29128 = slt64(lvl_29126, (int64_t) 3);
                            bool bounds_check_29129 = x_29127 && y_29128;
                            bool index_certs_29130;
                            
                            if (!bounds_check_29129) {
                                ctx->error =
                                    msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                              "Index [", (long long) lvl_29126,
                                              "] out of bounds for array of shape [",
                                              (long long) (int64_t) 3, "].",
                                              "-> #0  sample_programs/octree.fut:141:26-142:65\n   #1  /prelude/soacs.fut:67:19-23\n   #2  /prelude/soacs.fut:67:3-37\n   #3  sample_programs/octree.fut:48:5-163:28\n   #4  sample_programs/octree.fut:201:16-38\n   #5  sample_programs/nbody.fut:62:5-25\n   #6  sample_programs/nbody.fut:69:26-57\n   #7  sample_programs/nbody.fut:75:5-49\n   #8  sample_programs/nbody.fut:102:17-75\n   #9  sample_programs/nbody.fut:89:1-106:46\n");
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            ((int32_t *) mem_30183)[lvl_29126] = 2;
                            loopres_t_res_29112 = child_idx_29086;
                            loopres_t_res_29113 = lifted_unpack_arg_29124;
                            loopres_t_res_29114 = lvl_29125;
                        }
                        loopres_29099 = loopres_t_res_29112;
                        loopres_29100 = loopres_t_res_29113;
                        loopres_29101 = loopres_t_res_29114;
                    } else {
                        bool cond_29132 = x_29095 == 1;
                        int32_t loopres_f_res_29135;
                        int32_t loopres_f_res_29136;
                        int32_t loopres_f_res_29137;
                        
                        if (cond_29132) {
                            int64_t ridx_29138 = sext_i32_i64(ridx_29087);
                            bool x_29139 = sle64((int64_t) 0, ridx_29138);
                            bool y_29140 = slt64(ridx_29138, i_27006);
                            bool bounds_check_29141 = x_29139 && y_29140;
                            bool index_certs_29142;
                            
                            if (!bounds_check_29141) {
                                ctx->error =
                                    msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                              "Index [", (long long) ridx_29138,
                                              "] out of bounds for array of shape [",
                                              (long long) i_27006, "].",
                                              "-> #0  sample_programs/octree.fut:144:27-37\n   #1  /prelude/soacs.fut:67:19-23\n   #2  /prelude/soacs.fut:67:3-37\n   #3  sample_programs/octree.fut:48:5-163:28\n   #4  sample_programs/octree.fut:201:16-38\n   #5  sample_programs/nbody.fut:62:5-25\n   #6  sample_programs/nbody.fut:69:26-57\n   #7  sample_programs/nbody.fut:75:5-49\n   #8  sample_programs/nbody.fut:102:17-75\n   #9  sample_programs/nbody.fut:89:1-106:46\n");
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int32_t x_29143;
                            
                            x_29143 = ((int32_t *) mem_30011)[ridx_29138];
                            
                            bool cond_29144 = x_29143 == 0;
                            bool cond_29145 = !cond_29144;
                            int32_t loopres_f_res_t_res_29148;
                            int32_t loopres_f_res_t_res_29149;
                            int32_t loopres_f_res_t_res_29150;
                            
                            if (cond_29145) {
                                int32_t start_29151;
                                
                                start_29151 =
                                    ((int32_t *) mem_30050)[ridx_29138];
                                
                                int32_t x_29152;
                                
                                x_29152 = ((int32_t *) mem_30008)[ridx_29138];
                                
                                bool bool_arg_29153 = slt32(0, x_29152);
                                int32_t bool_res_29154 =
                                        btoi_bool_i32(bool_arg_29153);
                                int32_t lw_val_29155 = add32(start_29151,
                                                             bool_res_29154);
                                int64_t child_idx_29156 =
                                        sext_i32_i64(child_idx_29086);
                                bool x_29157 = sle64((int64_t) 0,
                                                     child_idx_29156);
                                bool y_29158 = slt64(child_idx_29156,
                                                     (int64_t) 8);
                                bool bounds_check_29159 = x_29157 && y_29158;
                                bool index_certs_29160;
                                
                                if (!bounds_check_29159) {
                                    ctx->error =
                                        msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                                  "Index [",
                                                  (long long) child_idx_29156,
                                                  "] out of bounds for array of shape [",
                                                  (long long) (int64_t) 8, "].",
                                                  "-> #0  sample_programs/octree.fut:146:26-150:65\n   #1  /prelude/soacs.fut:67:19-23\n   #2  /prelude/soacs.fut:67:3-37\n   #3  sample_programs/octree.fut:48:5-163:28\n   #4  sample_programs/octree.fut:201:16-38\n   #5  sample_programs/nbody.fut:62:5-25\n   #6  sample_programs/nbody.fut:69:26-57\n   #7  sample_programs/nbody.fut:75:5-49\n   #8  sample_programs/nbody.fut:102:17-75\n   #9  sample_programs/nbody.fut:89:1-106:46\n");
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                ((int32_t *) mem_30181)[child_idx_29156] =
                                    lw_val_29155;
                                
                                int32_t child_idx_29162 = add32(1,
                                                                child_idx_29086);
                                
                                ((int32_t *) mem_30183)[lvl_29089] = 0;
                                loopres_f_res_t_res_29148 = child_idx_29162;
                                loopres_f_res_t_res_29149 = ridx_29087;
                                loopres_f_res_t_res_29150 = lvl_29088;
                            } else {
                                int32_t lifted_unpack_arg_29164;
                                
                                lifted_unpack_arg_29164 =
                                    ((int32_t *) mem_29882)[ridx_29138];
                                
                                int32_t lvl_29165 = add32(1, lvl_29088);
                                int64_t lvl_29166 = sext_i32_i64(lvl_29165);
                                bool x_29167 = sle64((int64_t) 0, lvl_29166);
                                bool y_29168 = slt64(lvl_29166, (int64_t) 3);
                                bool bounds_check_29169 = x_29167 && y_29168;
                                bool index_certs_29170;
                                
                                if (!bounds_check_29169) {
                                    ctx->error =
                                        msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                                  "Index [",
                                                  (long long) lvl_29166,
                                                  "] out of bounds for array of shape [",
                                                  (long long) (int64_t) 3, "].",
                                                  "-> #0  sample_programs/octree.fut:154:26-155:65\n   #1  /prelude/soacs.fut:67:19-23\n   #2  /prelude/soacs.fut:67:3-37\n   #3  sample_programs/octree.fut:48:5-163:28\n   #4  sample_programs/octree.fut:201:16-38\n   #5  sample_programs/nbody.fut:62:5-25\n   #6  sample_programs/nbody.fut:69:26-57\n   #7  sample_programs/nbody.fut:75:5-49\n   #8  sample_programs/nbody.fut:102:17-75\n   #9  sample_programs/nbody.fut:89:1-106:46\n");
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                ((int32_t *) mem_30183)[lvl_29166] = 2;
                                loopres_f_res_t_res_29148 = child_idx_29086;
                                loopres_f_res_t_res_29149 =
                                    lifted_unpack_arg_29164;
                                loopres_f_res_t_res_29150 = lvl_29165;
                            }
                            loopres_f_res_29135 = loopres_f_res_t_res_29148;
                            loopres_f_res_29136 = loopres_f_res_t_res_29149;
                            loopres_f_res_29137 = loopres_f_res_t_res_29150;
                        } else {
                            int64_t ridx_29172 = sext_i32_i64(ridx_29087);
                            bool x_29173 = sle64((int64_t) 0, ridx_29172);
                            bool y_29174 = slt64(ridx_29172, i_27006);
                            bool bounds_check_29175 = x_29173 && y_29174;
                            bool index_certs_29176;
                            
                            if (!bounds_check_29175) {
                                ctx->error =
                                    msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                              "Index [", (long long) ridx_29172,
                                              "] out of bounds for array of shape [",
                                              (long long) i_27006, "].",
                                              "-> #0  sample_programs/octree.fut:157:35-46\n   #1  /prelude/soacs.fut:67:19-23\n   #2  /prelude/soacs.fut:67:3-37\n   #3  sample_programs/octree.fut:48:5-163:28\n   #4  sample_programs/octree.fut:201:16-38\n   #5  sample_programs/nbody.fut:62:5-25\n   #6  sample_programs/nbody.fut:69:26-57\n   #7  sample_programs/nbody.fut:75:5-49\n   #8  sample_programs/nbody.fut:102:17-75\n   #9  sample_programs/nbody.fut:89:1-106:46\n");
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int32_t ridx_29177;
                            
                            ridx_29177 = ((int32_t *) mem_29990)[ridx_29172];
                            
                            int32_t lvl_29178 = sub32(lvl_29088, 1);
                            int64_t lvl_29179 = sext_i32_i64(lvl_29178);
                            bool x_29180 = sle64((int64_t) 0, lvl_29179);
                            bool y_29181 = slt64(lvl_29179, (int64_t) 3);
                            bool bounds_check_29182 = x_29180 && y_29181;
                            bool index_certs_29183;
                            
                            if (!bounds_check_29182) {
                                ctx->error =
                                    msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                              "Index [", (long long) lvl_29179,
                                              "] out of bounds for array of shape [",
                                              (long long) (int64_t) 3, "].",
                                              "-> #0  sample_programs/octree.fut:159:44-56\n   #1  /prelude/soacs.fut:67:19-23\n   #2  /prelude/soacs.fut:67:3-37\n   #3  sample_programs/octree.fut:48:5-163:28\n   #4  sample_programs/octree.fut:201:16-38\n   #5  sample_programs/nbody.fut:62:5-25\n   #6  sample_programs/nbody.fut:69:26-57\n   #7  sample_programs/nbody.fut:75:5-49\n   #8  sample_programs/nbody.fut:102:17-75\n   #9  sample_programs/nbody.fut:89:1-106:46\n");
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int32_t x_29185;
                            
                            x_29185 = ((int32_t *) mem_30183)[lvl_29179];
                            
                            int32_t lw_val_29186 = sub32(x_29185, 1);
                            
                            ((int32_t *) mem_30183)[lvl_29179] = lw_val_29186;
                            loopres_f_res_29135 = child_idx_29086;
                            loopres_f_res_29136 = ridx_29177;
                            loopres_f_res_29137 = lvl_29178;
                        }
                        loopres_29099 = loopres_f_res_29135;
                        loopres_29100 = loopres_f_res_29136;
                        loopres_29101 = loopres_f_res_29137;
                    }
                    
                    int32_t x_29188;
                    
                    x_29188 = ((int32_t *) mem_30183)[(int64_t) 0];
                    
                    bool loop_cond_29189 = slt32(0, x_29188);
                    bool loop_while_tmp_30726 = loop_cond_29189;
                    int32_t child_idx_tmp_30729 = loopres_29099;
                    int32_t ridx_tmp_30730 = loopres_29100;
                    int32_t lvl_tmp_30731 = loopres_29101;
                    
                    loop_while_29083 = loop_while_tmp_30726;
                    child_idx_29086 = child_idx_tmp_30729;
                    ridx_29087 = ridx_tmp_30730;
                    lvl_29088 = lvl_tmp_30731;
                }
                arrzq_29077 = loop_while_29083;
                arrzq_29080 = child_idx_29086;
                arrzq_29081 = ridx_29087;
                arrzq_29082 = lvl_29088;
            }
            ((float *) mem_30096.mem)[i_29484] = defunc_1_f_res_27424;
            ((float *) mem_30099.mem)[i_29484] = defunc_1_f_res_27425;
            ((float *) mem_30102.mem)[i_29484] = defunc_1_f_res_27426;
            ((float *) mem_30105.mem)[i_29484] = defunc_1_f_res_27427;
            if ((int64_t) 32 > 0)
                memmove(mem_30109.mem + i_29484 * (int64_t) 8 * (int64_t) 4,
                        mem_30181 + (int64_t) 0, (int64_t) 32);
            ((bool *) mem_30111.mem)[i_29484] = x_27423;
            ((int32_t *) mem_30114.mem)[i_29484] = parent_27440;
            ((int32_t *) mem_30117.mem)[i_29484] = tree_level_27412;
        }
        
        int32_t root_leaf_delta_27593 = sub32(66, root_delta_27331);
        int32_t x_27594 = add32(3, root_leaf_delta_27593);
        int32_t x_27595 = sub32(x_27594, 1);
        int32_t lvl_27596 = sdiv32(x_27595, 3);
        int32_t range_second_27597 = sub32(lvl_27596, 1);
        int64_t lvl_27598 = sext_i32_i64(lvl_27596);
        int64_t range_second_27599 = sext_i32_i64(range_second_27597);
        int32_t subtracted_step_27600 = sub32(range_second_27597, lvl_27596);
        bool step_zzero_27601 = lvl_27596 == range_second_27597;
        int32_t s_sign_27602 = (subtracted_step_27600 > 0) -
                (subtracted_step_27600 < 0);
        int64_t s_sign_27603 = sext_i32_i64(s_sign_27602);
        bool bounds_invalid_downwards_27604 = sle32(lvl_27596, 0);
        bool bounds_invalid_upwards_27605 = slt32(0, lvl_27596);
        bool downwards_27606 = s_sign_27602 == -1;
        int32_t distance_exclusive_27612;
        
        if (downwards_27606) {
            distance_exclusive_27612 = lvl_27596;
        } else {
            int32_t distance_upwards_exclusive_29190 = sub32(0, lvl_27596);
            
            distance_exclusive_27612 = distance_upwards_exclusive_29190;
        }
        
        bool x_27608 = bounds_invalid_downwards_27604 && downwards_27606;
        bool x_27609 = !downwards_27606;
        bool y_27610 = bounds_invalid_upwards_27605 && x_27609;
        bool bounds_invalid_27611 = x_27608 || y_27610;
        int64_t distance_exclusive_27613 =
                sext_i32_i64(distance_exclusive_27612);
        int64_t distance_27614 = add64((int64_t) 1, distance_exclusive_27613);
        bool range_invalid_27615 = step_zzero_27601 || bounds_invalid_27611;
        bool valid_27616 = !range_invalid_27615;
        bool range_valid_c_27617;
        
        if (!valid_27616) {
            ctx->error =
                msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s",
                          "Range ", (long long) lvl_27598, "..",
                          (long long) range_second_27599, "...",
                          (long long) (int64_t) 0, " is invalid.",
                          "-> #0  sample_programs/octree.fut:206:30-47\n   #1  sample_programs/nbody.fut:62:5-25\n   #2  sample_programs/nbody.fut:69:26-57\n   #3  sample_programs/nbody.fut:75:5-49\n   #4  sample_programs/nbody.fut:102:17-75\n   #5  sample_programs/nbody.fut:89:1-106:46\n");
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t subtracted_step_27618 = sext_i32_i64(subtracted_step_27600);
        int64_t pos_step_27619 = mul64(s_sign_27603, subtracted_step_27618);
        int64_t num_elems_27620 = sdiv_up64(distance_27614, pos_step_27619);
        
        if (memblock_set(ctx, &mem_param_30272, &mem_30096, "mem_30096") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_30277, &mem_30099, "mem_30099") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_30282, &mem_30102, "mem_30102") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_30287, &mem_30105, "mem_30105") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_30295, &mem_30109, "mem_30109") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_30300, &mem_30111, "mem_30111") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_30305, &mem_30114, "mem_30114") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_30310, &mem_30117, "mem_30117") != 0)
            return 1;
        for (int64_t i_27629 = 0; i_27629 < num_elems_27620; i_27629++) {
            int32_t binop_x_27638 = sext_i64_i32(i_27629);
            int32_t binop_x_27639 = mul32(subtracted_step_27600, binop_x_27638);
            int32_t index_primexp_27640 = add32(lvl_27596, binop_x_27639);
            
            if (memblock_alloc(ctx, &mem_30312, bytes_30110, "mem_30312")) {
                err = 1;
                goto cleanup;
            }
            if (sizze_27358 > 0)
                memmove(mem_30312.mem + (int64_t) 0, mem_param_30300.mem +
                        (int64_t) 0, sizze_27358);
            if (memblock_alloc(ctx, &mem_30315, bytes_30064, "mem_30315")) {
                err = 1;
                goto cleanup;
            }
            if (sizze_27358 * (int64_t) 4 > 0)
                memmove(mem_30315.mem + (int64_t) 0, mem_param_30305.mem +
                        (int64_t) 0, sizze_27358 * (int64_t) 4);
            if (memblock_alloc(ctx, &mem_30318, bytes_30064, "mem_30318")) {
                err = 1;
                goto cleanup;
            }
            if (sizze_27358 * (int64_t) 4 > 0)
                memmove(mem_30318.mem + (int64_t) 0, mem_param_30310.mem +
                        (int64_t) 0, sizze_27358 * (int64_t) 4);
            if (memblock_alloc(ctx, &mem_30322, bytes_30108, "mem_30322")) {
                err = 1;
                goto cleanup;
            }
            if (sizze_27358 * (int64_t) 8 * (int64_t) 4 > 0)
                memmove(mem_30322.mem + (int64_t) 0, mem_param_30295.mem +
                        (int64_t) 0, sizze_27358 * (int64_t) 8 * (int64_t) 4);
            if (memblock_alloc(ctx, &mem_30325, bytes_30064, "mem_30325")) {
                err = 1;
                goto cleanup;
            }
            if (memblock_alloc(ctx, &mem_30328, bytes_30064, "mem_30328")) {
                err = 1;
                goto cleanup;
            }
            if (memblock_alloc(ctx, &mem_30331, bytes_30064, "mem_30331")) {
                err = 1;
                goto cleanup;
            }
            if (memblock_alloc(ctx, &mem_30334, bytes_30064, "mem_30334")) {
                err = 1;
                goto cleanup;
            }
            for (int64_t i_29501 = 0; i_29501 < sizze_27358; i_29501++) {
                float x_27649;
                
                x_27649 = ((float *) mem_param_30272.mem)[i_29501];
                
                float x_27650;
                
                x_27650 = ((float *) mem_param_30277.mem)[i_29501];
                
                float x_27651;
                
                x_27651 = ((float *) mem_param_30282.mem)[i_29501];
                
                float x_27652;
                
                x_27652 = ((float *) mem_param_30287.mem)[i_29501];
                
                int32_t x_27654;
                
                x_27654 = ((int32_t *) mem_param_30310.mem)[i_29501];
                
                bool cond_27655 = x_27654 == index_primexp_27640;
                bool cond_27656 = !cond_27655;
                float defunc_0_f_res_27657;
                float defunc_0_f_res_27658;
                float defunc_0_f_res_27659;
                float defunc_0_f_res_27660;
                
                if (cond_27656) {
                    defunc_0_f_res_27657 = x_27649;
                    defunc_0_f_res_27658 = x_27650;
                    defunc_0_f_res_27659 = x_27651;
                    defunc_0_f_res_27660 = x_27652;
                } else {
                    int32_t x_29191;
                    
                    x_29191 = ((int32_t *) mem_param_30295.mem)[i_29501 *
                                                                (int64_t) 8];
                    
                    bool loop_cond_t_res_29192 = x_29191 == -1;
                    bool loop_cond_t_res_29193 = !loop_cond_t_res_29192;
                    bool defunc_0_f_res_f_res_29194;
                    float defunc_0_f_res_f_res_29195;
                    float defunc_0_f_res_f_res_29196;
                    float defunc_0_f_res_f_res_29197;
                    float defunc_0_f_res_f_res_29198;
                    int32_t defunc_0_f_res_f_res_29199;
                    bool loop_while_29200;
                    float b_29201;
                    float b_29202;
                    float b_29203;
                    float b_29204;
                    int32_t j_29205;
                    
                    loop_while_29200 = loop_cond_t_res_29193;
                    b_29201 = x_27649;
                    b_29202 = x_27650;
                    b_29203 = x_27651;
                    b_29204 = x_27652;
                    j_29205 = 0;
                    while (loop_while_29200) {
                        int64_t j_29206 = sext_i32_i64(j_29205);
                        bool x_29207 = sle64((int64_t) 0, j_29206);
                        bool y_29208 = slt64(j_29206, (int64_t) 8);
                        bool bounds_check_29209 = x_29207 && y_29208;
                        bool index_certs_29210;
                        
                        if (!bounds_check_29209) {
                            ctx->error =
                                msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                          "Index [", (long long) j_29206,
                                          "] out of bounds for array of shape [",
                                          (long long) (int64_t) 8, "].",
                                          "-> #0  sample_programs/octree.fut:214:37-49\n   #1  sample_programs/octree.fut:207:10-222:46\n   #2  sample_programs/nbody.fut:62:5-25\n   #3  sample_programs/nbody.fut:69:26-57\n   #4  sample_programs/nbody.fut:75:5-49\n   #5  sample_programs/nbody.fut:102:17-75\n   #6  sample_programs/nbody.fut:89:1-106:46\n");
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int32_t i_29211;
                        
                        i_29211 = ((int32_t *) mem_param_30295.mem)[i_29501 *
                                                                    (int64_t) 8 +
                                                                    j_29206];
                        
                        int64_t i_29212 = sext_i32_i64(i_29211);
                        bool x_29213 = sle64((int64_t) 0, i_29212);
                        bool y_29214 = slt64(i_29212, sizze_27358);
                        bool bounds_check_29215 = x_29213 && y_29214;
                        bool index_certs_29216;
                        
                        if (!bounds_check_29215) {
                            ctx->error =
                                msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                          "Index [", (long long) i_29212,
                                          "] out of bounds for array of shape [",
                                          (long long) sizze_27358, "].",
                                          "-> #0  sample_programs/octree.fut:214:30-50\n   #1  sample_programs/octree.fut:207:10-222:46\n   #2  sample_programs/nbody.fut:62:5-25\n   #3  sample_programs/nbody.fut:69:26-57\n   #4  sample_programs/nbody.fut:75:5-49\n   #5  sample_programs/nbody.fut:102:17-75\n   #6  sample_programs/nbody.fut:89:1-106:46\n");
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        float loopres_29217;
                        
                        loopres_29217 =
                            ((float *) mem_param_30272.mem)[i_29212];
                        
                        float loopres_29218;
                        
                        loopres_29218 =
                            ((float *) mem_param_30277.mem)[i_29212];
                        
                        float loopres_29219;
                        
                        loopres_29219 =
                            ((float *) mem_param_30282.mem)[i_29212];
                        
                        float loopres_29220;
                        
                        loopres_29220 =
                            ((float *) mem_param_30287.mem)[i_29212];
                        
                        float defunc_1_f_res_29221 = b_29202 + loopres_29218;
                        float defunc_1_f_res_29222 = b_29203 + loopres_29219;
                        float defunc_1_f_res_29223 = b_29204 + loopres_29220;
                        float masszq_29224 = b_29201 + loopres_29217;
                        int32_t loopres_29225 = add32(1, j_29205);
                        bool cond_29226 = slt32(loopres_29225, 8);
                        bool loop_cond_29227;
                        
                        if (cond_29226) {
                            int64_t j_29228 = sext_i32_i64(loopres_29225);
                            bool x_29229 = sle64((int64_t) 0, j_29228);
                            bool y_29230 = slt64(j_29228, (int64_t) 8);
                            bool bounds_check_29231 = x_29229 && y_29230;
                            bool index_certs_29232;
                            
                            if (!bounds_check_29231) {
                                ctx->error =
                                    msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                              "Index [", (long long) j_29228,
                                              "] out of bounds for array of shape [",
                                              (long long) (int64_t) 8, "].",
                                              "-> #0  sample_programs/octree.fut:213:46-58\n   #1  sample_programs/octree.fut:207:10-222:46\n   #2  sample_programs/nbody.fut:62:5-25\n   #3  sample_programs/nbody.fut:69:26-57\n   #4  sample_programs/nbody.fut:75:5-49\n   #5  sample_programs/nbody.fut:102:17-75\n   #6  sample_programs/nbody.fut:89:1-106:46\n");
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int32_t x_29233;
                            
                            x_29233 =
                                ((int32_t *) mem_param_30295.mem)[i_29501 *
                                                                  (int64_t) 8 +
                                                                  j_29228];
                            
                            bool loop_cond_t_res_29234 = x_29233 == -1;
                            bool loop_cond_t_res_29235 = !loop_cond_t_res_29234;
                            
                            loop_cond_29227 = loop_cond_t_res_29235;
                        } else {
                            loop_cond_29227 = 0;
                        }
                        
                        bool loop_while_tmp_30752 = loop_cond_29227;
                        float b_tmp_30753 = masszq_29224;
                        float b_tmp_30754 = defunc_1_f_res_29221;
                        float b_tmp_30755 = defunc_1_f_res_29222;
                        float b_tmp_30756 = defunc_1_f_res_29223;
                        int32_t j_tmp_30757 = loopres_29225;
                        
                        loop_while_29200 = loop_while_tmp_30752;
                        b_29201 = b_tmp_30753;
                        b_29202 = b_tmp_30754;
                        b_29203 = b_tmp_30755;
                        b_29204 = b_tmp_30756;
                        j_29205 = j_tmp_30757;
                    }
                    defunc_0_f_res_f_res_29194 = loop_while_29200;
                    defunc_0_f_res_f_res_29195 = b_29201;
                    defunc_0_f_res_f_res_29196 = b_29202;
                    defunc_0_f_res_f_res_29197 = b_29203;
                    defunc_0_f_res_f_res_29198 = b_29204;
                    defunc_0_f_res_f_res_29199 = j_29205;
                    defunc_0_f_res_27657 = defunc_0_f_res_f_res_29195;
                    defunc_0_f_res_27658 = defunc_0_f_res_f_res_29196;
                    defunc_0_f_res_27659 = defunc_0_f_res_f_res_29197;
                    defunc_0_f_res_27660 = defunc_0_f_res_f_res_29198;
                }
                ((float *) mem_30325.mem)[i_29501] = defunc_0_f_res_27657;
                ((float *) mem_30328.mem)[i_29501] = defunc_0_f_res_27658;
                ((float *) mem_30331.mem)[i_29501] = defunc_0_f_res_27659;
                ((float *) mem_30334.mem)[i_29501] = defunc_0_f_res_27660;
            }
            if (memblock_set(ctx, &mem_param_tmp_30732, &mem_30325,
                             "mem_30325") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_30733, &mem_30328,
                             "mem_30328") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_30734, &mem_30331,
                             "mem_30331") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_30735, &mem_30334,
                             "mem_30334") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_30736, &mem_30322,
                             "mem_30322") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_30737, &mem_30312,
                             "mem_30312") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_30738, &mem_30315,
                             "mem_30315") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_30739, &mem_30318,
                             "mem_30318") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_30272, &mem_param_tmp_30732,
                             "mem_param_tmp_30732") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_30277, &mem_param_tmp_30733,
                             "mem_param_tmp_30733") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_30282, &mem_param_tmp_30734,
                             "mem_param_tmp_30734") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_30287, &mem_param_tmp_30735,
                             "mem_param_tmp_30735") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_30295, &mem_param_tmp_30736,
                             "mem_param_tmp_30736") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_30300, &mem_param_tmp_30737,
                             "mem_param_tmp_30737") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_30305, &mem_param_tmp_30738,
                             "mem_param_tmp_30738") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_30310, &mem_param_tmp_30739,
                             "mem_param_tmp_30739") != 0)
                return 1;
        }
        if (memblock_set(ctx, &ext_mem_30401, &mem_param_30272,
                         "mem_param_30272") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_30400, &mem_param_30277,
                         "mem_param_30277") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_30399, &mem_param_30282,
                         "mem_param_30282") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_30398, &mem_param_30287,
                         "mem_param_30287") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_30397, &mem_param_30295,
                         "mem_param_30295") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_30396, &mem_param_30300,
                         "mem_param_30300") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_30395, &mem_param_30305,
                         "mem_param_30305") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_30394, &mem_param_30310,
                         "mem_param_30310") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_30096, "mem_30096") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_30099, "mem_30099") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_30102, "mem_30102") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_30105, "mem_30105") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_30109, "mem_30109") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_30111, "mem_30111") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_30114, "mem_30114") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_30117, "mem_30117") != 0)
            return 1;
        ((float *) mem_30438)[(int64_t) 0] = y_27057;
        ((float *) mem_30438)[(int64_t) 1] = y_27058;
        ((float *) mem_30438)[(int64_t) 2] = y_27059;
        
        float defunc_2_reduce_res_28091;
        float redout_29506 = -INFINITY;
        
        for (int32_t i_29529 = 0; i_29529 < 3; i_29529++) {
            int64_t i_29507 = sext_i32_i64(i_29529);
            float x_28095;
            
            x_28095 = ((float *) mem_30438)[i_29507];
            
            float defunc_1_op_res_28094 = fmax32(x_28095, redout_29506);
            float redout_tmp_30758 = defunc_1_op_res_28094;
            
            redout_29506 = redout_tmp_30758;
        }
        defunc_2_reduce_res_28091 = redout_29506;
        if (memblock_alloc(ctx, &mem_30441, bytes_29609, "mem_30441")) {
            err = 1;
            goto cleanup;
        }
        if (memblock_alloc(ctx, &mem_30444, bytes_29609, "mem_30444")) {
            err = 1;
            goto cleanup;
        }
        if (memblock_alloc(ctx, &mem_30447, bytes_29609, "mem_30447")) {
            err = 1;
            goto cleanup;
        }
        if (memblock_alloc(ctx, &mem_30450, bytes_29609, "mem_30450")) {
            err = 1;
            goto cleanup;
        }
        if (memblock_alloc(ctx, &mem_30453, bytes_29609, "mem_30453")) {
            err = 1;
            goto cleanup;
        }
        if (memblock_alloc(ctx, &mem_30456, bytes_29609, "mem_30456")) {
            err = 1;
            goto cleanup;
        }
        for (int64_t i_29522 = 0; i_29522 < n_21239; i_29522++) {
            float x_27863;
            
            x_27863 = ((float *) mem_29755)[i_29522];
            
            float x_27864;
            
            x_27864 = ((float *) mem_29758)[i_29522];
            
            float x_27865;
            
            x_27865 = ((float *) mem_29761)[i_29522];
            
            float x_27866;
            
            x_27866 = ((float *) mem_29764)[i_29522];
            
            float x_27867;
            
            x_27867 = ((float *) mem_29767)[i_29522];
            
            float x_27868;
            
            x_27868 = ((float *) mem_29770)[i_29522];
            
            bool defunc_0_f_res_27714;
            float defunc_0_f_res_27715;
            float defunc_0_f_res_27716;
            float defunc_0_f_res_27717;
            int32_t defunc_0_f_res_27718;
            int32_t defunc_0_f_res_27719;
            int32_t defunc_0_f_res_27720;
            bool loop_while_27721;
            float acc_27722;
            float acc_27723;
            float acc_27724;
            int32_t cur_27725;
            int32_t prev_27726;
            int32_t to_check_27727;
            
            loop_while_27721 = 1;
            acc_27722 = 0.0F;
            acc_27723 = 0.0F;
            acc_27724 = 0.0F;
            cur_27725 = 0;
            prev_27726 = -1;
            to_check_27727 = 1;
            while (loop_while_27721) {
                bool cond_27728 = prev_27726 == -1;
                bool cond_27729 = !cond_27728;
                bool from_child_27730;
                
                if (cond_27729) {
                    int64_t prev_27731 = sext_i32_i64(prev_27726);
                    bool x_27732 = sle64((int64_t) 0, prev_27731);
                    bool y_27733 = slt64(prev_27731, sizze_27358);
                    bool bounds_check_27734 = x_27732 && y_27733;
                    bool index_certs_27735;
                    
                    if (!bounds_check_27734) {
                        ctx->error =
                            msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                      "Index [", (long long) prev_27731,
                                      "] out of bounds for array of shape [",
                                      (long long) sizze_27358, "].",
                                      "-> #0  sample_programs/nbody.fut:21:36-42\n   #1  sample_programs/nbody.fut:63:7-64:39\n   #2  sample_programs/nbody.fut:69:26-57\n   #3  sample_programs/nbody.fut:75:5-49\n   #4  sample_programs/nbody.fut:102:17-75\n   #5  sample_programs/nbody.fut:89:1-106:46\n");
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int32_t x_27736;
                    
                    x_27736 = ((int32_t *) ext_mem_30395.mem)[prev_27731];
                    
                    bool from_child_t_res_27737 = x_27736 == cur_27725;
                    
                    from_child_27730 = from_child_t_res_27737;
                } else {
                    from_child_27730 = 0;
                }
                
                int64_t cur_27738 = sext_i32_i64(cur_27725);
                bool x_27739 = sle64((int64_t) 0, cur_27738);
                bool y_27740 = slt64(cur_27738, sizze_27358);
                bool bounds_check_27741 = x_27739 && y_27740;
                bool index_certs_27742;
                
                if (!bounds_check_27741) {
                    ctx->error =
                        msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                  "Index [", (long long) cur_27738,
                                  "] out of bounds for array of shape [",
                                  (long long) sizze_27358, "].",
                                  "-> #0  sample_programs/nbody.fut:22:19-24\n   #1  sample_programs/nbody.fut:63:7-64:39\n   #2  sample_programs/nbody.fut:69:26-57\n   #3  sample_programs/nbody.fut:75:5-49\n   #4  sample_programs/nbody.fut:102:17-75\n   #5  sample_programs/nbody.fut:89:1-106:46\n");
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                float loopres_27743;
                
                loopres_27743 = ((float *) ext_mem_30401.mem)[cur_27738];
                
                float loopres_27744;
                
                loopres_27744 = ((float *) ext_mem_30400.mem)[cur_27738];
                
                float loopres_27745;
                
                loopres_27745 = ((float *) ext_mem_30399.mem)[cur_27738];
                
                float loopres_27746;
                
                loopres_27746 = ((float *) ext_mem_30398.mem)[cur_27738];
                
                bool loopres_27748;
                
                loopres_27748 = ((bool *) ext_mem_30396.mem)[cur_27738];
                
                int32_t loopres_27750;
                
                loopres_27750 = ((int32_t *) ext_mem_30394.mem)[cur_27738];
                
                float loopres_27751;
                float loopres_27752;
                float loopres_27753;
                int32_t loopres_27754;
                int32_t loopres_27755;
                
                if (from_child_27730) {
                    int32_t x_27756;
                    
                    x_27756 = ((int32_t *) ext_mem_30397.mem)[cur_27738 *
                                                              (int64_t) 8];
                    
                    bool loop_cond_27757 = x_27756 == prev_27726;
                    bool loop_cond_27758 = !loop_cond_27757;
                    bool j_27759;
                    int32_t j_27760;
                    bool loop_while_27761;
                    int32_t i_27762;
                    
                    loop_while_27761 = loop_cond_27758;
                    i_27762 = 0;
                    while (loop_while_27761) {
                        int32_t loopres_27763 = add32(1, i_27762);
                        int64_t i_27764 = sext_i32_i64(loopres_27763);
                        bool x_27765 = sle64((int64_t) 0, i_27764);
                        bool y_27766 = slt64(i_27764, (int64_t) 8);
                        bool bounds_check_27767 = x_27765 && y_27766;
                        bool index_certs_27768;
                        
                        if (!bounds_check_27767) {
                            ctx->error =
                                msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                          "Index [", (long long) i_27764,
                                          "] out of bounds for array of shape [",
                                          (long long) (int64_t) 8, "].",
                                          "-> #0  sample_programs/nbody.fut:26:32-52\n   #1  sample_programs/nbody.fut:63:7-64:39\n   #2  sample_programs/nbody.fut:69:26-57\n   #3  sample_programs/nbody.fut:75:5-49\n   #4  sample_programs/nbody.fut:102:17-75\n   #5  sample_programs/nbody.fut:89:1-106:46\n");
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int32_t x_27769;
                        
                        x_27769 = ((int32_t *) ext_mem_30397.mem)[cur_27738 *
                                                                  (int64_t) 8 +
                                                                  i_27764];
                        
                        bool loop_cond_27770 = x_27769 == prev_27726;
                        bool loop_cond_27771 = !loop_cond_27770;
                        bool loop_while_tmp_30772 = loop_cond_27771;
                        int32_t i_tmp_30773 = loopres_27763;
                        
                        loop_while_27761 = loop_while_tmp_30772;
                        i_27762 = i_tmp_30773;
                    }
                    j_27759 = loop_while_27761;
                    j_27760 = i_27762;
                    
                    bool cond_27772 = j_27760 == 7;
                    bool cond_27773;
                    
                    if (cond_27772) {
                        cond_27773 = 1;
                    } else {
                        int32_t i_29236 = add32(1, j_27760);
                        int64_t i_29237 = sext_i32_i64(i_29236);
                        bool x_29238 = sle64((int64_t) 0, i_29237);
                        bool y_29239 = slt64(i_29237, (int64_t) 8);
                        bool bounds_check_29240 = x_29238 && y_29239;
                        bool index_certs_29241;
                        
                        if (!bounds_check_29240) {
                            ctx->error =
                                msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                          "Index [", (long long) i_29237,
                                          "] out of bounds for array of shape [",
                                          (long long) (int64_t) 8, "].",
                                          "-> #0  sample_programs/nbody.fut:29:23-47\n   #1  sample_programs/nbody.fut:63:7-64:39\n   #2  sample_programs/nbody.fut:69:26-57\n   #3  sample_programs/nbody.fut:75:5-49\n   #4  sample_programs/nbody.fut:102:17-75\n   #5  sample_programs/nbody.fut:89:1-106:46\n");
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int32_t x_29242;
                        
                        x_29242 = ((int32_t *) ext_mem_30397.mem)[cur_27738 *
                                                                  (int64_t) 8 +
                                                                  i_29237];
                        
                        bool cond_f_res_29243 = x_29242 == -1;
                        
                        cond_27773 = cond_f_res_29243;
                    }
                    
                    int32_t next_cur_27782;
                    
                    if (cond_27773) {
                        int32_t loopres_27749;
                        
                        loopres_27749 =
                            ((int32_t *) ext_mem_30395.mem)[cur_27738];
                        next_cur_27782 = loopres_27749;
                    } else {
                        int32_t i_29244 = add32(1, j_27760);
                        int64_t i_29245 = sext_i32_i64(i_29244);
                        bool x_29246 = sle64((int64_t) 0, i_29245);
                        bool y_29247 = slt64(i_29245, (int64_t) 8);
                        bool bounds_check_29248 = x_29246 && y_29247;
                        bool index_certs_29249;
                        
                        if (!bounds_check_29248) {
                            ctx->error =
                                msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                          "Index [", (long long) i_29245,
                                          "] out of bounds for array of shape [",
                                          (long long) (int64_t) 8, "].",
                                          "-> #0  sample_programs/nbody.fut:31:14-38\n   #1  sample_programs/nbody.fut:63:7-64:39\n   #2  sample_programs/nbody.fut:69:26-57\n   #3  sample_programs/nbody.fut:75:5-49\n   #4  sample_programs/nbody.fut:102:17-75\n   #5  sample_programs/nbody.fut:89:1-106:46\n");
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int32_t next_cur_f_res_29250;
                        
                        next_cur_f_res_29250 =
                            ((int32_t *) ext_mem_30397.mem)[cur_27738 *
                                                            (int64_t) 8 +
                                                            i_29245];
                        next_cur_27782 = next_cur_f_res_29250;
                    }
                    loopres_27751 = acc_27722;
                    loopres_27752 = acc_27723;
                    loopres_27753 = acc_27724;
                    loopres_27754 = next_cur_27782;
                    loopres_27755 = to_check_27727;
                } else {
                    bool nonnegative_29262 = sle32(0, loopres_27750);
                    bool nonzzero_cert_29263;
                    
                    if (!nonnegative_29262) {
                        ctx->error = msgprintf("Error: %s\n\nBacktrace:\n%s",
                                               "negative exponent",
                                               "-> #0  sample_programs/nbody.fut:35:35-58\n   #1  sample_programs/nbody.fut:63:7-64:39\n   #2  sample_programs/nbody.fut:69:26-57\n   #3  sample_programs/nbody.fut:75:5-49\n   #4  sample_programs/nbody.fut:102:17-75\n   #5  sample_programs/nbody.fut:89:1-106:46\n");
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int32_t i32_arg_29264 = shl32(1, loopres_27750);
                    float i32_res_29265 = sitofp_i32_f32(i32_arg_29264);
                    float s_29266 = defunc_2_reduce_res_28091 / i32_res_29265;
                    float scale_arg_29267 = 1.0F / loopres_27743;
                    float zt_res_29268 = loopres_27744 * scale_arg_29267;
                    float zt_res_29269 = loopres_27745 * scale_arg_29267;
                    float zt_res_29270 = loopres_27746 * scale_arg_29267;
                    float x_29271 = x_27863 - zt_res_29268;
                    float y_29272 = x_27864 - zt_res_29269;
                    float zz_29273 = x_27865 - zt_res_29270;
                    float x_29274 = x_29271 * x_29271;
                    float y_29275 = y_29272 * y_29272;
                    float x_29276 = x_29274 + y_29275;
                    float y_29277 = zz_29273 * zz_29273;
                    float inner_29278 = x_29276 + y_29277;
                    float sqrt_res_29279;
                    
                    sqrt_res_29279 = futrts_sqrt32(inner_29278);
                    
                    float local_theta_29280 = s_29266 / sqrt_res_29279;
                    int32_t x_29282 = add32(y_27381, loopres_27750);
                    bool overlapping_subtree_29283 = slt32(11, x_29282);
                    bool cond_29284 = loopres_27748 ||
                         overlapping_subtree_29283;
                    bool cond_f_res_29285 = local_theta_29280 < 0.5F;
                    bool x_29286 = !cond_29284;
                    bool y_29287 = cond_f_res_29285 && x_29286;
                    bool cond_29288 = cond_29284 || y_29287;
                    float loopres_f_res_29289;
                    float loopres_f_res_29290;
                    float loopres_f_res_29291;
                    int32_t loopres_f_res_29292;
                    int32_t loopres_f_res_29293;
                    
                    if (cond_29288) {
                        float defunc_1_f_res_29294 = zt_res_29268 - x_27863;
                        float defunc_1_f_res_29295 = zt_res_29269 - x_27864;
                        float defunc_1_f_res_29296 = zt_res_29270 - x_27865;
                        float zt_res_29297 = defunc_1_f_res_29296 *
                              defunc_1_f_res_29296;
                        float zt_res_29298 = defunc_1_f_res_29295 *
                              defunc_1_f_res_29295;
                        float zt_res_29299 = defunc_1_f_res_29294 *
                              defunc_1_f_res_29294;
                        float zp_res_29300 = zt_res_29298 + zt_res_29299;
                        float zp_res_29301 = zt_res_29297 + zp_res_29300;
                        float y_29302 = epsilon_21241 * epsilon_21241;
                        float rsqr_29303 = zp_res_29301 + y_29302;
                        float sqrt_res_29304;
                        
                        sqrt_res_29304 = futrts_sqrt32(rsqr_29303);
                        
                        float invr_29305 = 1.0F / sqrt_res_29304;
                        float x_29306 = invr_29305 * invr_29305;
                        float invr3_29307 = invr_29305 * x_29306;
                        float s_29308 = loopres_27743 * invr3_29307;
                        float zt_res_29309 = defunc_1_f_res_29294 * s_29308;
                        float zt_res_29310 = defunc_1_f_res_29295 * s_29308;
                        float zt_res_29311 = defunc_1_f_res_29296 * s_29308;
                        float defunc_1_f_res_29312 = acc_27722 + zt_res_29309;
                        float defunc_1_f_res_29313 = acc_27723 + zt_res_29310;
                        float defunc_1_f_res_29314 = acc_27724 + zt_res_29311;
                        int32_t loopres_f_res_t_res_29315 =
                                sub32(to_check_27727, 1);
                        int32_t loopres_29316;
                        
                        loopres_29316 =
                            ((int32_t *) ext_mem_30395.mem)[cur_27738];
                        loopres_f_res_29289 = defunc_1_f_res_29312;
                        loopres_f_res_29290 = defunc_1_f_res_29313;
                        loopres_f_res_29291 = defunc_1_f_res_29314;
                        loopres_f_res_29292 = loopres_29316;
                        loopres_f_res_29293 = loopres_f_res_t_res_29315;
                    } else {
                        int32_t defunc_0_f_res_29318;
                        int32_t redout_29508 = 0;
                        
                        for (int32_t i_29530 = 0; i_29530 < 8; i_29530++) {
                            int64_t i_29509 = sext_i32_i64(i_29530);
                            int32_t x_29322;
                            
                            x_29322 =
                                ((int32_t *) ext_mem_30397.mem)[cur_27738 *
                                                                (int64_t) 8 +
                                                                i_29509];
                            
                            bool defunc_0_f_res_29323 = sle32(0, x_29322);
                            int32_t defunc_0_g_res_29324 =
                                    btoi_bool_i32(defunc_0_f_res_29323);
                            int32_t defunc_1_op_res_29321 =
                                    add32(defunc_0_g_res_29324, redout_29508);
                            int32_t redout_tmp_30774 = defunc_1_op_res_29321;
                            
                            redout_29508 = redout_tmp_30774;
                        }
                        defunc_0_f_res_29318 = redout_29508;
                        
                        int32_t loopres_f_res_f_res_29325;
                        
                        loopres_f_res_f_res_29325 =
                            ((int32_t *) ext_mem_30397.mem)[cur_27738 *
                                                            (int64_t) 8];
                        
                        int32_t x_29326 = add32(to_check_27727,
                                                defunc_0_f_res_29318);
                        int32_t loopres_f_res_f_res_29327 = sub32(x_29326, 1);
                        
                        loopres_f_res_29289 = acc_27722;
                        loopres_f_res_29290 = acc_27723;
                        loopres_f_res_29291 = acc_27724;
                        loopres_f_res_29292 = loopres_f_res_f_res_29325;
                        loopres_f_res_29293 = loopres_f_res_f_res_29327;
                    }
                    loopres_27751 = loopres_f_res_29289;
                    loopres_27752 = loopres_f_res_29290;
                    loopres_27753 = loopres_f_res_29291;
                    loopres_27754 = loopres_f_res_29292;
                    loopres_27755 = loopres_f_res_29293;
                }
                
                bool loop_cond_27856 = slt32(0, loopres_27755);
                bool loop_while_tmp_30765 = loop_cond_27856;
                float acc_tmp_30766 = loopres_27751;
                float acc_tmp_30767 = loopres_27752;
                float acc_tmp_30768 = loopres_27753;
                int32_t cur_tmp_30769 = loopres_27754;
                int32_t prev_tmp_30770 = cur_27725;
                int32_t to_check_tmp_30771 = loopres_27755;
                
                loop_while_27721 = loop_while_tmp_30765;
                acc_27722 = acc_tmp_30766;
                acc_27723 = acc_tmp_30767;
                acc_27724 = acc_tmp_30768;
                cur_27725 = cur_tmp_30769;
                prev_27726 = prev_tmp_30770;
                to_check_27727 = to_check_tmp_30771;
            }
            defunc_0_f_res_27714 = loop_while_27721;
            defunc_0_f_res_27715 = acc_27722;
            defunc_0_f_res_27716 = acc_27723;
            defunc_0_f_res_27717 = acc_27724;
            defunc_0_f_res_27718 = cur_27725;
            defunc_0_f_res_27719 = prev_27726;
            defunc_0_f_res_27720 = to_check_27727;
            
            float zt_res_28123 = time_step_21242 * x_27866;
            float zt_res_28124 = time_step_21242 * x_27867;
            float zt_res_28125 = time_step_21242 * x_27868;
            float defunc_1_f_res_28132 = x_27863 + zt_res_28123;
            float defunc_1_f_res_28133 = x_27864 + zt_res_28124;
            float defunc_1_f_res_28134 = x_27865 + zt_res_28125;
            float zt_res_28139 = time_step_21242 * defunc_0_f_res_27715;
            float zt_res_28140 = time_step_21242 * defunc_0_f_res_27716;
            float zt_res_28141 = time_step_21242 * defunc_0_f_res_27717;
            float defunc_1_f_res_28148 = x_27866 + zt_res_28139;
            float defunc_1_f_res_28149 = x_27867 + zt_res_28140;
            float defunc_1_f_res_28150 = x_27868 + zt_res_28141;
            
            ((float *) mem_30441.mem)[i_29522] = defunc_1_f_res_28132;
            ((float *) mem_30444.mem)[i_29522] = defunc_1_f_res_28133;
            ((float *) mem_30447.mem)[i_29522] = defunc_1_f_res_28134;
            ((float *) mem_30450.mem)[i_29522] = defunc_1_f_res_28148;
            ((float *) mem_30453.mem)[i_29522] = defunc_1_f_res_28149;
            ((float *) mem_30456.mem)[i_29522] = defunc_1_f_res_28150;
        }
        if (memblock_unref(ctx, &ext_mem_30394, "ext_mem_30394") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_30395, "ext_mem_30395") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_30396, "ext_mem_30396") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_30397, "ext_mem_30397") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_30398, "ext_mem_30398") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_30399, "ext_mem_30399") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_30400, "ext_mem_30400") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_30401, "ext_mem_30401") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_30642, &mem_29752, "mem_29752") !=
            0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_30643, &mem_30441, "mem_30441") !=
            0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_30644, &mem_30444, "mem_30444") !=
            0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_30645, &mem_30447, "mem_30447") !=
            0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_30646, &mem_30450, "mem_30450") !=
            0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_30647, &mem_30453, "mem_30453") !=
            0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_30648, &mem_30456, "mem_30456") !=
            0)
            return 1;
        if (memblock_set(ctx, &mem_param_29563, &mem_param_tmp_30642,
                         "mem_param_tmp_30642") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_29568, &mem_param_tmp_30643,
                         "mem_param_tmp_30643") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_29573, &mem_param_tmp_30644,
                         "mem_param_tmp_30644") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_29578, &mem_param_tmp_30645,
                         "mem_param_tmp_30645") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_29583, &mem_param_tmp_30646,
                         "mem_param_tmp_30646") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_29588, &mem_param_tmp_30647,
                         "mem_param_tmp_30647") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_29593, &mem_param_tmp_30648,
                         "mem_param_tmp_30648") != 0)
            return 1;
    }
    if (memblock_set(ctx, &ext_mem_30535, &mem_param_29563,
                     "mem_param_29563") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_30534, &mem_param_29568,
                     "mem_param_29568") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_30533, &mem_param_29573,
                     "mem_param_29573") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_30532, &mem_param_29578,
                     "mem_param_29578") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_30531, &mem_param_29583,
                     "mem_param_29583") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_30530, &mem_param_29588,
                     "mem_param_29588") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_30529, &mem_param_29593,
                     "mem_param_29593") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_29558, "mem_29558") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_29610, "mem_29610") != 0)
        return 1;
    
    int64_t binop_y_30564 = (int64_t) 4 * n_21239;
    int64_t bytes_30565 = smax64((int64_t) 0, binop_y_30564);
    
    if (memblock_alloc(ctx, &mem_30566, bytes_30565, "mem_30566")) {
        err = 1;
        goto cleanup;
    }
    if (n_21239 * (int64_t) 4 > 0)
        memmove(mem_30566.mem + (int64_t) 0, ext_mem_30534.mem + (int64_t) 0,
                n_21239 * (int64_t) 4);
    if (memblock_unref(ctx, &ext_mem_30534, "ext_mem_30534") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_30570, bytes_30565, "mem_30570")) {
        err = 1;
        goto cleanup;
    }
    if (n_21239 * (int64_t) 4 > 0)
        memmove(mem_30570.mem + (int64_t) 0, ext_mem_30533.mem + (int64_t) 0,
                n_21239 * (int64_t) 4);
    if (memblock_unref(ctx, &ext_mem_30533, "ext_mem_30533") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_30574, bytes_30565, "mem_30574")) {
        err = 1;
        goto cleanup;
    }
    if (n_21239 * (int64_t) 4 > 0)
        memmove(mem_30574.mem + (int64_t) 0, ext_mem_30532.mem + (int64_t) 0,
                n_21239 * (int64_t) 4);
    if (memblock_unref(ctx, &ext_mem_30532, "ext_mem_30532") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_30578, bytes_30565, "mem_30578")) {
        err = 1;
        goto cleanup;
    }
    if (n_21239 * (int64_t) 4 > 0)
        memmove(mem_30578.mem + (int64_t) 0, ext_mem_30535.mem + (int64_t) 0,
                n_21239 * (int64_t) 4);
    if (memblock_unref(ctx, &ext_mem_30535, "ext_mem_30535") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_30582, bytes_30565, "mem_30582")) {
        err = 1;
        goto cleanup;
    }
    if (n_21239 * (int64_t) 4 > 0)
        memmove(mem_30582.mem + (int64_t) 0, ext_mem_30531.mem + (int64_t) 0,
                n_21239 * (int64_t) 4);
    if (memblock_unref(ctx, &ext_mem_30531, "ext_mem_30531") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_30586, bytes_30565, "mem_30586")) {
        err = 1;
        goto cleanup;
    }
    if (n_21239 * (int64_t) 4 > 0)
        memmove(mem_30586.mem + (int64_t) 0, ext_mem_30530.mem + (int64_t) 0,
                n_21239 * (int64_t) 4);
    if (memblock_unref(ctx, &ext_mem_30530, "ext_mem_30530") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_30590, bytes_30565, "mem_30590")) {
        err = 1;
        goto cleanup;
    }
    if (n_21239 * (int64_t) 4 > 0)
        memmove(mem_30590.mem + (int64_t) 0, ext_mem_30529.mem + (int64_t) 0,
                n_21239 * (int64_t) 4);
    if (memblock_unref(ctx, &ext_mem_30529, "ext_mem_30529") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_30633, &mem_30566, "mem_30566") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_30634, &mem_30570, "mem_30570") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_30635, &mem_30574, "mem_30574") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_30636, &mem_30578, "mem_30578") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_30637, &mem_30582, "mem_30582") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_30638, &mem_30586, "mem_30586") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_30639, &mem_30590, "mem_30590") != 0)
        return 1;
    (*mem_out_p_30775).references = NULL;
    if (memblock_set(ctx, &*mem_out_p_30775, &mem_out_30633, "mem_out_30633") !=
        0)
        return 1;
    (*mem_out_p_30776).references = NULL;
    if (memblock_set(ctx, &*mem_out_p_30776, &mem_out_30634, "mem_out_30634") !=
        0)
        return 1;
    (*mem_out_p_30777).references = NULL;
    if (memblock_set(ctx, &*mem_out_p_30777, &mem_out_30635, "mem_out_30635") !=
        0)
        return 1;
    (*mem_out_p_30778).references = NULL;
    if (memblock_set(ctx, &*mem_out_p_30778, &mem_out_30636, "mem_out_30636") !=
        0)
        return 1;
    (*mem_out_p_30779).references = NULL;
    if (memblock_set(ctx, &*mem_out_p_30779, &mem_out_30637, "mem_out_30637") !=
        0)
        return 1;
    (*mem_out_p_30780).references = NULL;
    if (memblock_set(ctx, &*mem_out_p_30780, &mem_out_30638, "mem_out_30638") !=
        0)
        return 1;
    (*mem_out_p_30781).references = NULL;
    if (memblock_set(ctx, &*mem_out_p_30781, &mem_out_30639, "mem_out_30639") !=
        0)
        return 1;
    
  cleanup:
    {
        free(mem_29637);
        free(mem_29640);
        free(mem_29643);
        free(mem_29646);
        free(mem_29649);
        free(mem_29755);
        free(mem_29758);
        free(mem_29761);
        free(mem_29764);
        free(mem_29767);
        free(mem_29770);
        free(mem_29773);
        free(mem_29872);
        free(mem_29874);
        free(mem_29877);
        free(mem_29879);
        free(mem_29882);
        free(mem_29885);
        free(mem_29888);
        free(mem_29891);
        free(mem_29990);
        free(mem_30005);
        free(mem_30008);
        free(mem_30011);
        free(mem_30050);
        free(mem_30065);
        free(mem_30081);
        free(mem_30181);
        free(mem_30183);
        free(mem_30438);
        if (memblock_unref(ctx, &mem_30590, "mem_30590") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_30586, "mem_30586") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_30582, "mem_30582") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_30578, "mem_30578") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_30574, "mem_30574") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_30570, "mem_30570") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_30566, "mem_30566") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_30648, "mem_param_tmp_30648") !=
            0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_30647, "mem_param_tmp_30647") !=
            0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_30646, "mem_param_tmp_30646") !=
            0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_30645, "mem_param_tmp_30645") !=
            0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_30644, "mem_param_tmp_30644") !=
            0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_30643, "mem_param_tmp_30643") !=
            0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_30642, "mem_param_tmp_30642") !=
            0)
            return 1;
        if (memblock_unref(ctx, &mem_30456, "mem_30456") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_30453, "mem_30453") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_30450, "mem_30450") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_30447, "mem_30447") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_30444, "mem_30444") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_30441, "mem_30441") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_30739, "mem_param_tmp_30739") !=
            0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_30738, "mem_param_tmp_30738") !=
            0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_30737, "mem_param_tmp_30737") !=
            0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_30736, "mem_param_tmp_30736") !=
            0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_30735, "mem_param_tmp_30735") !=
            0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_30734, "mem_param_tmp_30734") !=
            0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_30733, "mem_param_tmp_30733") !=
            0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_30732, "mem_param_tmp_30732") !=
            0)
            return 1;
        if (memblock_unref(ctx, &mem_30334, "mem_30334") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_30331, "mem_30331") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_30328, "mem_30328") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_30325, "mem_30325") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_30322, "mem_30322") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_30318, "mem_30318") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_30315, "mem_30315") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_30312, "mem_30312") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_30310, "mem_param_30310") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_30305, "mem_param_30305") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_30300, "mem_param_30300") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_30295, "mem_param_30295") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_30287, "mem_param_30287") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_30282, "mem_param_30282") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_30277, "mem_param_30277") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_30272, "mem_param_30272") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_30394, "ext_mem_30394") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_30395, "ext_mem_30395") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_30396, "ext_mem_30396") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_30397, "ext_mem_30397") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_30398, "ext_mem_30398") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_30399, "ext_mem_30399") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_30400, "ext_mem_30400") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_30401, "ext_mem_30401") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_30117, "mem_30117") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_30114, "mem_30114") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_30111, "mem_30111") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_30109, "mem_30109") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_30105, "mem_30105") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_30102, "mem_30102") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_30099, "mem_30099") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_30096, "mem_30096") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_29752, "mem_29752") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_30664, "mem_param_tmp_30664") !=
            0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_30663, "mem_param_tmp_30663") !=
            0)
            return 1;
        if (memblock_unref(ctx, &mem_29715, "mem_29715") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_29712, "mem_29712") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_29632, "mem_param_29632") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_29627, "mem_param_29627") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_29740, "ext_mem_29740") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_29741, "ext_mem_29741") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_29593, "mem_param_29593") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_29588, "mem_param_29588") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_29583, "mem_param_29583") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_29578, "mem_param_29578") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_29573, "mem_param_29573") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_29568, "mem_param_29568") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_29563, "mem_param_29563") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_30529, "ext_mem_30529") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_30530, "ext_mem_30530") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_30531, "ext_mem_30531") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_30532, "ext_mem_30532") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_30533, "ext_mem_30533") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_30534, "ext_mem_30534") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_30535, "ext_mem_30535") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_29610, "mem_29610") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_29558, "mem_29558") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_30639, "mem_out_30639") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_30638, "mem_out_30638") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_30637, "mem_out_30637") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_30636, "mem_out_30636") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_30635, "mem_out_30635") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_30634, "mem_out_30634") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_30633, "mem_out_30633") != 0)
            return 1;
    }
    return err;
}

int futhark_entry_main(struct futhark_context *ctx,
                       struct futhark_f32_1d **out0,
                       struct futhark_f32_1d **out1,
                       struct futhark_f32_1d **out2,
                       struct futhark_f32_1d **out3,
                       struct futhark_f32_1d **out4,
                       struct futhark_f32_1d **out5,
                       struct futhark_f32_1d **out6, const int32_t in0, const
                       float in1, const float in2, const
                       struct futhark_f32_1d *in3, const
                       struct futhark_f32_1d *in4, const
                       struct futhark_f32_1d *in5, const
                       struct futhark_f32_1d *in6, const
                       struct futhark_f32_1d *in7, const
                       struct futhark_f32_1d *in8, const
                       struct futhark_f32_1d *in9)
{
    int64_t n_21239;
    int32_t n_steps_21240;
    float epsilon_21241;
    float time_step_21242;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_30639;
    
    mem_out_30639.references = NULL;
    
    struct memblock mem_out_30638;
    
    mem_out_30638.references = NULL;
    
    struct memblock mem_out_30637;
    
    mem_out_30637.references = NULL;
    
    struct memblock mem_out_30636;
    
    mem_out_30636.references = NULL;
    
    struct memblock mem_out_30635;
    
    mem_out_30635.references = NULL;
    
    struct memblock mem_out_30634;
    
    mem_out_30634.references = NULL;
    
    struct memblock mem_out_30633;
    
    mem_out_30633.references = NULL;
    
    struct memblock zzvs_mem_29555;
    
    zzvs_mem_29555.references = NULL;
    
    struct memblock yvs_mem_29554;
    
    yvs_mem_29554.references = NULL;
    
    struct memblock xvs_mem_29553;
    
    xvs_mem_29553.references = NULL;
    
    struct memblock ms_mem_29552;
    
    ms_mem_29552.references = NULL;
    
    struct memblock zzps_mem_29551;
    
    zzps_mem_29551.references = NULL;
    
    struct memblock yps_mem_29550;
    
    yps_mem_29550.references = NULL;
    
    struct memblock xps_mem_29549;
    
    xps_mem_29549.references = NULL;
    n_steps_21240 = in0;
    epsilon_21241 = in1;
    time_step_21242 = in2;
    xps_mem_29549 = in3->mem;
    n_21239 = in3->shape[0];
    yps_mem_29550 = in4->mem;
    n_21239 = in4->shape[0];
    zzps_mem_29551 = in5->mem;
    n_21239 = in5->shape[0];
    ms_mem_29552 = in6->mem;
    n_21239 = in6->shape[0];
    xvs_mem_29553 = in7->mem;
    n_21239 = in7->shape[0];
    yvs_mem_29554 = in8->mem;
    n_21239 = in8->shape[0];
    zzvs_mem_29555 = in9->mem;
    n_21239 = in9->shape[0];
    if (!(n_21239 == in3->shape[0] && (n_21239 == in4->shape[0] && (n_21239 ==
                                                                    in5->shape[0] &&
                                                                    (n_21239 ==
                                                                     in6->shape[0] &&
                                                                     (n_21239 ==
                                                                      in7->shape[0] &&
                                                                      (n_21239 ==
                                                                       in8->shape[0] &&
                                                                       n_21239 ==
                                                                       in9->shape[0]))))))) {
        ret = 1;
        if (!ctx->error)
            ctx->error =
                msgprintf("Error: entry point arguments have invalid sizes.\n");
    }
    if (ret == 0) {
        ret = futrts_entry_main(ctx, &mem_out_30633, &mem_out_30634,
                                &mem_out_30635, &mem_out_30636, &mem_out_30637,
                                &mem_out_30638, &mem_out_30639, xps_mem_29549,
                                yps_mem_29550, zzps_mem_29551, ms_mem_29552,
                                xvs_mem_29553, yvs_mem_29554, zzvs_mem_29555,
                                n_21239, n_steps_21240, epsilon_21241,
                                time_step_21242);
        if (ret == 0) {
            assert((*out0 =
                    (struct futhark_f32_1d *) malloc(sizeof(struct futhark_f32_1d))) !=
                NULL);
            (*out0)->mem = mem_out_30633;
            (*out0)->shape[0] = n_21239;
            assert((*out1 =
                    (struct futhark_f32_1d *) malloc(sizeof(struct futhark_f32_1d))) !=
                NULL);
            (*out1)->mem = mem_out_30634;
            (*out1)->shape[0] = n_21239;
            assert((*out2 =
                    (struct futhark_f32_1d *) malloc(sizeof(struct futhark_f32_1d))) !=
                NULL);
            (*out2)->mem = mem_out_30635;
            (*out2)->shape[0] = n_21239;
            assert((*out3 =
                    (struct futhark_f32_1d *) malloc(sizeof(struct futhark_f32_1d))) !=
                NULL);
            (*out3)->mem = mem_out_30636;
            (*out3)->shape[0] = n_21239;
            assert((*out4 =
                    (struct futhark_f32_1d *) malloc(sizeof(struct futhark_f32_1d))) !=
                NULL);
            (*out4)->mem = mem_out_30637;
            (*out4)->shape[0] = n_21239;
            assert((*out5 =
                    (struct futhark_f32_1d *) malloc(sizeof(struct futhark_f32_1d))) !=
                NULL);
            (*out5)->mem = mem_out_30638;
            (*out5)->shape[0] = n_21239;
            assert((*out6 =
                    (struct futhark_f32_1d *) malloc(sizeof(struct futhark_f32_1d))) !=
                NULL);
            (*out6)->mem = mem_out_30639;
            (*out6)->shape[0] = n_21239;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
  
