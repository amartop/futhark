
// We need to define _GNU_SOURCE before
// _any_ headers files are imported to get
// the usage statistics of a thread (i.e. have RUSAGE_THREAD) on GNU/Linux
// https://manpages.courier-mta.org/htmlman2/getrusage.2.html
#ifndef _GNU_SOURCE // Avoid possible double-definition warning.
#define _GNU_SOURCE
#endif

#ifdef __clang__
#pragma clang diagnostic ignored "-Wunused-function"
#pragma clang diagnostic ignored "-Wunused-variable"
#pragma clang diagnostic ignored "-Wparentheses"
#pragma clang diagnostic ignored "-Wunused-label"
#elif __GNUC__
#pragma GCC diagnostic ignored "-Wunused-function"
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wparentheses"
#pragma GCC diagnostic ignored "-Wunused-label"
#pragma GCC diagnostic ignored "-Wunused-but-set-variable"
#endif

// Headers\n")
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <stdio.h>
#include <float.h>

#ifdef __cplusplus
extern "C" {
#endif

// Initialisation
struct futhark_context_config;
struct futhark_context_config *futhark_context_config_new(void);
void futhark_context_config_free(struct futhark_context_config *cfg);
void futhark_context_config_set_debugging(struct futhark_context_config *cfg,
                                          int flag);
void futhark_context_config_set_profiling(struct futhark_context_config *cfg,
                                          int flag);
void futhark_context_config_set_logging(struct futhark_context_config *cfg,
                                        int flag);
struct futhark_context;
struct futhark_context *futhark_context_new(struct futhark_context_config *cfg);
void futhark_context_free(struct futhark_context *ctx);
int futhark_context_config_set_tuning_param(struct futhark_context_config *cfg,
                                            const char *param_name,
                                            size_t param_value);
int futhark_get_tuning_param_count(void);
const char *futhark_get_tuning_param_name(int);
const char *futhark_get_tuning_param_class(int);

// Arrays
struct futhark_f32_1d;
struct futhark_f32_1d *futhark_new_f32_1d(struct futhark_context *ctx, const
                                          float *data, int64_t dim0);
struct futhark_f32_1d *futhark_new_raw_f32_1d(struct futhark_context *ctx, const
                                              unsigned char *data,
                                              int64_t offset, int64_t dim0);
int futhark_free_f32_1d(struct futhark_context *ctx,
                        struct futhark_f32_1d *arr);
int futhark_values_f32_1d(struct futhark_context *ctx,
                          struct futhark_f32_1d *arr, float *data);
unsigned char *futhark_values_raw_f32_1d(struct futhark_context *ctx,
                                         struct futhark_f32_1d *arr);
const int64_t *futhark_shape_f32_1d(struct futhark_context *ctx,
                                    struct futhark_f32_1d *arr);

// Opaque values


// Entry points
int futhark_entry_main(struct futhark_context *ctx,
                       struct futhark_f32_1d **out0,
                       struct futhark_f32_1d **out1,
                       struct futhark_f32_1d **out2,
                       struct futhark_f32_1d **out3,
                       struct futhark_f32_1d **out4,
                       struct futhark_f32_1d **out5,
                       struct futhark_f32_1d **out6, const int32_t in0, const
                       float in1, const float in2, const
                       struct futhark_f32_1d *in3, const
                       struct futhark_f32_1d *in4, const
                       struct futhark_f32_1d *in5, const
                       struct futhark_f32_1d *in6, const
                       struct futhark_f32_1d *in7, const
                       struct futhark_f32_1d *in8, const
                       struct futhark_f32_1d *in9);

// Miscellaneous
int futhark_context_sync(struct futhark_context *ctx);
char *futhark_context_report(struct futhark_context *ctx);
char *futhark_context_get_error(struct futhark_context *ctx);
void futhark_context_set_logging_file(struct futhark_context *ctx, FILE *f);
void futhark_context_pause_profiling(struct futhark_context *ctx);
void futhark_context_unpause_profiling(struct futhark_context *ctx);
int futhark_context_clear_caches(struct futhark_context *ctx);
#define FUTHARK_BACKEND_c
#define FUTHARK_SUCCESS 0
#define FUTHARK_PROGRAM_ERROR 2
#define FUTHARK_OUT_OF_MEMORY 3

#ifdef __cplusplus
}
#endif

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <math.h>
#include <stdint.h>
// If NDEBUG is set, the assert() macro will do nothing. Since Futhark
// (unfortunately) makes use of assert() for error detection (and even some
// side effects), we want to avoid that.
#undef NDEBUG
#include <assert.h>
#include <stdarg.h>
// Start of util.h.
//
// Various helper functions that are useful in all generated C code.

#include <errno.h>
#include <string.h>

static const char *fut_progname = "(embedded Futhark)";

static void futhark_panic(int eval, const char *fmt, ...) __attribute__((noreturn));
static char* msgprintf(const char *s, ...);
static void* slurp_file(const char *filename, size_t *size);
static int dump_file(const char *file, const void *buf, size_t n);
struct str_builder;
static void str_builder_init(struct str_builder *b);
static void str_builder(struct str_builder *b, const char *s, ...);

static void futhark_panic(int eval, const char *fmt, ...) {
  va_list ap;
  va_start(ap, fmt);
  fprintf(stderr, "%s: ", fut_progname);
  vfprintf(stderr, fmt, ap);
  va_end(ap);
  exit(eval);
}

// For generating arbitrary-sized error messages.  It is the callers
// responsibility to free the buffer at some point.
static char* msgprintf(const char *s, ...) {
  va_list vl;
  va_start(vl, s);
  size_t needed = 1 + (size_t)vsnprintf(NULL, 0, s, vl);
  char *buffer = (char*) malloc(needed);
  va_start(vl, s); // Must re-init.
  vsnprintf(buffer, needed, s, vl);
  return buffer;
}

static inline void check_err(int errval, int sets_errno, const char *fun, int line,
                             const char *msg, ...) {
  if (errval) {
    char errnum[10];

    va_list vl;
    va_start(vl, msg);

    fprintf(stderr, "ERROR: ");
    vfprintf(stderr, msg, vl);
    fprintf(stderr, " in %s() at line %d with error code %s\n",
            fun, line,
            sets_errno ? strerror(errno) : errnum);
    exit(errval);
  }
}

#define CHECK_ERR(err, ...) check_err(err, 0, __func__, __LINE__, __VA_ARGS__)
#define CHECK_ERRNO(err, ...) check_err(err, 1, __func__, __LINE__, __VA_ARGS__)

// Read the rest of an open file into a NUL-terminated string; returns
// NULL on error.
static void* fslurp_file(FILE *f, size_t *size) {
  long start = ftell(f);
  fseek(f, 0, SEEK_END);
  long src_size = ftell(f)-start;
  fseek(f, start, SEEK_SET);
  unsigned char *s = (unsigned char*) malloc((size_t)src_size + 1);
  if (fread(s, 1, (size_t)src_size, f) != (size_t)src_size) {
    free(s);
    s = NULL;
  } else {
    s[src_size] = '\0';
  }

  if (size) {
    *size = (size_t)src_size;
  }

  return s;
}

// Read a file into a NUL-terminated string; returns NULL on error.
static void* slurp_file(const char *filename, size_t *size) {
  FILE *f = fopen(filename, "rb"); // To avoid Windows messing with linebreaks.
  if (f == NULL) return NULL;
  unsigned char *s = fslurp_file(f, size);
  fclose(f);
  return s;
}

// Dump 'n' bytes from 'buf' into the file at the designated location.
// Returns 0 on success.
static int dump_file(const char *file, const void *buf, size_t n) {
  FILE *f = fopen(file, "w");

  if (f == NULL) {
    return 1;
  }

  if (fwrite(buf, sizeof(char), n, f) != n) {
    return 1;
  }

  if (fclose(f) != 0) {
    return 1;
  }

  return 0;
}

struct str_builder {
  char *str;
  size_t capacity; // Size of buffer.
  size_t used; // Bytes used, *not* including final zero.
};

static void str_builder_init(struct str_builder *b) {
  b->capacity = 10;
  b->used = 0;
  b->str = malloc(b->capacity);
  b->str[0] = 0;
}

static void str_builder(struct str_builder *b, const char *s, ...) {
  va_list vl;
  va_start(vl, s);
  size_t needed = (size_t)vsnprintf(NULL, 0, s, vl);

  while (b->capacity < b->used + needed + 1) {
    b->capacity *= 2;
    b->str = realloc(b->str, b->capacity);
  }

  va_start(vl, s); // Must re-init.
  vsnprintf(b->str+b->used, b->capacity-b->used, s, vl);
  b->used += needed;
}

static int lexical_realloc(char **error, unsigned char **ptr, size_t *old_size, size_t new_size) {
  unsigned char *new = realloc(*ptr, new_size);
  if (new == NULL) {
    *error = msgprintf("Failed to allocate memory.\nAttempted allocation: %12lld bytes\n",
                       (long long) new_size);
    return FUTHARK_OUT_OF_MEMORY;
  } else {
    *ptr = new;
    *old_size = new_size;
    return FUTHARK_SUCCESS;
  }
}

// End of util.h.
// Start of half.h.

// Conversion functions are from http://half.sourceforge.net/, but
// translated to C.
//
// Copyright (c) 2012-2021 Christian Rau
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

#ifndef __OPENCL_VERSION__
#define __constant
#endif

__constant static const uint16_t base_table[512] = {
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080, 0x0100,
  0x0200, 0x0400, 0x0800, 0x0C00, 0x1000, 0x1400, 0x1800, 0x1C00, 0x2000, 0x2400, 0x2800, 0x2C00, 0x3000, 0x3400, 0x3800, 0x3C00,
  0x4000, 0x4400, 0x4800, 0x4C00, 0x5000, 0x5400, 0x5800, 0x5C00, 0x6000, 0x6400, 0x6800, 0x6C00, 0x7000, 0x7400, 0x7800, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8001, 0x8002, 0x8004, 0x8008, 0x8010, 0x8020, 0x8040, 0x8080, 0x8100,
  0x8200, 0x8400, 0x8800, 0x8C00, 0x9000, 0x9400, 0x9800, 0x9C00, 0xA000, 0xA400, 0xA800, 0xAC00, 0xB000, 0xB400, 0xB800, 0xBC00,
  0xC000, 0xC400, 0xC800, 0xCC00, 0xD000, 0xD400, 0xD800, 0xDC00, 0xE000, 0xE400, 0xE800, 0xEC00, 0xF000, 0xF400, 0xF800, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00 };

__constant static const unsigned char shift_table[512] = {
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 13,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 13 };

__constant static const uint32_t mantissa_table[2048] = {
  0x00000000, 0x33800000, 0x34000000, 0x34400000, 0x34800000, 0x34A00000, 0x34C00000, 0x34E00000, 0x35000000, 0x35100000, 0x35200000, 0x35300000, 0x35400000, 0x35500000, 0x35600000, 0x35700000,
  0x35800000, 0x35880000, 0x35900000, 0x35980000, 0x35A00000, 0x35A80000, 0x35B00000, 0x35B80000, 0x35C00000, 0x35C80000, 0x35D00000, 0x35D80000, 0x35E00000, 0x35E80000, 0x35F00000, 0x35F80000,
  0x36000000, 0x36040000, 0x36080000, 0x360C0000, 0x36100000, 0x36140000, 0x36180000, 0x361C0000, 0x36200000, 0x36240000, 0x36280000, 0x362C0000, 0x36300000, 0x36340000, 0x36380000, 0x363C0000,
  0x36400000, 0x36440000, 0x36480000, 0x364C0000, 0x36500000, 0x36540000, 0x36580000, 0x365C0000, 0x36600000, 0x36640000, 0x36680000, 0x366C0000, 0x36700000, 0x36740000, 0x36780000, 0x367C0000,
  0x36800000, 0x36820000, 0x36840000, 0x36860000, 0x36880000, 0x368A0000, 0x368C0000, 0x368E0000, 0x36900000, 0x36920000, 0x36940000, 0x36960000, 0x36980000, 0x369A0000, 0x369C0000, 0x369E0000,
  0x36A00000, 0x36A20000, 0x36A40000, 0x36A60000, 0x36A80000, 0x36AA0000, 0x36AC0000, 0x36AE0000, 0x36B00000, 0x36B20000, 0x36B40000, 0x36B60000, 0x36B80000, 0x36BA0000, 0x36BC0000, 0x36BE0000,
  0x36C00000, 0x36C20000, 0x36C40000, 0x36C60000, 0x36C80000, 0x36CA0000, 0x36CC0000, 0x36CE0000, 0x36D00000, 0x36D20000, 0x36D40000, 0x36D60000, 0x36D80000, 0x36DA0000, 0x36DC0000, 0x36DE0000,
  0x36E00000, 0x36E20000, 0x36E40000, 0x36E60000, 0x36E80000, 0x36EA0000, 0x36EC0000, 0x36EE0000, 0x36F00000, 0x36F20000, 0x36F40000, 0x36F60000, 0x36F80000, 0x36FA0000, 0x36FC0000, 0x36FE0000,
  0x37000000, 0x37010000, 0x37020000, 0x37030000, 0x37040000, 0x37050000, 0x37060000, 0x37070000, 0x37080000, 0x37090000, 0x370A0000, 0x370B0000, 0x370C0000, 0x370D0000, 0x370E0000, 0x370F0000,
  0x37100000, 0x37110000, 0x37120000, 0x37130000, 0x37140000, 0x37150000, 0x37160000, 0x37170000, 0x37180000, 0x37190000, 0x371A0000, 0x371B0000, 0x371C0000, 0x371D0000, 0x371E0000, 0x371F0000,
  0x37200000, 0x37210000, 0x37220000, 0x37230000, 0x37240000, 0x37250000, 0x37260000, 0x37270000, 0x37280000, 0x37290000, 0x372A0000, 0x372B0000, 0x372C0000, 0x372D0000, 0x372E0000, 0x372F0000,
  0x37300000, 0x37310000, 0x37320000, 0x37330000, 0x37340000, 0x37350000, 0x37360000, 0x37370000, 0x37380000, 0x37390000, 0x373A0000, 0x373B0000, 0x373C0000, 0x373D0000, 0x373E0000, 0x373F0000,
  0x37400000, 0x37410000, 0x37420000, 0x37430000, 0x37440000, 0x37450000, 0x37460000, 0x37470000, 0x37480000, 0x37490000, 0x374A0000, 0x374B0000, 0x374C0000, 0x374D0000, 0x374E0000, 0x374F0000,
  0x37500000, 0x37510000, 0x37520000, 0x37530000, 0x37540000, 0x37550000, 0x37560000, 0x37570000, 0x37580000, 0x37590000, 0x375A0000, 0x375B0000, 0x375C0000, 0x375D0000, 0x375E0000, 0x375F0000,
  0x37600000, 0x37610000, 0x37620000, 0x37630000, 0x37640000, 0x37650000, 0x37660000, 0x37670000, 0x37680000, 0x37690000, 0x376A0000, 0x376B0000, 0x376C0000, 0x376D0000, 0x376E0000, 0x376F0000,
  0x37700000, 0x37710000, 0x37720000, 0x37730000, 0x37740000, 0x37750000, 0x37760000, 0x37770000, 0x37780000, 0x37790000, 0x377A0000, 0x377B0000, 0x377C0000, 0x377D0000, 0x377E0000, 0x377F0000,
  0x37800000, 0x37808000, 0x37810000, 0x37818000, 0x37820000, 0x37828000, 0x37830000, 0x37838000, 0x37840000, 0x37848000, 0x37850000, 0x37858000, 0x37860000, 0x37868000, 0x37870000, 0x37878000,
  0x37880000, 0x37888000, 0x37890000, 0x37898000, 0x378A0000, 0x378A8000, 0x378B0000, 0x378B8000, 0x378C0000, 0x378C8000, 0x378D0000, 0x378D8000, 0x378E0000, 0x378E8000, 0x378F0000, 0x378F8000,
  0x37900000, 0x37908000, 0x37910000, 0x37918000, 0x37920000, 0x37928000, 0x37930000, 0x37938000, 0x37940000, 0x37948000, 0x37950000, 0x37958000, 0x37960000, 0x37968000, 0x37970000, 0x37978000,
  0x37980000, 0x37988000, 0x37990000, 0x37998000, 0x379A0000, 0x379A8000, 0x379B0000, 0x379B8000, 0x379C0000, 0x379C8000, 0x379D0000, 0x379D8000, 0x379E0000, 0x379E8000, 0x379F0000, 0x379F8000,
  0x37A00000, 0x37A08000, 0x37A10000, 0x37A18000, 0x37A20000, 0x37A28000, 0x37A30000, 0x37A38000, 0x37A40000, 0x37A48000, 0x37A50000, 0x37A58000, 0x37A60000, 0x37A68000, 0x37A70000, 0x37A78000,
  0x37A80000, 0x37A88000, 0x37A90000, 0x37A98000, 0x37AA0000, 0x37AA8000, 0x37AB0000, 0x37AB8000, 0x37AC0000, 0x37AC8000, 0x37AD0000, 0x37AD8000, 0x37AE0000, 0x37AE8000, 0x37AF0000, 0x37AF8000,
  0x37B00000, 0x37B08000, 0x37B10000, 0x37B18000, 0x37B20000, 0x37B28000, 0x37B30000, 0x37B38000, 0x37B40000, 0x37B48000, 0x37B50000, 0x37B58000, 0x37B60000, 0x37B68000, 0x37B70000, 0x37B78000,
  0x37B80000, 0x37B88000, 0x37B90000, 0x37B98000, 0x37BA0000, 0x37BA8000, 0x37BB0000, 0x37BB8000, 0x37BC0000, 0x37BC8000, 0x37BD0000, 0x37BD8000, 0x37BE0000, 0x37BE8000, 0x37BF0000, 0x37BF8000,
  0x37C00000, 0x37C08000, 0x37C10000, 0x37C18000, 0x37C20000, 0x37C28000, 0x37C30000, 0x37C38000, 0x37C40000, 0x37C48000, 0x37C50000, 0x37C58000, 0x37C60000, 0x37C68000, 0x37C70000, 0x37C78000,
  0x37C80000, 0x37C88000, 0x37C90000, 0x37C98000, 0x37CA0000, 0x37CA8000, 0x37CB0000, 0x37CB8000, 0x37CC0000, 0x37CC8000, 0x37CD0000, 0x37CD8000, 0x37CE0000, 0x37CE8000, 0x37CF0000, 0x37CF8000,
  0x37D00000, 0x37D08000, 0x37D10000, 0x37D18000, 0x37D20000, 0x37D28000, 0x37D30000, 0x37D38000, 0x37D40000, 0x37D48000, 0x37D50000, 0x37D58000, 0x37D60000, 0x37D68000, 0x37D70000, 0x37D78000,
  0x37D80000, 0x37D88000, 0x37D90000, 0x37D98000, 0x37DA0000, 0x37DA8000, 0x37DB0000, 0x37DB8000, 0x37DC0000, 0x37DC8000, 0x37DD0000, 0x37DD8000, 0x37DE0000, 0x37DE8000, 0x37DF0000, 0x37DF8000,
  0x37E00000, 0x37E08000, 0x37E10000, 0x37E18000, 0x37E20000, 0x37E28000, 0x37E30000, 0x37E38000, 0x37E40000, 0x37E48000, 0x37E50000, 0x37E58000, 0x37E60000, 0x37E68000, 0x37E70000, 0x37E78000,
  0x37E80000, 0x37E88000, 0x37E90000, 0x37E98000, 0x37EA0000, 0x37EA8000, 0x37EB0000, 0x37EB8000, 0x37EC0000, 0x37EC8000, 0x37ED0000, 0x37ED8000, 0x37EE0000, 0x37EE8000, 0x37EF0000, 0x37EF8000,
  0x37F00000, 0x37F08000, 0x37F10000, 0x37F18000, 0x37F20000, 0x37F28000, 0x37F30000, 0x37F38000, 0x37F40000, 0x37F48000, 0x37F50000, 0x37F58000, 0x37F60000, 0x37F68000, 0x37F70000, 0x37F78000,
  0x37F80000, 0x37F88000, 0x37F90000, 0x37F98000, 0x37FA0000, 0x37FA8000, 0x37FB0000, 0x37FB8000, 0x37FC0000, 0x37FC8000, 0x37FD0000, 0x37FD8000, 0x37FE0000, 0x37FE8000, 0x37FF0000, 0x37FF8000,
  0x38000000, 0x38004000, 0x38008000, 0x3800C000, 0x38010000, 0x38014000, 0x38018000, 0x3801C000, 0x38020000, 0x38024000, 0x38028000, 0x3802C000, 0x38030000, 0x38034000, 0x38038000, 0x3803C000,
  0x38040000, 0x38044000, 0x38048000, 0x3804C000, 0x38050000, 0x38054000, 0x38058000, 0x3805C000, 0x38060000, 0x38064000, 0x38068000, 0x3806C000, 0x38070000, 0x38074000, 0x38078000, 0x3807C000,
  0x38080000, 0x38084000, 0x38088000, 0x3808C000, 0x38090000, 0x38094000, 0x38098000, 0x3809C000, 0x380A0000, 0x380A4000, 0x380A8000, 0x380AC000, 0x380B0000, 0x380B4000, 0x380B8000, 0x380BC000,
  0x380C0000, 0x380C4000, 0x380C8000, 0x380CC000, 0x380D0000, 0x380D4000, 0x380D8000, 0x380DC000, 0x380E0000, 0x380E4000, 0x380E8000, 0x380EC000, 0x380F0000, 0x380F4000, 0x380F8000, 0x380FC000,
  0x38100000, 0x38104000, 0x38108000, 0x3810C000, 0x38110000, 0x38114000, 0x38118000, 0x3811C000, 0x38120000, 0x38124000, 0x38128000, 0x3812C000, 0x38130000, 0x38134000, 0x38138000, 0x3813C000,
  0x38140000, 0x38144000, 0x38148000, 0x3814C000, 0x38150000, 0x38154000, 0x38158000, 0x3815C000, 0x38160000, 0x38164000, 0x38168000, 0x3816C000, 0x38170000, 0x38174000, 0x38178000, 0x3817C000,
  0x38180000, 0x38184000, 0x38188000, 0x3818C000, 0x38190000, 0x38194000, 0x38198000, 0x3819C000, 0x381A0000, 0x381A4000, 0x381A8000, 0x381AC000, 0x381B0000, 0x381B4000, 0x381B8000, 0x381BC000,
  0x381C0000, 0x381C4000, 0x381C8000, 0x381CC000, 0x381D0000, 0x381D4000, 0x381D8000, 0x381DC000, 0x381E0000, 0x381E4000, 0x381E8000, 0x381EC000, 0x381F0000, 0x381F4000, 0x381F8000, 0x381FC000,
  0x38200000, 0x38204000, 0x38208000, 0x3820C000, 0x38210000, 0x38214000, 0x38218000, 0x3821C000, 0x38220000, 0x38224000, 0x38228000, 0x3822C000, 0x38230000, 0x38234000, 0x38238000, 0x3823C000,
  0x38240000, 0x38244000, 0x38248000, 0x3824C000, 0x38250000, 0x38254000, 0x38258000, 0x3825C000, 0x38260000, 0x38264000, 0x38268000, 0x3826C000, 0x38270000, 0x38274000, 0x38278000, 0x3827C000,
  0x38280000, 0x38284000, 0x38288000, 0x3828C000, 0x38290000, 0x38294000, 0x38298000, 0x3829C000, 0x382A0000, 0x382A4000, 0x382A8000, 0x382AC000, 0x382B0000, 0x382B4000, 0x382B8000, 0x382BC000,
  0x382C0000, 0x382C4000, 0x382C8000, 0x382CC000, 0x382D0000, 0x382D4000, 0x382D8000, 0x382DC000, 0x382E0000, 0x382E4000, 0x382E8000, 0x382EC000, 0x382F0000, 0x382F4000, 0x382F8000, 0x382FC000,
  0x38300000, 0x38304000, 0x38308000, 0x3830C000, 0x38310000, 0x38314000, 0x38318000, 0x3831C000, 0x38320000, 0x38324000, 0x38328000, 0x3832C000, 0x38330000, 0x38334000, 0x38338000, 0x3833C000,
  0x38340000, 0x38344000, 0x38348000, 0x3834C000, 0x38350000, 0x38354000, 0x38358000, 0x3835C000, 0x38360000, 0x38364000, 0x38368000, 0x3836C000, 0x38370000, 0x38374000, 0x38378000, 0x3837C000,
  0x38380000, 0x38384000, 0x38388000, 0x3838C000, 0x38390000, 0x38394000, 0x38398000, 0x3839C000, 0x383A0000, 0x383A4000, 0x383A8000, 0x383AC000, 0x383B0000, 0x383B4000, 0x383B8000, 0x383BC000,
  0x383C0000, 0x383C4000, 0x383C8000, 0x383CC000, 0x383D0000, 0x383D4000, 0x383D8000, 0x383DC000, 0x383E0000, 0x383E4000, 0x383E8000, 0x383EC000, 0x383F0000, 0x383F4000, 0x383F8000, 0x383FC000,
  0x38400000, 0x38404000, 0x38408000, 0x3840C000, 0x38410000, 0x38414000, 0x38418000, 0x3841C000, 0x38420000, 0x38424000, 0x38428000, 0x3842C000, 0x38430000, 0x38434000, 0x38438000, 0x3843C000,
  0x38440000, 0x38444000, 0x38448000, 0x3844C000, 0x38450000, 0x38454000, 0x38458000, 0x3845C000, 0x38460000, 0x38464000, 0x38468000, 0x3846C000, 0x38470000, 0x38474000, 0x38478000, 0x3847C000,
  0x38480000, 0x38484000, 0x38488000, 0x3848C000, 0x38490000, 0x38494000, 0x38498000, 0x3849C000, 0x384A0000, 0x384A4000, 0x384A8000, 0x384AC000, 0x384B0000, 0x384B4000, 0x384B8000, 0x384BC000,
  0x384C0000, 0x384C4000, 0x384C8000, 0x384CC000, 0x384D0000, 0x384D4000, 0x384D8000, 0x384DC000, 0x384E0000, 0x384E4000, 0x384E8000, 0x384EC000, 0x384F0000, 0x384F4000, 0x384F8000, 0x384FC000,
  0x38500000, 0x38504000, 0x38508000, 0x3850C000, 0x38510000, 0x38514000, 0x38518000, 0x3851C000, 0x38520000, 0x38524000, 0x38528000, 0x3852C000, 0x38530000, 0x38534000, 0x38538000, 0x3853C000,
  0x38540000, 0x38544000, 0x38548000, 0x3854C000, 0x38550000, 0x38554000, 0x38558000, 0x3855C000, 0x38560000, 0x38564000, 0x38568000, 0x3856C000, 0x38570000, 0x38574000, 0x38578000, 0x3857C000,
  0x38580000, 0x38584000, 0x38588000, 0x3858C000, 0x38590000, 0x38594000, 0x38598000, 0x3859C000, 0x385A0000, 0x385A4000, 0x385A8000, 0x385AC000, 0x385B0000, 0x385B4000, 0x385B8000, 0x385BC000,
  0x385C0000, 0x385C4000, 0x385C8000, 0x385CC000, 0x385D0000, 0x385D4000, 0x385D8000, 0x385DC000, 0x385E0000, 0x385E4000, 0x385E8000, 0x385EC000, 0x385F0000, 0x385F4000, 0x385F8000, 0x385FC000,
  0x38600000, 0x38604000, 0x38608000, 0x3860C000, 0x38610000, 0x38614000, 0x38618000, 0x3861C000, 0x38620000, 0x38624000, 0x38628000, 0x3862C000, 0x38630000, 0x38634000, 0x38638000, 0x3863C000,
  0x38640000, 0x38644000, 0x38648000, 0x3864C000, 0x38650000, 0x38654000, 0x38658000, 0x3865C000, 0x38660000, 0x38664000, 0x38668000, 0x3866C000, 0x38670000, 0x38674000, 0x38678000, 0x3867C000,
  0x38680000, 0x38684000, 0x38688000, 0x3868C000, 0x38690000, 0x38694000, 0x38698000, 0x3869C000, 0x386A0000, 0x386A4000, 0x386A8000, 0x386AC000, 0x386B0000, 0x386B4000, 0x386B8000, 0x386BC000,
  0x386C0000, 0x386C4000, 0x386C8000, 0x386CC000, 0x386D0000, 0x386D4000, 0x386D8000, 0x386DC000, 0x386E0000, 0x386E4000, 0x386E8000, 0x386EC000, 0x386F0000, 0x386F4000, 0x386F8000, 0x386FC000,
  0x38700000, 0x38704000, 0x38708000, 0x3870C000, 0x38710000, 0x38714000, 0x38718000, 0x3871C000, 0x38720000, 0x38724000, 0x38728000, 0x3872C000, 0x38730000, 0x38734000, 0x38738000, 0x3873C000,
  0x38740000, 0x38744000, 0x38748000, 0x3874C000, 0x38750000, 0x38754000, 0x38758000, 0x3875C000, 0x38760000, 0x38764000, 0x38768000, 0x3876C000, 0x38770000, 0x38774000, 0x38778000, 0x3877C000,
  0x38780000, 0x38784000, 0x38788000, 0x3878C000, 0x38790000, 0x38794000, 0x38798000, 0x3879C000, 0x387A0000, 0x387A4000, 0x387A8000, 0x387AC000, 0x387B0000, 0x387B4000, 0x387B8000, 0x387BC000,
  0x387C0000, 0x387C4000, 0x387C8000, 0x387CC000, 0x387D0000, 0x387D4000, 0x387D8000, 0x387DC000, 0x387E0000, 0x387E4000, 0x387E8000, 0x387EC000, 0x387F0000, 0x387F4000, 0x387F8000, 0x387FC000,
  0x38000000, 0x38002000, 0x38004000, 0x38006000, 0x38008000, 0x3800A000, 0x3800C000, 0x3800E000, 0x38010000, 0x38012000, 0x38014000, 0x38016000, 0x38018000, 0x3801A000, 0x3801C000, 0x3801E000,
  0x38020000, 0x38022000, 0x38024000, 0x38026000, 0x38028000, 0x3802A000, 0x3802C000, 0x3802E000, 0x38030000, 0x38032000, 0x38034000, 0x38036000, 0x38038000, 0x3803A000, 0x3803C000, 0x3803E000,
  0x38040000, 0x38042000, 0x38044000, 0x38046000, 0x38048000, 0x3804A000, 0x3804C000, 0x3804E000, 0x38050000, 0x38052000, 0x38054000, 0x38056000, 0x38058000, 0x3805A000, 0x3805C000, 0x3805E000,
  0x38060000, 0x38062000, 0x38064000, 0x38066000, 0x38068000, 0x3806A000, 0x3806C000, 0x3806E000, 0x38070000, 0x38072000, 0x38074000, 0x38076000, 0x38078000, 0x3807A000, 0x3807C000, 0x3807E000,
  0x38080000, 0x38082000, 0x38084000, 0x38086000, 0x38088000, 0x3808A000, 0x3808C000, 0x3808E000, 0x38090000, 0x38092000, 0x38094000, 0x38096000, 0x38098000, 0x3809A000, 0x3809C000, 0x3809E000,
  0x380A0000, 0x380A2000, 0x380A4000, 0x380A6000, 0x380A8000, 0x380AA000, 0x380AC000, 0x380AE000, 0x380B0000, 0x380B2000, 0x380B4000, 0x380B6000, 0x380B8000, 0x380BA000, 0x380BC000, 0x380BE000,
  0x380C0000, 0x380C2000, 0x380C4000, 0x380C6000, 0x380C8000, 0x380CA000, 0x380CC000, 0x380CE000, 0x380D0000, 0x380D2000, 0x380D4000, 0x380D6000, 0x380D8000, 0x380DA000, 0x380DC000, 0x380DE000,
  0x380E0000, 0x380E2000, 0x380E4000, 0x380E6000, 0x380E8000, 0x380EA000, 0x380EC000, 0x380EE000, 0x380F0000, 0x380F2000, 0x380F4000, 0x380F6000, 0x380F8000, 0x380FA000, 0x380FC000, 0x380FE000,
  0x38100000, 0x38102000, 0x38104000, 0x38106000, 0x38108000, 0x3810A000, 0x3810C000, 0x3810E000, 0x38110000, 0x38112000, 0x38114000, 0x38116000, 0x38118000, 0x3811A000, 0x3811C000, 0x3811E000,
  0x38120000, 0x38122000, 0x38124000, 0x38126000, 0x38128000, 0x3812A000, 0x3812C000, 0x3812E000, 0x38130000, 0x38132000, 0x38134000, 0x38136000, 0x38138000, 0x3813A000, 0x3813C000, 0x3813E000,
  0x38140000, 0x38142000, 0x38144000, 0x38146000, 0x38148000, 0x3814A000, 0x3814C000, 0x3814E000, 0x38150000, 0x38152000, 0x38154000, 0x38156000, 0x38158000, 0x3815A000, 0x3815C000, 0x3815E000,
  0x38160000, 0x38162000, 0x38164000, 0x38166000, 0x38168000, 0x3816A000, 0x3816C000, 0x3816E000, 0x38170000, 0x38172000, 0x38174000, 0x38176000, 0x38178000, 0x3817A000, 0x3817C000, 0x3817E000,
  0x38180000, 0x38182000, 0x38184000, 0x38186000, 0x38188000, 0x3818A000, 0x3818C000, 0x3818E000, 0x38190000, 0x38192000, 0x38194000, 0x38196000, 0x38198000, 0x3819A000, 0x3819C000, 0x3819E000,
  0x381A0000, 0x381A2000, 0x381A4000, 0x381A6000, 0x381A8000, 0x381AA000, 0x381AC000, 0x381AE000, 0x381B0000, 0x381B2000, 0x381B4000, 0x381B6000, 0x381B8000, 0x381BA000, 0x381BC000, 0x381BE000,
  0x381C0000, 0x381C2000, 0x381C4000, 0x381C6000, 0x381C8000, 0x381CA000, 0x381CC000, 0x381CE000, 0x381D0000, 0x381D2000, 0x381D4000, 0x381D6000, 0x381D8000, 0x381DA000, 0x381DC000, 0x381DE000,
  0x381E0000, 0x381E2000, 0x381E4000, 0x381E6000, 0x381E8000, 0x381EA000, 0x381EC000, 0x381EE000, 0x381F0000, 0x381F2000, 0x381F4000, 0x381F6000, 0x381F8000, 0x381FA000, 0x381FC000, 0x381FE000,
  0x38200000, 0x38202000, 0x38204000, 0x38206000, 0x38208000, 0x3820A000, 0x3820C000, 0x3820E000, 0x38210000, 0x38212000, 0x38214000, 0x38216000, 0x38218000, 0x3821A000, 0x3821C000, 0x3821E000,
  0x38220000, 0x38222000, 0x38224000, 0x38226000, 0x38228000, 0x3822A000, 0x3822C000, 0x3822E000, 0x38230000, 0x38232000, 0x38234000, 0x38236000, 0x38238000, 0x3823A000, 0x3823C000, 0x3823E000,
  0x38240000, 0x38242000, 0x38244000, 0x38246000, 0x38248000, 0x3824A000, 0x3824C000, 0x3824E000, 0x38250000, 0x38252000, 0x38254000, 0x38256000, 0x38258000, 0x3825A000, 0x3825C000, 0x3825E000,
  0x38260000, 0x38262000, 0x38264000, 0x38266000, 0x38268000, 0x3826A000, 0x3826C000, 0x3826E000, 0x38270000, 0x38272000, 0x38274000, 0x38276000, 0x38278000, 0x3827A000, 0x3827C000, 0x3827E000,
  0x38280000, 0x38282000, 0x38284000, 0x38286000, 0x38288000, 0x3828A000, 0x3828C000, 0x3828E000, 0x38290000, 0x38292000, 0x38294000, 0x38296000, 0x38298000, 0x3829A000, 0x3829C000, 0x3829E000,
  0x382A0000, 0x382A2000, 0x382A4000, 0x382A6000, 0x382A8000, 0x382AA000, 0x382AC000, 0x382AE000, 0x382B0000, 0x382B2000, 0x382B4000, 0x382B6000, 0x382B8000, 0x382BA000, 0x382BC000, 0x382BE000,
  0x382C0000, 0x382C2000, 0x382C4000, 0x382C6000, 0x382C8000, 0x382CA000, 0x382CC000, 0x382CE000, 0x382D0000, 0x382D2000, 0x382D4000, 0x382D6000, 0x382D8000, 0x382DA000, 0x382DC000, 0x382DE000,
  0x382E0000, 0x382E2000, 0x382E4000, 0x382E6000, 0x382E8000, 0x382EA000, 0x382EC000, 0x382EE000, 0x382F0000, 0x382F2000, 0x382F4000, 0x382F6000, 0x382F8000, 0x382FA000, 0x382FC000, 0x382FE000,
  0x38300000, 0x38302000, 0x38304000, 0x38306000, 0x38308000, 0x3830A000, 0x3830C000, 0x3830E000, 0x38310000, 0x38312000, 0x38314000, 0x38316000, 0x38318000, 0x3831A000, 0x3831C000, 0x3831E000,
  0x38320000, 0x38322000, 0x38324000, 0x38326000, 0x38328000, 0x3832A000, 0x3832C000, 0x3832E000, 0x38330000, 0x38332000, 0x38334000, 0x38336000, 0x38338000, 0x3833A000, 0x3833C000, 0x3833E000,
  0x38340000, 0x38342000, 0x38344000, 0x38346000, 0x38348000, 0x3834A000, 0x3834C000, 0x3834E000, 0x38350000, 0x38352000, 0x38354000, 0x38356000, 0x38358000, 0x3835A000, 0x3835C000, 0x3835E000,
  0x38360000, 0x38362000, 0x38364000, 0x38366000, 0x38368000, 0x3836A000, 0x3836C000, 0x3836E000, 0x38370000, 0x38372000, 0x38374000, 0x38376000, 0x38378000, 0x3837A000, 0x3837C000, 0x3837E000,
  0x38380000, 0x38382000, 0x38384000, 0x38386000, 0x38388000, 0x3838A000, 0x3838C000, 0x3838E000, 0x38390000, 0x38392000, 0x38394000, 0x38396000, 0x38398000, 0x3839A000, 0x3839C000, 0x3839E000,
  0x383A0000, 0x383A2000, 0x383A4000, 0x383A6000, 0x383A8000, 0x383AA000, 0x383AC000, 0x383AE000, 0x383B0000, 0x383B2000, 0x383B4000, 0x383B6000, 0x383B8000, 0x383BA000, 0x383BC000, 0x383BE000,
  0x383C0000, 0x383C2000, 0x383C4000, 0x383C6000, 0x383C8000, 0x383CA000, 0x383CC000, 0x383CE000, 0x383D0000, 0x383D2000, 0x383D4000, 0x383D6000, 0x383D8000, 0x383DA000, 0x383DC000, 0x383DE000,
  0x383E0000, 0x383E2000, 0x383E4000, 0x383E6000, 0x383E8000, 0x383EA000, 0x383EC000, 0x383EE000, 0x383F0000, 0x383F2000, 0x383F4000, 0x383F6000, 0x383F8000, 0x383FA000, 0x383FC000, 0x383FE000,
  0x38400000, 0x38402000, 0x38404000, 0x38406000, 0x38408000, 0x3840A000, 0x3840C000, 0x3840E000, 0x38410000, 0x38412000, 0x38414000, 0x38416000, 0x38418000, 0x3841A000, 0x3841C000, 0x3841E000,
  0x38420000, 0x38422000, 0x38424000, 0x38426000, 0x38428000, 0x3842A000, 0x3842C000, 0x3842E000, 0x38430000, 0x38432000, 0x38434000, 0x38436000, 0x38438000, 0x3843A000, 0x3843C000, 0x3843E000,
  0x38440000, 0x38442000, 0x38444000, 0x38446000, 0x38448000, 0x3844A000, 0x3844C000, 0x3844E000, 0x38450000, 0x38452000, 0x38454000, 0x38456000, 0x38458000, 0x3845A000, 0x3845C000, 0x3845E000,
  0x38460000, 0x38462000, 0x38464000, 0x38466000, 0x38468000, 0x3846A000, 0x3846C000, 0x3846E000, 0x38470000, 0x38472000, 0x38474000, 0x38476000, 0x38478000, 0x3847A000, 0x3847C000, 0x3847E000,
  0x38480000, 0x38482000, 0x38484000, 0x38486000, 0x38488000, 0x3848A000, 0x3848C000, 0x3848E000, 0x38490000, 0x38492000, 0x38494000, 0x38496000, 0x38498000, 0x3849A000, 0x3849C000, 0x3849E000,
  0x384A0000, 0x384A2000, 0x384A4000, 0x384A6000, 0x384A8000, 0x384AA000, 0x384AC000, 0x384AE000, 0x384B0000, 0x384B2000, 0x384B4000, 0x384B6000, 0x384B8000, 0x384BA000, 0x384BC000, 0x384BE000,
  0x384C0000, 0x384C2000, 0x384C4000, 0x384C6000, 0x384C8000, 0x384CA000, 0x384CC000, 0x384CE000, 0x384D0000, 0x384D2000, 0x384D4000, 0x384D6000, 0x384D8000, 0x384DA000, 0x384DC000, 0x384DE000,
  0x384E0000, 0x384E2000, 0x384E4000, 0x384E6000, 0x384E8000, 0x384EA000, 0x384EC000, 0x384EE000, 0x384F0000, 0x384F2000, 0x384F4000, 0x384F6000, 0x384F8000, 0x384FA000, 0x384FC000, 0x384FE000,
  0x38500000, 0x38502000, 0x38504000, 0x38506000, 0x38508000, 0x3850A000, 0x3850C000, 0x3850E000, 0x38510000, 0x38512000, 0x38514000, 0x38516000, 0x38518000, 0x3851A000, 0x3851C000, 0x3851E000,
  0x38520000, 0x38522000, 0x38524000, 0x38526000, 0x38528000, 0x3852A000, 0x3852C000, 0x3852E000, 0x38530000, 0x38532000, 0x38534000, 0x38536000, 0x38538000, 0x3853A000, 0x3853C000, 0x3853E000,
  0x38540000, 0x38542000, 0x38544000, 0x38546000, 0x38548000, 0x3854A000, 0x3854C000, 0x3854E000, 0x38550000, 0x38552000, 0x38554000, 0x38556000, 0x38558000, 0x3855A000, 0x3855C000, 0x3855E000,
  0x38560000, 0x38562000, 0x38564000, 0x38566000, 0x38568000, 0x3856A000, 0x3856C000, 0x3856E000, 0x38570000, 0x38572000, 0x38574000, 0x38576000, 0x38578000, 0x3857A000, 0x3857C000, 0x3857E000,
  0x38580000, 0x38582000, 0x38584000, 0x38586000, 0x38588000, 0x3858A000, 0x3858C000, 0x3858E000, 0x38590000, 0x38592000, 0x38594000, 0x38596000, 0x38598000, 0x3859A000, 0x3859C000, 0x3859E000,
  0x385A0000, 0x385A2000, 0x385A4000, 0x385A6000, 0x385A8000, 0x385AA000, 0x385AC000, 0x385AE000, 0x385B0000, 0x385B2000, 0x385B4000, 0x385B6000, 0x385B8000, 0x385BA000, 0x385BC000, 0x385BE000,
  0x385C0000, 0x385C2000, 0x385C4000, 0x385C6000, 0x385C8000, 0x385CA000, 0x385CC000, 0x385CE000, 0x385D0000, 0x385D2000, 0x385D4000, 0x385D6000, 0x385D8000, 0x385DA000, 0x385DC000, 0x385DE000,
  0x385E0000, 0x385E2000, 0x385E4000, 0x385E6000, 0x385E8000, 0x385EA000, 0x385EC000, 0x385EE000, 0x385F0000, 0x385F2000, 0x385F4000, 0x385F6000, 0x385F8000, 0x385FA000, 0x385FC000, 0x385FE000,
  0x38600000, 0x38602000, 0x38604000, 0x38606000, 0x38608000, 0x3860A000, 0x3860C000, 0x3860E000, 0x38610000, 0x38612000, 0x38614000, 0x38616000, 0x38618000, 0x3861A000, 0x3861C000, 0x3861E000,
  0x38620000, 0x38622000, 0x38624000, 0x38626000, 0x38628000, 0x3862A000, 0x3862C000, 0x3862E000, 0x38630000, 0x38632000, 0x38634000, 0x38636000, 0x38638000, 0x3863A000, 0x3863C000, 0x3863E000,
  0x38640000, 0x38642000, 0x38644000, 0x38646000, 0x38648000, 0x3864A000, 0x3864C000, 0x3864E000, 0x38650000, 0x38652000, 0x38654000, 0x38656000, 0x38658000, 0x3865A000, 0x3865C000, 0x3865E000,
  0x38660000, 0x38662000, 0x38664000, 0x38666000, 0x38668000, 0x3866A000, 0x3866C000, 0x3866E000, 0x38670000, 0x38672000, 0x38674000, 0x38676000, 0x38678000, 0x3867A000, 0x3867C000, 0x3867E000,
  0x38680000, 0x38682000, 0x38684000, 0x38686000, 0x38688000, 0x3868A000, 0x3868C000, 0x3868E000, 0x38690000, 0x38692000, 0x38694000, 0x38696000, 0x38698000, 0x3869A000, 0x3869C000, 0x3869E000,
  0x386A0000, 0x386A2000, 0x386A4000, 0x386A6000, 0x386A8000, 0x386AA000, 0x386AC000, 0x386AE000, 0x386B0000, 0x386B2000, 0x386B4000, 0x386B6000, 0x386B8000, 0x386BA000, 0x386BC000, 0x386BE000,
  0x386C0000, 0x386C2000, 0x386C4000, 0x386C6000, 0x386C8000, 0x386CA000, 0x386CC000, 0x386CE000, 0x386D0000, 0x386D2000, 0x386D4000, 0x386D6000, 0x386D8000, 0x386DA000, 0x386DC000, 0x386DE000,
  0x386E0000, 0x386E2000, 0x386E4000, 0x386E6000, 0x386E8000, 0x386EA000, 0x386EC000, 0x386EE000, 0x386F0000, 0x386F2000, 0x386F4000, 0x386F6000, 0x386F8000, 0x386FA000, 0x386FC000, 0x386FE000,
  0x38700000, 0x38702000, 0x38704000, 0x38706000, 0x38708000, 0x3870A000, 0x3870C000, 0x3870E000, 0x38710000, 0x38712000, 0x38714000, 0x38716000, 0x38718000, 0x3871A000, 0x3871C000, 0x3871E000,
  0x38720000, 0x38722000, 0x38724000, 0x38726000, 0x38728000, 0x3872A000, 0x3872C000, 0x3872E000, 0x38730000, 0x38732000, 0x38734000, 0x38736000, 0x38738000, 0x3873A000, 0x3873C000, 0x3873E000,
  0x38740000, 0x38742000, 0x38744000, 0x38746000, 0x38748000, 0x3874A000, 0x3874C000, 0x3874E000, 0x38750000, 0x38752000, 0x38754000, 0x38756000, 0x38758000, 0x3875A000, 0x3875C000, 0x3875E000,
  0x38760000, 0x38762000, 0x38764000, 0x38766000, 0x38768000, 0x3876A000, 0x3876C000, 0x3876E000, 0x38770000, 0x38772000, 0x38774000, 0x38776000, 0x38778000, 0x3877A000, 0x3877C000, 0x3877E000,
  0x38780000, 0x38782000, 0x38784000, 0x38786000, 0x38788000, 0x3878A000, 0x3878C000, 0x3878E000, 0x38790000, 0x38792000, 0x38794000, 0x38796000, 0x38798000, 0x3879A000, 0x3879C000, 0x3879E000,
  0x387A0000, 0x387A2000, 0x387A4000, 0x387A6000, 0x387A8000, 0x387AA000, 0x387AC000, 0x387AE000, 0x387B0000, 0x387B2000, 0x387B4000, 0x387B6000, 0x387B8000, 0x387BA000, 0x387BC000, 0x387BE000,
  0x387C0000, 0x387C2000, 0x387C4000, 0x387C6000, 0x387C8000, 0x387CA000, 0x387CC000, 0x387CE000, 0x387D0000, 0x387D2000, 0x387D4000, 0x387D6000, 0x387D8000, 0x387DA000, 0x387DC000, 0x387DE000,
  0x387E0000, 0x387E2000, 0x387E4000, 0x387E6000, 0x387E8000, 0x387EA000, 0x387EC000, 0x387EE000, 0x387F0000, 0x387F2000, 0x387F4000, 0x387F6000, 0x387F8000, 0x387FA000, 0x387FC000, 0x387FE000 };
__constant static const uint32_t exponent_table[64] = {
  0x00000000, 0x00800000, 0x01000000, 0x01800000, 0x02000000, 0x02800000, 0x03000000, 0x03800000, 0x04000000, 0x04800000, 0x05000000, 0x05800000, 0x06000000, 0x06800000, 0x07000000, 0x07800000,
  0x08000000, 0x08800000, 0x09000000, 0x09800000, 0x0A000000, 0x0A800000, 0x0B000000, 0x0B800000, 0x0C000000, 0x0C800000, 0x0D000000, 0x0D800000, 0x0E000000, 0x0E800000, 0x0F000000, 0x47800000,
  0x80000000, 0x80800000, 0x81000000, 0x81800000, 0x82000000, 0x82800000, 0x83000000, 0x83800000, 0x84000000, 0x84800000, 0x85000000, 0x85800000, 0x86000000, 0x86800000, 0x87000000, 0x87800000,
  0x88000000, 0x88800000, 0x89000000, 0x89800000, 0x8A000000, 0x8A800000, 0x8B000000, 0x8B800000, 0x8C000000, 0x8C800000, 0x8D000000, 0x8D800000, 0x8E000000, 0x8E800000, 0x8F000000, 0xC7800000 };
__constant static const unsigned short offset_table[64] = {
  0, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024,
  0, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024 };

static uint16_t float2halfbits(float value) {
  union { float x; uint32_t y; } u;
  u.x = value;
  uint32_t bits = u.y;

  uint16_t hbits = base_table[bits>>23] + (uint16_t)((bits&0x7FFFFF)>>shift_table[bits>>23]);;

  return hbits;
}

static float halfbits2float(uint16_t value) {
  uint32_t bits = mantissa_table[offset_table[value>>10]+(value&0x3FF)] + exponent_table[value>>10];

  union { uint32_t x; float y; } u;
  u.x = bits;
  return u.y;
}

// End of half.h.
// Start of timing.h.

// The function get_wall_time() returns the wall time in microseconds
// (with an unspecified offset).

#ifdef _WIN32

#include <windows.h>

static int64_t get_wall_time(void) {
  LARGE_INTEGER time,freq;
  assert(QueryPerformanceFrequency(&freq));
  assert(QueryPerformanceCounter(&time));
  return ((double)time.QuadPart / freq.QuadPart) * 1000000;
}

#else
// Assuming POSIX

#include <time.h>
#include <sys/time.h>

static int64_t get_wall_time(void) {
  struct timeval time;
  assert(gettimeofday(&time,NULL) == 0);
  return time.tv_sec * 1000000 + time.tv_usec;
}

static int64_t get_wall_time_ns(void) {
  struct timespec time;
  assert(clock_gettime(CLOCK_REALTIME, &time) == 0);
  return time.tv_sec * 1000000000 + time.tv_nsec;
}

#endif

// End of timing.h.
#include <getopt.h>
#include <ctype.h>
#include <inttypes.h>
#include <unistd.h>
// Start of values.h.

//// Text I/O

typedef int (*writer)(FILE*, const void*);
typedef int (*bin_reader)(void*);
typedef int (*str_reader)(const char *, void*);

struct array_reader {
  char* elems;
  int64_t n_elems_space;
  int64_t elem_size;
  int64_t n_elems_used;
  int64_t *shape;
  str_reader elem_reader;
};

static void skipspaces(FILE *f) {
  int c;
  do {
    c = getc(f);
  } while (isspace(c));

  if (c != EOF) {
    ungetc(c, f);
  }
}

static int constituent(char c) {
  return isalnum(c) || c == '.' || c == '-' || c == '+' || c == '_';
}

// Produces an empty token only on EOF.
static void next_token(FILE *f, char *buf, int bufsize) {
 start:
  skipspaces(f);

  int i = 0;
  while (i < bufsize) {
    int c = getc(f);
    buf[i] = (char)c;

    if (c == EOF) {
      buf[i] = 0;
      return;
    } else if (c == '-' && i == 1 && buf[0] == '-') {
      // Line comment, so skip to end of line and start over.
      for (; c != '\n' && c != EOF; c = getc(f));
      goto start;
    } else if (!constituent((char)c)) {
      if (i == 0) {
        // We permit single-character tokens that are not
        // constituents; this lets things like ']' and ',' be
        // tokens.
        buf[i+1] = 0;
        return;
      } else {
        ungetc(c, f);
        buf[i] = 0;
        return;
      }
    }

    i++;
  }

  buf[bufsize-1] = 0;
}

static int next_token_is(FILE *f, char *buf, int bufsize, const char* expected) {
  next_token(f, buf, bufsize);
  return strcmp(buf, expected) == 0;
}

static void remove_underscores(char *buf) {
  char *w = buf;

  for (char *r = buf; *r; r++) {
    if (*r != '_') {
      *w++ = *r;
    }
  }

  *w++ = 0;
}

static int read_str_elem(char *buf, struct array_reader *reader) {
  int ret;
  if (reader->n_elems_used == reader->n_elems_space) {
    reader->n_elems_space *= 2;
    reader->elems = (char*) realloc(reader->elems,
                                    (size_t)(reader->n_elems_space * reader->elem_size));
  }

  ret = reader->elem_reader(buf, reader->elems + reader->n_elems_used * reader->elem_size);

  if (ret == 0) {
    reader->n_elems_used++;
  }

  return ret;
}

static int read_str_array_elems(FILE *f,
                                char *buf, int bufsize,
                                struct array_reader *reader, int64_t dims) {
  int ret;
  int first = 1;
  char *knows_dimsize = (char*) calloc((size_t)dims, sizeof(char));
  int cur_dim = (int)dims-1;
  int64_t *elems_read_in_dim = (int64_t*) calloc((size_t)dims, sizeof(int64_t));

  while (1) {
    next_token(f, buf, bufsize);

    if (strcmp(buf, "]") == 0) {
      if (knows_dimsize[cur_dim]) {
        if (reader->shape[cur_dim] != elems_read_in_dim[cur_dim]) {
          ret = 1;
          break;
        }
      } else {
        knows_dimsize[cur_dim] = 1;
        reader->shape[cur_dim] = elems_read_in_dim[cur_dim];
      }
      if (cur_dim == 0) {
        ret = 0;
        break;
      } else {
        cur_dim--;
        elems_read_in_dim[cur_dim]++;
      }
    } else if (strcmp(buf, ",") == 0) {
      next_token(f, buf, bufsize);
      if (strcmp(buf, "[") == 0) {
        if (cur_dim == dims - 1) {
          ret = 1;
          break;
        }
        first = 1;
        cur_dim++;
        elems_read_in_dim[cur_dim] = 0;
      } else if (cur_dim == dims - 1) {
        ret = read_str_elem(buf, reader);
        if (ret != 0) {
          break;
        }
        elems_read_in_dim[cur_dim]++;
      } else {
        ret = 1;
        break;
      }
    } else if (strlen(buf) == 0) {
      // EOF
      ret = 1;
      break;
    } else if (first) {
      if (strcmp(buf, "[") == 0) {
        if (cur_dim == dims - 1) {
          ret = 1;
          break;
        }
        cur_dim++;
        elems_read_in_dim[cur_dim] = 0;
      } else {
        ret = read_str_elem(buf, reader);
        if (ret != 0) {
          break;
        }
        elems_read_in_dim[cur_dim]++;
        first = 0;
      }
    } else {
      ret = 1;
      break;
    }
  }

  free(knows_dimsize);
  free(elems_read_in_dim);
  return ret;
}

static int read_str_empty_array(FILE *f, char *buf, int bufsize,
                                const char *type_name, int64_t *shape, int64_t dims) {
  if (strlen(buf) == 0) {
    // EOF
    return 1;
  }

  if (strcmp(buf, "empty") != 0) {
    return 1;
  }

  if (!next_token_is(f, buf, bufsize, "(")) {
    return 1;
  }

  for (int i = 0; i < dims; i++) {
    if (!next_token_is(f, buf, bufsize, "[")) {
      return 1;
    }

    next_token(f, buf, bufsize);

    if (sscanf(buf, "%"SCNu64, (uint64_t*)&shape[i]) != 1) {
      return 1;
    }

    if (!next_token_is(f, buf, bufsize, "]")) {
      return 1;
    }
  }

  if (!next_token_is(f, buf, bufsize, type_name)) {
    return 1;
  }


  if (!next_token_is(f, buf, bufsize, ")")) {
    return 1;
  }

  // Check whether the array really is empty.
  for (int i = 0; i < dims; i++) {
    if (shape[i] == 0) {
      return 0;
    }
  }

  // Not an empty array!
  return 1;
}

static int read_str_array(FILE *f,
                          int64_t elem_size, str_reader elem_reader,
                          const char *type_name,
                          void **data, int64_t *shape, int64_t dims) {
  int ret;
  struct array_reader reader;
  char buf[100];

  int dims_seen;
  for (dims_seen = 0; dims_seen < dims; dims_seen++) {
    if (!next_token_is(f, buf, sizeof(buf), "[")) {
      break;
    }
  }

  if (dims_seen == 0) {
    return read_str_empty_array(f, buf, sizeof(buf), type_name, shape, dims);
  }

  if (dims_seen != dims) {
    return 1;
  }

  reader.shape = shape;
  reader.n_elems_used = 0;
  reader.elem_size = elem_size;
  reader.n_elems_space = 16;
  reader.elems = (char*) realloc(*data, (size_t)(elem_size*reader.n_elems_space));
  reader.elem_reader = elem_reader;

  ret = read_str_array_elems(f, buf, sizeof(buf), &reader, dims);

  *data = reader.elems;

  return ret;
}

#define READ_STR(MACRO, PTR, SUFFIX)                                   \
  remove_underscores(buf);                                              \
  int j;                                                                \
  if (sscanf(buf, "%"MACRO"%n", (PTR*)dest, &j) == 1) {                 \
    return !(strcmp(buf+j, "") == 0 || strcmp(buf+j, SUFFIX) == 0);     \
  } else {                                                              \
    return 1;                                                           \
  }

static int read_str_i8(char *buf, void* dest) {
  // Some platforms (WINDOWS) does not support scanf %hhd or its
  // cousin, %SCNi8.  Read into int first to avoid corrupting
  // memory.
  //
  // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=63417
  remove_underscores(buf);
  int j, x;
  if (sscanf(buf, "%i%n", &x, &j) == 1) {
    *(int8_t*)dest = (int8_t)x;
    return !(strcmp(buf+j, "") == 0 || strcmp(buf+j, "i8") == 0);
  } else {
    return 1;
  }
}

static int read_str_u8(char *buf, void* dest) {
  // Some platforms (WINDOWS) does not support scanf %hhd or its
  // cousin, %SCNu8.  Read into int first to avoid corrupting
  // memory.
  //
  // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=63417
  remove_underscores(buf);
  int j, x;
  if (sscanf(buf, "%i%n", &x, &j) == 1) {
    *(uint8_t*)dest = (uint8_t)x;
    return !(strcmp(buf+j, "") == 0 || strcmp(buf+j, "u8") == 0);
  } else {
    return 1;
  }
}

static int read_str_i16(char *buf, void* dest) {
  READ_STR(SCNi16, int16_t, "i16");
}

static int read_str_u16(char *buf, void* dest) {
  READ_STR(SCNi16, int16_t, "u16");
}

static int read_str_i32(char *buf, void* dest) {
  READ_STR(SCNi32, int32_t, "i32");
}

static int read_str_u32(char *buf, void* dest) {
  READ_STR(SCNi32, int32_t, "u32");
}

static int read_str_i64(char *buf, void* dest) {
  READ_STR(SCNi64, int64_t, "i64");
}

static int read_str_u64(char *buf, void* dest) {
  // FIXME: This is not correct, as SCNu64 only permits decimal
  // literals.  However, SCNi64 does not handle very large numbers
  // correctly (it's really for signed numbers, so that's fair).
  READ_STR(SCNu64, uint64_t, "u64");
}

static int read_str_f16(char *buf, void* dest) {
  remove_underscores(buf);
  if (strcmp(buf, "f16.nan") == 0) {
    *(uint16_t*)dest = float2halfbits(NAN);
    return 0;
  } else if (strcmp(buf, "f16.inf") == 0) {
    *(uint16_t*)dest = float2halfbits(INFINITY);
    return 0;
  } else if (strcmp(buf, "-f16.inf") == 0) {
    *(uint16_t*)dest = float2halfbits(-INFINITY);
    return 0;
  } else {
    int j;
    float x;
    if (sscanf(buf, "%f%n", &x, &j) == 1) {
      if (strcmp(buf+j, "") == 0 || strcmp(buf+j, "f16") == 0) {
        *(uint16_t*)dest = float2halfbits(x);
        return 0;
      }
    }
    return 1;
  }
}

static int read_str_f32(char *buf, void* dest) {
  remove_underscores(buf);
  if (strcmp(buf, "f32.nan") == 0) {
    *(float*)dest = (float)NAN;
    return 0;
  } else if (strcmp(buf, "f32.inf") == 0) {
    *(float*)dest = (float)INFINITY;
    return 0;
  } else if (strcmp(buf, "-f32.inf") == 0) {
    *(float*)dest = (float)-INFINITY;
    return 0;
  } else {
    READ_STR("f", float, "f32");
  }
}

static int read_str_f64(char *buf, void* dest) {
  remove_underscores(buf);
  if (strcmp(buf, "f64.nan") == 0) {
    *(double*)dest = (double)NAN;
    return 0;
  } else if (strcmp(buf, "f64.inf") == 0) {
    *(double*)dest = (double)INFINITY;
    return 0;
  } else if (strcmp(buf, "-f64.inf") == 0) {
    *(double*)dest = (double)-INFINITY;
    return 0;
  } else {
    READ_STR("lf", double, "f64");
  }
}

static int read_str_bool(char *buf, void* dest) {
  if (strcmp(buf, "true") == 0) {
    *(char*)dest = 1;
    return 0;
  } else if (strcmp(buf, "false") == 0) {
    *(char*)dest = 0;
    return 0;
  } else {
    return 1;
  }
}

static int write_str_i8(FILE *out, int8_t *src) {
  return fprintf(out, "%hhdi8", *src);
}

static int write_str_u8(FILE *out, uint8_t *src) {
  return fprintf(out, "%hhuu8", *src);
}

static int write_str_i16(FILE *out, int16_t *src) {
  return fprintf(out, "%hdi16", *src);
}

static int write_str_u16(FILE *out, uint16_t *src) {
  return fprintf(out, "%huu16", *src);
}

static int write_str_i32(FILE *out, int32_t *src) {
  return fprintf(out, "%di32", *src);
}

static int write_str_u32(FILE *out, uint32_t *src) {
  return fprintf(out, "%uu32", *src);
}

static int write_str_i64(FILE *out, int64_t *src) {
  return fprintf(out, "%"PRIi64"i64", *src);
}

static int write_str_u64(FILE *out, uint64_t *src) {
  return fprintf(out, "%"PRIu64"u64", *src);
}

static int write_str_f16(FILE *out, uint16_t *src) {
  float x = halfbits2float(*src);
  if (isnan(x)) {
    return fprintf(out, "f16.nan");
  } else if (isinf(x) && x >= 0) {
    return fprintf(out, "f16.inf");
  } else if (isinf(x)) {
    return fprintf(out, "-f16.inf");
  } else {
    return fprintf(out, "%.6ff16", x);
  }
}

static int write_str_f32(FILE *out, float *src) {
  float x = *src;
  if (isnan(x)) {
    return fprintf(out, "f32.nan");
  } else if (isinf(x) && x >= 0) {
    return fprintf(out, "f32.inf");
  } else if (isinf(x)) {
    return fprintf(out, "-f32.inf");
  } else {
    return fprintf(out, "%.6ff32", x);
  }
}

static int write_str_f64(FILE *out, double *src) {
  double x = *src;
  if (isnan(x)) {
    return fprintf(out, "f64.nan");
  } else if (isinf(x) && x >= 0) {
    return fprintf(out, "f64.inf");
  } else if (isinf(x)) {
    return fprintf(out, "-f64.inf");
  } else {
    return fprintf(out, "%.6ff64", *src);
  }
}

static int write_str_bool(FILE *out, void *src) {
  return fprintf(out, *(char*)src ? "true" : "false");
}

//// Binary I/O

#define BINARY_FORMAT_VERSION 2
#define IS_BIG_ENDIAN (!*(unsigned char *)&(uint16_t){1})

static void flip_bytes(size_t elem_size, unsigned char *elem) {
  for (size_t j=0; j<elem_size/2; j++) {
    unsigned char head = elem[j];
    size_t tail_index = elem_size-1-j;
    elem[j] = elem[tail_index];
    elem[tail_index] = head;
  }
}

// On Windows we need to explicitly set the file mode to not mangle
// newline characters.  On *nix there is no difference.
#ifdef _WIN32
#include <io.h>
#include <fcntl.h>
static void set_binary_mode(FILE *f) {
  setmode(fileno(f), O_BINARY);
}
#else
static void set_binary_mode(FILE *f) {
  (void)f;
}
#endif

static int read_byte(FILE *f, void* dest) {
  size_t num_elems_read = fread(dest, 1, 1, f);
  return num_elems_read == 1 ? 0 : 1;
}

//// Types

struct primtype_info_t {
  const char binname[4]; // Used for parsing binary data.
  const char* type_name; // Same name as in Futhark.
  const int64_t size; // in bytes
  const writer write_str; // Write in text format.
  const str_reader read_str; // Read in text format.
};

static const struct primtype_info_t i8_info =
  {.binname = "  i8", .type_name = "i8",   .size = 1,
   .write_str = (writer)write_str_i8, .read_str = (str_reader)read_str_i8};
static const struct primtype_info_t i16_info =
  {.binname = " i16", .type_name = "i16",  .size = 2,
   .write_str = (writer)write_str_i16, .read_str = (str_reader)read_str_i16};
static const struct primtype_info_t i32_info =
  {.binname = " i32", .type_name = "i32",  .size = 4,
   .write_str = (writer)write_str_i32, .read_str = (str_reader)read_str_i32};
static const struct primtype_info_t i64_info =
  {.binname = " i64", .type_name = "i64",  .size = 8,
   .write_str = (writer)write_str_i64, .read_str = (str_reader)read_str_i64};
static const struct primtype_info_t u8_info =
  {.binname = "  u8", .type_name = "u8",   .size = 1,
   .write_str = (writer)write_str_u8, .read_str = (str_reader)read_str_u8};
static const struct primtype_info_t u16_info =
  {.binname = " u16", .type_name = "u16",  .size = 2,
   .write_str = (writer)write_str_u16, .read_str = (str_reader)read_str_u16};
static const struct primtype_info_t u32_info =
  {.binname = " u32", .type_name = "u32",  .size = 4,
   .write_str = (writer)write_str_u32, .read_str = (str_reader)read_str_u32};
static const struct primtype_info_t u64_info =
  {.binname = " u64", .type_name = "u64",  .size = 8,
   .write_str = (writer)write_str_u64, .read_str = (str_reader)read_str_u64};
static const struct primtype_info_t f16_info =
  {.binname = " f16", .type_name = "f16",  .size = 2,
   .write_str = (writer)write_str_f16, .read_str = (str_reader)read_str_f16};
static const struct primtype_info_t f32_info =
  {.binname = " f32", .type_name = "f32",  .size = 4,
   .write_str = (writer)write_str_f32, .read_str = (str_reader)read_str_f32};
static const struct primtype_info_t f64_info =
  {.binname = " f64", .type_name = "f64",  .size = 8,
   .write_str = (writer)write_str_f64, .read_str = (str_reader)read_str_f64};
static const struct primtype_info_t bool_info =
  {.binname = "bool", .type_name = "bool", .size = 1,
   .write_str = (writer)write_str_bool, .read_str = (str_reader)read_str_bool};

static const struct primtype_info_t* primtypes[] = {
  &i8_info, &i16_info, &i32_info, &i64_info,
  &u8_info, &u16_info, &u32_info, &u64_info,
  &f16_info, &f32_info, &f64_info,
  &bool_info,
  NULL // NULL-terminated
};

// General value interface.  All endian business taken care of at
// lower layers.

static int read_is_binary(FILE *f) {
  skipspaces(f);
  int c = getc(f);
  if (c == 'b') {
    int8_t bin_version;
    int ret = read_byte(f, &bin_version);

    if (ret != 0) { futhark_panic(1, "binary-input: could not read version.\n"); }

    if (bin_version != BINARY_FORMAT_VERSION) {
      futhark_panic(1, "binary-input: File uses version %i, but I only understand version %i.\n",
            bin_version, BINARY_FORMAT_VERSION);
    }

    return 1;
  }
  ungetc(c, f);
  return 0;
}

static const struct primtype_info_t* read_bin_read_type_enum(FILE *f) {
  char read_binname[4];

  int num_matched = fscanf(f, "%4c", read_binname);
  if (num_matched != 1) { futhark_panic(1, "binary-input: Couldn't read element type.\n"); }

  const struct primtype_info_t **type = primtypes;

  for (; *type != NULL; type++) {
    // I compare the 4 characters manually instead of using strncmp because
    // this allows any value to be used, also NULL bytes
    if (memcmp(read_binname, (*type)->binname, 4) == 0) {
      return *type;
    }
  }
  futhark_panic(1, "binary-input: Did not recognize the type '%s'.\n", read_binname);
  return NULL;
}

static void read_bin_ensure_scalar(FILE *f, const struct primtype_info_t *expected_type) {
  int8_t bin_dims;
  int ret = read_byte(f, &bin_dims);
  if (ret != 0) { futhark_panic(1, "binary-input: Couldn't get dims.\n"); }

  if (bin_dims != 0) {
    futhark_panic(1, "binary-input: Expected scalar (0 dimensions), but got array with %i dimensions.\n",
          bin_dims);
  }

  const struct primtype_info_t *bin_type = read_bin_read_type_enum(f);
  if (bin_type != expected_type) {
    futhark_panic(1, "binary-input: Expected scalar of type %s but got scalar of type %s.\n",
          expected_type->type_name,
          bin_type->type_name);
  }
}

//// High-level interface

static int read_bin_array(FILE *f,
                          const struct primtype_info_t *expected_type, void **data, int64_t *shape, int64_t dims) {
  int ret;

  int8_t bin_dims;
  ret = read_byte(f, &bin_dims);
  if (ret != 0) { futhark_panic(1, "binary-input: Couldn't get dims.\n"); }

  if (bin_dims != dims) {
    futhark_panic(1, "binary-input: Expected %i dimensions, but got array with %i dimensions.\n",
          dims, bin_dims);
  }

  const struct primtype_info_t *bin_primtype = read_bin_read_type_enum(f);
  if (expected_type != bin_primtype) {
    futhark_panic(1, "binary-input: Expected %iD-array with element type '%s' but got %iD-array with element type '%s'.\n",
          dims, expected_type->type_name, dims, bin_primtype->type_name);
  }

  int64_t elem_count = 1;
  for (int i=0; i<dims; i++) {
    int64_t bin_shape;
    ret = (int)fread(&bin_shape, sizeof(bin_shape), 1, f);
    if (ret != 1) {
      futhark_panic(1, "binary-input: Couldn't read size for dimension %i of array.\n", i);
    }
    if (IS_BIG_ENDIAN) {
      flip_bytes(sizeof(bin_shape), (unsigned char*) &bin_shape);
    }
    elem_count *= bin_shape;
    shape[i] = bin_shape;
  }

  int64_t elem_size = expected_type->size;
  void* tmp = realloc(*data, (size_t)(elem_count * elem_size));
  if (tmp == NULL) {
    futhark_panic(1, "binary-input: Failed to allocate array of size %i.\n",
          elem_count * elem_size);
  }
  *data = tmp;

  int64_t num_elems_read = (int64_t)fread(*data, (size_t)elem_size, (size_t)elem_count, f);
  if (num_elems_read != elem_count) {
    futhark_panic(1, "binary-input: tried to read %i elements of an array, but only got %i elements.\n",
          elem_count, num_elems_read);
  }

  // If we're on big endian platform we must change all multibyte elements
  // from using little endian to big endian
  if (IS_BIG_ENDIAN && elem_size != 1) {
    flip_bytes((size_t)elem_size, (unsigned char*) *data);
  }

  return 0;
}

static int read_array(FILE *f, const struct primtype_info_t *expected_type, void **data, int64_t *shape, int64_t dims) {
  if (!read_is_binary(f)) {
    return read_str_array(f, expected_type->size, (str_reader)expected_type->read_str, expected_type->type_name, data, shape, dims);
  } else {
    return read_bin_array(f, expected_type, data, shape, dims);
  }
}

static int end_of_input(FILE *f) {
  skipspaces(f);
  char token[2];
  next_token(f, token, sizeof(token));
  if (strcmp(token, "") == 0) {
    return 0;
  } else {
    return 1;
  }
}

static int write_str_array(FILE *out,
                           const struct primtype_info_t *elem_type,
                           const unsigned char *data,
                           const int64_t *shape,
                           int8_t rank) {
  if (rank==0) {
    elem_type->write_str(out, (const void*)data);
  } else {
    int64_t len = (int64_t)shape[0];
    int64_t slice_size = 1;

    int64_t elem_size = elem_type->size;
    for (int8_t i = 1; i < rank; i++) {
      slice_size *= shape[i];
    }

    if (len*slice_size == 0) {
      fprintf(out, "empty(");
      for (int64_t i = 0; i < rank; i++) {
        fprintf(out, "[%"PRIi64"]", shape[i]);
      }
      fprintf(out, "%s", elem_type->type_name);
      fprintf(out, ")");
    } else if (rank==1) {
      fputc('[', out);
      for (int64_t i = 0; i < len; i++) {
        elem_type->write_str(out, (const void*) (data + i * elem_size));
        if (i != len-1) {
          fprintf(out, ", ");
        }
      }
      fputc(']', out);
    } else {
      fputc('[', out);
      for (int64_t i = 0; i < len; i++) {
        write_str_array(out, elem_type, data + i * slice_size * elem_size, shape+1, rank-1);
        if (i != len-1) {
          fprintf(out, ", ");
        }
      }
      fputc(']', out);
    }
  }
  return 0;
}

static int write_bin_array(FILE *out,
                           const struct primtype_info_t *elem_type,
                           const unsigned char *data,
                           const int64_t *shape,
                           int8_t rank) {
  int64_t num_elems = 1;
  for (int64_t i = 0; i < rank; i++) {
    num_elems *= shape[i];
  }

  fputc('b', out);
  fputc((char)BINARY_FORMAT_VERSION, out);
  fwrite(&rank, sizeof(int8_t), 1, out);
  fwrite(elem_type->binname, 4, 1, out);
  if (shape != NULL) {
    fwrite(shape, sizeof(int64_t), (size_t)rank, out);
  }

  if (IS_BIG_ENDIAN) {
    for (int64_t i = 0; i < num_elems; i++) {
      const unsigned char *elem = data+i*elem_type->size;
      for (int64_t j = 0; j < elem_type->size; j++) {
        fwrite(&elem[elem_type->size-j], 1, 1, out);
      }
    }
  } else {
    fwrite(data, (size_t)elem_type->size, (size_t)num_elems, out);
  }

  return 0;
}

static int write_array(FILE *out, int write_binary,
                       const struct primtype_info_t *elem_type,
                       const void *data,
                       const int64_t *shape,
                       const int8_t rank) {
  if (write_binary) {
    return write_bin_array(out, elem_type, data, shape, rank);
  } else {
    return write_str_array(out, elem_type, data, shape, rank);
  }
}

static int read_scalar(FILE *f,
                       const struct primtype_info_t *expected_type, void *dest) {
  if (!read_is_binary(f)) {
    char buf[100];
    next_token(f, buf, sizeof(buf));
    return expected_type->read_str(buf, dest);
  } else {
    read_bin_ensure_scalar(f, expected_type);
    size_t elem_size = (size_t)expected_type->size;
    size_t num_elems_read = fread(dest, elem_size, 1, f);
    if (IS_BIG_ENDIAN) {
      flip_bytes(elem_size, (unsigned char*) dest);
    }
    return num_elems_read == 1 ? 0 : 1;
  }
}

static int write_scalar(FILE *out, int write_binary, const struct primtype_info_t *type, void *src) {
  if (write_binary) {
    return write_bin_array(out, type, src, NULL, 0);
  } else {
    return type->write_str(out, src);
  }
}

// End of values.h.

static int binary_output = 0;
static int print_result = 1;
static FILE *runtime_file;
static int perform_warmup = 0;
static int num_runs = 1;
static const char *entry_point = "main";
// Start of tuning.h.

static char* load_tuning_file(const char *fname,
                              void *cfg,
                              int (*set_tuning_param)(void*, const char*, size_t)) {
  const int max_line_len = 1024;
  char* line = (char*) malloc(max_line_len);

  FILE *f = fopen(fname, "r");

  if (f == NULL) {
    snprintf(line, max_line_len, "Cannot open file: %s", strerror(errno));
    return line;
  }

  int lineno = 0;
  while (fgets(line, max_line_len, f) != NULL) {
    lineno++;
    char *eql = strstr(line, "=");
    if (eql) {
      *eql = 0;
      int value = atoi(eql+1);
      if (set_tuning_param(cfg, line, (size_t)value) != 0) {
        char* err = (char*) malloc(max_line_len + 50);
        snprintf(err, max_line_len + 50, "Unknown name '%s' on line %d.", line, lineno);
        free(line);
        return err;
      }
    } else {
      snprintf(line, max_line_len, "Invalid line %d (must be of form 'name=int').",
               lineno);
      return line;
    }
  }

  free(line);

  return NULL;
}

// End of tuning.h.

int parse_options(struct futhark_context_config *cfg, int argc,
                  char *const argv[])
{
    int ch;
    static struct option long_options[] = {{"write-runtime-to",
                                            required_argument, NULL, 1},
                                           {"runs", required_argument, NULL, 2},
                                           {"debugging", no_argument, NULL, 3},
                                           {"log", no_argument, NULL, 4},
                                           {"entry-point", required_argument,
                                            NULL, 5}, {"binary-output",
                                                       no_argument, NULL, 6},
                                           {"no-print-result", no_argument,
                                            NULL, 7}, {"help", no_argument,
                                                       NULL, 8},
                                           {"print-params", no_argument, NULL,
                                            9}, {"param", required_argument,
                                                 NULL, 10}, {"tuning",
                                                             required_argument,
                                                             NULL, 11}, {0, 0,
                                                                         0, 0}};
    static char *option_descriptions =
                "  -t/--write-runtime-to FILE Print the time taken to execute the program to the indicated file, an integral number of microseconds.\n  -r/--runs INT              Perform NUM runs of the program.\n  -D/--debugging             Perform possibly expensive internal correctness checks and verbose logging.\n  -L/--log                   Print various low-overhead logging information to stderr while running.\n  -e/--entry-point NAME      The entry point to run. Defaults to main.\n  -b/--binary-output         Print the program result in the binary output format.\n  -n/--no-print-result       Do not print the program result.\n  -h/--help                  Print help information and exit.\n  --print-params             Print all tuning parameters that can be set with --param or --tuning.\n  --param ASSIGNMENT         Set a tuning parameter to the given value.\n  --tuning FILE              Read size=value assignments from the given file.\n";
    
    while ((ch = getopt_long(argc, argv, ":t:r:DLe:bnh", long_options, NULL)) !=
           -1) {
        if (ch == 1 || ch == 't') {
            runtime_file = fopen(optarg, "w");
            if (runtime_file == NULL)
                futhark_panic(1, "Cannot open %s: %s\n", optarg,
                              strerror(errno));
        }
        if (ch == 2 || ch == 'r') {
            num_runs = atoi(optarg);
            perform_warmup = 1;
            if (num_runs <= 0)
                futhark_panic(1, "Need a positive number of runs, not %s\n",
                              optarg);
        }
        if (ch == 3 || ch == 'D')
            futhark_context_config_set_debugging(cfg, 1);
        if (ch == 4 || ch == 'L')
            futhark_context_config_set_logging(cfg, 1);
        if (ch == 5 || ch == 'e') {
            if (entry_point != NULL)
                entry_point = optarg;
        }
        if (ch == 6 || ch == 'b')
            binary_output = 1;
        if (ch == 7 || ch == 'n')
            print_result = 0;
        if (ch == 8 || ch == 'h') {
            printf("Usage: %s [OPTION]...\nOptions:\n\n%s\nFor more information, consult the Futhark User's Guide or the man pages.\n",
                   fut_progname, option_descriptions);
            exit(0);
        }
        if (ch == 9) {
            int n = futhark_get_tuning_param_count();
            
            for (int i = 0; i < n; i++)
                printf("%s (%s)\n", futhark_get_tuning_param_name(i),
                       futhark_get_tuning_param_class(i));
            exit(0);
        }
        if (ch == 10) {
            char *name = optarg;
            char *equals = strstr(optarg, "=");
            char *value_str = equals != NULL ? equals + 1 : optarg;
            int value = atoi(value_str);
            
            if (equals != NULL) {
                *equals = 0;
                if (futhark_context_config_set_tuning_param(cfg, name,
                                                            (size_t) value) !=
                    0)
                    futhark_panic(1, "Unknown size: %s\n", name);
            } else
                futhark_panic(1, "Invalid argument for size option: %s\n",
                              optarg);
        }
        if (ch == 11) {
            char *ret = load_tuning_file(optarg, cfg, (int (*)(void *, const
                                                               char *,
                                                               size_t)) futhark_context_config_set_tuning_param);
            
            if (ret != NULL)
                futhark_panic(1, "When loading tuning from '%s': %s\n", optarg,
                              ret);
        }
        if (ch == ':')
            futhark_panic(-1, "Missing argument for option %s\n", argv[optind -
                                                                       1]);
        if (ch == '?') {
            fprintf(stderr, "Usage: %s [OPTIONS]...\nOptions:\n\n%s\n",
                    fut_progname,
                    "  -t/--write-runtime-to FILE Print the time taken to execute the program to the indicated file, an integral number of microseconds.\n  -r/--runs INT              Perform NUM runs of the program.\n  -D/--debugging             Perform possibly expensive internal correctness checks and verbose logging.\n  -L/--log                   Print various low-overhead logging information to stderr while running.\n  -e/--entry-point NAME      The entry point to run. Defaults to main.\n  -b/--binary-output         Print the program result in the binary output format.\n  -n/--no-print-result       Do not print the program result.\n  -h/--help                  Print help information and exit.\n  --print-params             Print all tuning parameters that can be set with --param or --tuning.\n  --param ASSIGNMENT         Set a tuning parameter to the given value.\n  --tuning FILE              Read size=value assignments from the given file.\n");
            futhark_panic(1, "Unknown option: %s\n", argv[optind - 1]);
        }
    }
    return optind;
}
static void futrts_cli_entry_main(struct futhark_context *ctx)
{
    int64_t t_start, t_end;
    int time_runs = 0, profile_run = 0;
    
    // We do not want to profile all the initialisation.
    futhark_context_pause_profiling(ctx);
    // Declare and read input.
    set_binary_mode(stdin);
    
    int32_t read_value_0;
    
    if (read_scalar(stdin, &i32_info, &read_value_0) != 0)
        futhark_panic(1,
                      "Error when reading input #%d of type %s (errno: %s).\n",
                      0, "i32", strerror(errno));
    ;
    
    float read_value_1;
    
    if (read_scalar(stdin, &f32_info, &read_value_1) != 0)
        futhark_panic(1,
                      "Error when reading input #%d of type %s (errno: %s).\n",
                      1, "f32", strerror(errno));
    ;
    
    float read_value_2;
    
    if (read_scalar(stdin, &f32_info, &read_value_2) != 0)
        futhark_panic(1,
                      "Error when reading input #%d of type %s (errno: %s).\n",
                      2, "f32", strerror(errno));
    ;
    
    struct futhark_f32_1d * read_value_3;
    int64_t read_shape_3[1];
    float *read_arr_3 = NULL;
    
    errno = 0;
    if (read_array(stdin, &f32_info, (void **) &read_arr_3, read_shape_3, 1) !=
        0)
        futhark_panic(1, "Cannot read input #%d of type %s (errno: %s).\n", 3,
                      "[]f32", strerror(errno));
    
    struct futhark_f32_1d * read_value_4;
    int64_t read_shape_4[1];
    float *read_arr_4 = NULL;
    
    errno = 0;
    if (read_array(stdin, &f32_info, (void **) &read_arr_4, read_shape_4, 1) !=
        0)
        futhark_panic(1, "Cannot read input #%d of type %s (errno: %s).\n", 4,
                      "[]f32", strerror(errno));
    
    struct futhark_f32_1d * read_value_5;
    int64_t read_shape_5[1];
    float *read_arr_5 = NULL;
    
    errno = 0;
    if (read_array(stdin, &f32_info, (void **) &read_arr_5, read_shape_5, 1) !=
        0)
        futhark_panic(1, "Cannot read input #%d of type %s (errno: %s).\n", 5,
                      "[]f32", strerror(errno));
    
    struct futhark_f32_1d * read_value_6;
    int64_t read_shape_6[1];
    float *read_arr_6 = NULL;
    
    errno = 0;
    if (read_array(stdin, &f32_info, (void **) &read_arr_6, read_shape_6, 1) !=
        0)
        futhark_panic(1, "Cannot read input #%d of type %s (errno: %s).\n", 6,
                      "[]f32", strerror(errno));
    
    struct futhark_f32_1d * read_value_7;
    int64_t read_shape_7[1];
    float *read_arr_7 = NULL;
    
    errno = 0;
    if (read_array(stdin, &f32_info, (void **) &read_arr_7, read_shape_7, 1) !=
        0)
        futhark_panic(1, "Cannot read input #%d of type %s (errno: %s).\n", 7,
                      "[]f32", strerror(errno));
    
    struct futhark_f32_1d * read_value_8;
    int64_t read_shape_8[1];
    float *read_arr_8 = NULL;
    
    errno = 0;
    if (read_array(stdin, &f32_info, (void **) &read_arr_8, read_shape_8, 1) !=
        0)
        futhark_panic(1, "Cannot read input #%d of type %s (errno: %s).\n", 8,
                      "[]f32", strerror(errno));
    
    struct futhark_f32_1d * read_value_9;
    int64_t read_shape_9[1];
    float *read_arr_9 = NULL;
    
    errno = 0;
    if (read_array(stdin, &f32_info, (void **) &read_arr_9, read_shape_9, 1) !=
        0)
        futhark_panic(1, "Cannot read input #%d of type %s (errno: %s).\n", 9,
                      "[]f32", strerror(errno));
    if (end_of_input(stdin) != 0)
        futhark_panic(1,
                      "Expected EOF on stdin after reading input for \"%s\".\n",
                      "main");
    
    struct futhark_f32_1d * result_0;
    struct futhark_f32_1d * result_1;
    struct futhark_f32_1d * result_2;
    struct futhark_f32_1d * result_3;
    struct futhark_f32_1d * result_4;
    struct futhark_f32_1d * result_5;
    struct futhark_f32_1d * result_6;
    
    if (perform_warmup) {
        int r;
        
        ;
        ;
        ;
        assert((read_value_3 = futhark_new_f32_1d(ctx, read_arr_3,
                                                  read_shape_3[0])) != NULL);
        assert((read_value_4 = futhark_new_f32_1d(ctx, read_arr_4,
                                                  read_shape_4[0])) != NULL);
        assert((read_value_5 = futhark_new_f32_1d(ctx, read_arr_5,
                                                  read_shape_5[0])) != NULL);
        assert((read_value_6 = futhark_new_f32_1d(ctx, read_arr_6,
                                                  read_shape_6[0])) != NULL);
        assert((read_value_7 = futhark_new_f32_1d(ctx, read_arr_7,
                                                  read_shape_7[0])) != NULL);
        assert((read_value_8 = futhark_new_f32_1d(ctx, read_arr_8,
                                                  read_shape_8[0])) != NULL);
        assert((read_value_9 = futhark_new_f32_1d(ctx, read_arr_9,
                                                  read_shape_9[0])) != NULL);
        if (futhark_context_sync(ctx) != 0)
            futhark_panic(1, "%s", futhark_context_get_error(ctx));
        ;
        // Only profile last run.
        if (profile_run)
            futhark_context_unpause_profiling(ctx);
        t_start = get_wall_time();
        r = futhark_entry_main(ctx, &result_0, &result_1, &result_2, &result_3,
                               &result_4, &result_5, &result_6, read_value_0,
                               read_value_1, read_value_2, read_value_3,
                               read_value_4, read_value_5, read_value_6,
                               read_value_7, read_value_8, read_value_9);
        if (r != 0)
            futhark_panic(1, "%s", futhark_context_get_error(ctx));
        if (futhark_context_sync(ctx) != 0)
            futhark_panic(1, "%s", futhark_context_get_error(ctx));
        ;
        if (profile_run)
            futhark_context_pause_profiling(ctx);
        t_end = get_wall_time();
        
        long elapsed_usec = t_end - t_start;
        
        if (time_runs && runtime_file != NULL) {
            fprintf(runtime_file, "%lld\n", (long long) elapsed_usec);
            fflush(runtime_file);
        }
        ;
        ;
        ;
        assert(futhark_free_f32_1d(ctx, read_value_3) == 0);
        assert(futhark_free_f32_1d(ctx, read_value_4) == 0);
        assert(futhark_free_f32_1d(ctx, read_value_5) == 0);
        assert(futhark_free_f32_1d(ctx, read_value_6) == 0);
        assert(futhark_free_f32_1d(ctx, read_value_7) == 0);
        assert(futhark_free_f32_1d(ctx, read_value_8) == 0);
        assert(futhark_free_f32_1d(ctx, read_value_9) == 0);
        assert(futhark_free_f32_1d(ctx, result_0) == 0);
        assert(futhark_free_f32_1d(ctx, result_1) == 0);
        assert(futhark_free_f32_1d(ctx, result_2) == 0);
        assert(futhark_free_f32_1d(ctx, result_3) == 0);
        assert(futhark_free_f32_1d(ctx, result_4) == 0);
        assert(futhark_free_f32_1d(ctx, result_5) == 0);
        assert(futhark_free_f32_1d(ctx, result_6) == 0);
    }
    time_runs = 1;
    // Proper run.
    for (int run = 0; run < num_runs; run++) {
        // Only profile last run.
        profile_run = run == num_runs - 1;
        
        int r;
        
        ;
        ;
        ;
        assert((read_value_3 = futhark_new_f32_1d(ctx, read_arr_3,
                                                  read_shape_3[0])) != NULL);
        assert((read_value_4 = futhark_new_f32_1d(ctx, read_arr_4,
                                                  read_shape_4[0])) != NULL);
        assert((read_value_5 = futhark_new_f32_1d(ctx, read_arr_5,
                                                  read_shape_5[0])) != NULL);
        assert((read_value_6 = futhark_new_f32_1d(ctx, read_arr_6,
                                                  read_shape_6[0])) != NULL);
        assert((read_value_7 = futhark_new_f32_1d(ctx, read_arr_7,
                                                  read_shape_7[0])) != NULL);
        assert((read_value_8 = futhark_new_f32_1d(ctx, read_arr_8,
                                                  read_shape_8[0])) != NULL);
        assert((read_value_9 = futhark_new_f32_1d(ctx, read_arr_9,
                                                  read_shape_9[0])) != NULL);
        if (futhark_context_sync(ctx) != 0)
            futhark_panic(1, "%s", futhark_context_get_error(ctx));
        ;
        // Only profile last run.
        if (profile_run)
            futhark_context_unpause_profiling(ctx);
        t_start = get_wall_time();
        r = futhark_entry_main(ctx, &result_0, &result_1, &result_2, &result_3,
                               &result_4, &result_5, &result_6, read_value_0,
                               read_value_1, read_value_2, read_value_3,
                               read_value_4, read_value_5, read_value_6,
                               read_value_7, read_value_8, read_value_9);
        if (r != 0)
            futhark_panic(1, "%s", futhark_context_get_error(ctx));
        if (futhark_context_sync(ctx) != 0)
            futhark_panic(1, "%s", futhark_context_get_error(ctx));
        ;
        if (profile_run)
            futhark_context_pause_profiling(ctx);
        t_end = get_wall_time();
        
        long elapsed_usec = t_end - t_start;
        
        if (time_runs && runtime_file != NULL) {
            fprintf(runtime_file, "%lld\n", (long long) elapsed_usec);
            fflush(runtime_file);
        }
        ;
        ;
        ;
        assert(futhark_free_f32_1d(ctx, read_value_3) == 0);
        assert(futhark_free_f32_1d(ctx, read_value_4) == 0);
        assert(futhark_free_f32_1d(ctx, read_value_5) == 0);
        assert(futhark_free_f32_1d(ctx, read_value_6) == 0);
        assert(futhark_free_f32_1d(ctx, read_value_7) == 0);
        assert(futhark_free_f32_1d(ctx, read_value_8) == 0);
        assert(futhark_free_f32_1d(ctx, read_value_9) == 0);
        if (run < num_runs - 1) {
            assert(futhark_free_f32_1d(ctx, result_0) == 0);
            assert(futhark_free_f32_1d(ctx, result_1) == 0);
            assert(futhark_free_f32_1d(ctx, result_2) == 0);
            assert(futhark_free_f32_1d(ctx, result_3) == 0);
            assert(futhark_free_f32_1d(ctx, result_4) == 0);
            assert(futhark_free_f32_1d(ctx, result_5) == 0);
            assert(futhark_free_f32_1d(ctx, result_6) == 0);
        }
    }
    ;
    ;
    ;
    free(read_arr_3);
    free(read_arr_4);
    free(read_arr_5);
    free(read_arr_6);
    free(read_arr_7);
    free(read_arr_8);
    free(read_arr_9);
    if (print_result) {
        // Print the final result.
        if (binary_output)
            set_binary_mode(stdout);
        {
            float *arr = calloc(futhark_shape_f32_1d(ctx, result_0)[0],
                                f32_info.size);
            
            assert(arr != NULL);
            assert(futhark_values_f32_1d(ctx, result_0, arr) == 0);
            write_array(stdout, binary_output, &f32_info, arr,
                        futhark_shape_f32_1d(ctx, result_0), 1);
            free(arr);
        }
        printf("\n");
        {
            float *arr = calloc(futhark_shape_f32_1d(ctx, result_1)[0],
                                f32_info.size);
            
            assert(arr != NULL);
            assert(futhark_values_f32_1d(ctx, result_1, arr) == 0);
            write_array(stdout, binary_output, &f32_info, arr,
                        futhark_shape_f32_1d(ctx, result_1), 1);
            free(arr);
        }
        printf("\n");
        {
            float *arr = calloc(futhark_shape_f32_1d(ctx, result_2)[0],
                                f32_info.size);
            
            assert(arr != NULL);
            assert(futhark_values_f32_1d(ctx, result_2, arr) == 0);
            write_array(stdout, binary_output, &f32_info, arr,
                        futhark_shape_f32_1d(ctx, result_2), 1);
            free(arr);
        }
        printf("\n");
        {
            float *arr = calloc(futhark_shape_f32_1d(ctx, result_3)[0],
                                f32_info.size);
            
            assert(arr != NULL);
            assert(futhark_values_f32_1d(ctx, result_3, arr) == 0);
            write_array(stdout, binary_output, &f32_info, arr,
                        futhark_shape_f32_1d(ctx, result_3), 1);
            free(arr);
        }
        printf("\n");
        {
            float *arr = calloc(futhark_shape_f32_1d(ctx, result_4)[0],
                                f32_info.size);
            
            assert(arr != NULL);
            assert(futhark_values_f32_1d(ctx, result_4, arr) == 0);
            write_array(stdout, binary_output, &f32_info, arr,
                        futhark_shape_f32_1d(ctx, result_4), 1);
            free(arr);
        }
        printf("\n");
        {
            float *arr = calloc(futhark_shape_f32_1d(ctx, result_5)[0],
                                f32_info.size);
            
            assert(arr != NULL);
            assert(futhark_values_f32_1d(ctx, result_5, arr) == 0);
            write_array(stdout, binary_output, &f32_info, arr,
                        futhark_shape_f32_1d(ctx, result_5), 1);
            free(arr);
        }
        printf("\n");
        {
            float *arr = calloc(futhark_shape_f32_1d(ctx, result_6)[0],
                                f32_info.size);
            
            assert(arr != NULL);
            assert(futhark_values_f32_1d(ctx, result_6, arr) == 0);
            write_array(stdout, binary_output, &f32_info, arr,
                        futhark_shape_f32_1d(ctx, result_6), 1);
            free(arr);
        }
        printf("\n");
    }
    assert(futhark_free_f32_1d(ctx, result_0) == 0);
    assert(futhark_free_f32_1d(ctx, result_1) == 0);
    assert(futhark_free_f32_1d(ctx, result_2) == 0);
    assert(futhark_free_f32_1d(ctx, result_3) == 0);
    assert(futhark_free_f32_1d(ctx, result_4) == 0);
    assert(futhark_free_f32_1d(ctx, result_5) == 0);
    assert(futhark_free_f32_1d(ctx, result_6) == 0);
}
typedef void entry_point_fun(struct futhark_context *);
struct entry_point_entry {
    const char *name;
    entry_point_fun *fun;
};
int main(int argc, char **argv)
{
    fut_progname = argv[0];
    
    struct futhark_context_config *cfg = futhark_context_config_new();
    
    assert(cfg != NULL);
    
    int parsed_options = parse_options(cfg, argc, argv);
    
    argc -= parsed_options;
    argv += parsed_options;
    if (argc != 0)
        futhark_panic(1, "Excess non-option: %s\n", argv[0]);
    
    struct futhark_context *ctx = futhark_context_new(cfg);
    
    assert(ctx != NULL);
    
    char *error = futhark_context_get_error(ctx);
    
    if (error != NULL)
        futhark_panic(1, "%s", error);
    
    struct entry_point_entry entry_points[] = {{.name ="main", .fun =
                                                futrts_cli_entry_main}};
    
    if (entry_point != NULL) {
        int num_entry_points = sizeof(entry_points) / sizeof(entry_points[0]);
        entry_point_fun *entry_point_fun = NULL;
        
        for (int i = 0; i < num_entry_points; i++) {
            if (strcmp(entry_points[i].name, entry_point) == 0) {
                entry_point_fun = entry_points[i].fun;
                break;
            }
        }
        if (entry_point_fun == NULL) {
            fprintf(stderr,
                    "No entry point '%s'.  Select another with --entry-point.  Options are:\n",
                    entry_point);
            for (int i = 0; i < num_entry_points; i++)
                fprintf(stderr, "%s\n", entry_points[i].name);
            return 1;
        }
        if (isatty(fileno(stdin))) {
            fprintf(stderr, "Reading input from TTY.\n");
            fprintf(stderr,
                    "Send EOF (CTRL-d) after typing all input values.\n");
        }
        entry_point_fun(ctx);
        if (runtime_file != NULL)
            fclose(runtime_file);
        
        char *report = futhark_context_report(ctx);
        
        fputs(report, stderr);
        free(report);
    }
    futhark_context_free(ctx);
    futhark_context_config_free(cfg);
    return 0;
}

#ifdef _MSC_VER
#define inline __inline
#endif
#include <string.h>
#include <string.h>
#include <errno.h>
#include <assert.h>
#include <ctype.h>



// Start of lock.h.

// A very simple cross-platform implementation of locks.  Uses
// pthreads on Unix and some Windows thing there.  Futhark's
// host-level code is not multithreaded, but user code may be, so we
// need some mechanism for ensuring atomic access to API functions.
// This is that mechanism.  It is not exposed to user code at all, so
// we do not have to worry about name collisions.

#ifdef _WIN32

typedef HANDLE lock_t;

static void create_lock(lock_t *lock) {
  *lock = CreateMutex(NULL,  // Default security attributes.
                      FALSE, // Initially unlocked.
                      NULL); // Unnamed.
}

static void lock_lock(lock_t *lock) {
  assert(WaitForSingleObject(*lock, INFINITE) == WAIT_OBJECT_0);
}

static void lock_unlock(lock_t *lock) {
  assert(ReleaseMutex(*lock));
}

static void free_lock(lock_t *lock) {
  CloseHandle(*lock);
}

#else
// Assuming POSIX

#include <pthread.h>

typedef pthread_mutex_t lock_t;

static void create_lock(lock_t *lock) {
  int r = pthread_mutex_init(lock, NULL);
  assert(r == 0);
}

static void lock_lock(lock_t *lock) {
  int r = pthread_mutex_lock(lock);
  assert(r == 0);
}

static void lock_unlock(lock_t *lock) {
  int r = pthread_mutex_unlock(lock);
  assert(r == 0);
}

static void free_lock(lock_t *lock) {
  // Nothing to do for pthreads.
  (void)lock;
}

#endif

// End of lock.h.

#define FUTHARK_F64_ENABLED

// Start of scalar.h.

// Implementation of the primitive scalar operations.  Very
// repetitive.  This code is inserted directly into both CUDA and
// OpenCL programs, as well as the CPU code, so it has some #ifdefs to
// work everywhere.  Some operations are defined as macros because
// this allows us to use them as constant expressions in things like
// array sizes and static initialisers.

// Some of the #ifdefs are because OpenCL uses type-generic functions
// for some operations (e.g. sqrt), while C and CUDA sensibly use
// distinct functions for different precisions (e.g. sqrtf() and
// sqrt()).  This is quite annoying.  Due to C's unfortunate casting
// rules, it is also really easy to accidentally implement
// floating-point functions in the wrong precision, so be careful.

// Double-precision definitions are only included if the preprocessor
// macro FUTHARK_F64_ENABLED is set.

static inline uint8_t add8(uint8_t x, uint8_t y) {
  return x + y;
}

static inline uint16_t add16(uint16_t x, uint16_t y) {
  return x + y;
}

static inline uint32_t add32(uint32_t x, uint32_t y) {
  return x + y;
}

static inline uint64_t add64(uint64_t x, uint64_t y) {
  return x + y;
}

static inline uint8_t sub8(uint8_t x, uint8_t y) {
  return x - y;
}

static inline uint16_t sub16(uint16_t x, uint16_t y) {
  return x - y;
}

static inline uint32_t sub32(uint32_t x, uint32_t y) {
  return x - y;
}

static inline uint64_t sub64(uint64_t x, uint64_t y) {
  return x - y;
}

static inline uint8_t mul8(uint8_t x, uint8_t y) {
  return x * y;
}

static inline uint16_t mul16(uint16_t x, uint16_t y) {
  return x * y;
}

static inline uint32_t mul32(uint32_t x, uint32_t y) {
  return x * y;
}

static inline uint64_t mul64(uint64_t x, uint64_t y) {
  return x * y;
}

static inline uint8_t udiv8(uint8_t x, uint8_t y) {
  return x / y;
}

static inline uint16_t udiv16(uint16_t x, uint16_t y) {
  return x / y;
}

static inline uint32_t udiv32(uint32_t x, uint32_t y) {
  return x / y;
}

static inline uint64_t udiv64(uint64_t x, uint64_t y) {
  return x / y;
}

static inline uint8_t udiv_up8(uint8_t x, uint8_t y) {
  return (x + y - 1) / y;
}

static inline uint16_t udiv_up16(uint16_t x, uint16_t y) {
  return (x + y - 1) / y;
}

static inline uint32_t udiv_up32(uint32_t x, uint32_t y) {
  return (x + y - 1) / y;
}

static inline uint64_t udiv_up64(uint64_t x, uint64_t y) {
  return (x + y - 1) / y;
}

static inline uint8_t umod8(uint8_t x, uint8_t y) {
  return x % y;
}

static inline uint16_t umod16(uint16_t x, uint16_t y) {
  return x % y;
}

static inline uint32_t umod32(uint32_t x, uint32_t y) {
  return x % y;
}

static inline uint64_t umod64(uint64_t x, uint64_t y) {
  return x % y;
}

static inline uint8_t udiv_safe8(uint8_t x, uint8_t y) {
  return y == 0 ? 0 : x / y;
}

static inline uint16_t udiv_safe16(uint16_t x, uint16_t y) {
  return y == 0 ? 0 : x / y;
}

static inline uint32_t udiv_safe32(uint32_t x, uint32_t y) {
  return y == 0 ? 0 : x / y;
}

static inline uint64_t udiv_safe64(uint64_t x, uint64_t y) {
  return y == 0 ? 0 : x / y;
}

static inline uint8_t udiv_up_safe8(uint8_t x, uint8_t y) {
  return y == 0 ? 0 : (x + y - 1) / y;
}

static inline uint16_t udiv_up_safe16(uint16_t x, uint16_t y) {
  return y == 0 ? 0 : (x + y - 1) / y;
}

static inline uint32_t udiv_up_safe32(uint32_t x, uint32_t y) {
  return y == 0 ? 0 : (x + y - 1) / y;
}

static inline uint64_t udiv_up_safe64(uint64_t x, uint64_t y) {
  return y == 0 ? 0 : (x + y - 1) / y;
}

static inline uint8_t umod_safe8(uint8_t x, uint8_t y) {
  return y == 0 ? 0 : x % y;
}

static inline uint16_t umod_safe16(uint16_t x, uint16_t y) {
  return y == 0 ? 0 : x % y;
}

static inline uint32_t umod_safe32(uint32_t x, uint32_t y) {
  return y == 0 ? 0 : x % y;
}

static inline uint64_t umod_safe64(uint64_t x, uint64_t y) {
  return y == 0 ? 0 : x % y;
}

static inline int8_t sdiv8(int8_t x, int8_t y) {
  int8_t q = x / y;
  int8_t r = x % y;

  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}

static inline int16_t sdiv16(int16_t x, int16_t y) {
  int16_t q = x / y;
  int16_t r = x % y;

  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}

static inline int32_t sdiv32(int32_t x, int32_t y) {
  int32_t q = x / y;
  int32_t r = x % y;

  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}

static inline int64_t sdiv64(int64_t x, int64_t y) {
  int64_t q = x / y;
  int64_t r = x % y;

  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}

static inline int8_t sdiv_up8(int8_t x, int8_t y) {
  return sdiv8(x + y - 1, y);
}

static inline int16_t sdiv_up16(int16_t x, int16_t y) {
  return sdiv16(x + y - 1, y);
}

static inline int32_t sdiv_up32(int32_t x, int32_t y) {
  return sdiv32(x + y - 1, y);
}

static inline int64_t sdiv_up64(int64_t x, int64_t y) {
  return sdiv64(x + y - 1, y);
}

static inline int8_t smod8(int8_t x, int8_t y) {
  int8_t r = x % y;

  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}

static inline int16_t smod16(int16_t x, int16_t y) {
  int16_t r = x % y;

  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}

static inline int32_t smod32(int32_t x, int32_t y) {
  int32_t r = x % y;

  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}

static inline int64_t smod64(int64_t x, int64_t y) {
  int64_t r = x % y;

  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}

static inline int8_t sdiv_safe8(int8_t x, int8_t y) {
  return y == 0 ? 0 : sdiv8(x, y);
}

static inline int16_t sdiv_safe16(int16_t x, int16_t y) {
  return y == 0 ? 0 : sdiv16(x, y);
}

static inline int32_t sdiv_safe32(int32_t x, int32_t y) {
  return y == 0 ? 0 : sdiv32(x, y);
}

static inline int64_t sdiv_safe64(int64_t x, int64_t y) {
  return y == 0 ? 0 : sdiv64(x, y);
}

static inline int8_t sdiv_up_safe8(int8_t x, int8_t y) {
  return sdiv_safe8(x + y - 1, y);
}

static inline int16_t sdiv_up_safe16(int16_t x, int16_t y) {
  return sdiv_safe16(x + y - 1, y);
}

static inline int32_t sdiv_up_safe32(int32_t x, int32_t y) {
  return sdiv_safe32(x + y - 1, y);
}

static inline int64_t sdiv_up_safe64(int64_t x, int64_t y) {
  return sdiv_safe64(x + y - 1, y);
}

static inline int8_t smod_safe8(int8_t x, int8_t y) {
  return y == 0 ? 0 : smod8(x, y);
}

static inline int16_t smod_safe16(int16_t x, int16_t y) {
  return y == 0 ? 0 : smod16(x, y);
}

static inline int32_t smod_safe32(int32_t x, int32_t y) {
  return y == 0 ? 0 : smod32(x, y);
}

static inline int64_t smod_safe64(int64_t x, int64_t y) {
  return y == 0 ? 0 : smod64(x, y);
}

static inline int8_t squot8(int8_t x, int8_t y) {
  return x / y;
}

static inline int16_t squot16(int16_t x, int16_t y) {
  return x / y;
}

static inline int32_t squot32(int32_t x, int32_t y) {
  return x / y;
}

static inline int64_t squot64(int64_t x, int64_t y) {
  return x / y;
}

static inline int8_t srem8(int8_t x, int8_t y) {
  return x % y;
}

static inline int16_t srem16(int16_t x, int16_t y) {
  return x % y;
}

static inline int32_t srem32(int32_t x, int32_t y) {
  return x % y;
}

static inline int64_t srem64(int64_t x, int64_t y) {
  return x % y;
}

static inline int8_t squot_safe8(int8_t x, int8_t y) {
  return y == 0 ? 0 : x / y;
}

static inline int16_t squot_safe16(int16_t x, int16_t y) {
  return y == 0 ? 0 : x / y;
}

static inline int32_t squot_safe32(int32_t x, int32_t y) {
  return y == 0 ? 0 : x / y;
}

static inline int64_t squot_safe64(int64_t x, int64_t y) {
  return y == 0 ? 0 : x / y;
}

static inline int8_t srem_safe8(int8_t x, int8_t y) {
  return y == 0 ? 0 : x % y;
}

static inline int16_t srem_safe16(int16_t x, int16_t y) {
  return y == 0 ? 0 : x % y;
}

static inline int32_t srem_safe32(int32_t x, int32_t y) {
  return y == 0 ? 0 : x % y;
}

static inline int64_t srem_safe64(int64_t x, int64_t y) {
  return y == 0 ? 0 : x % y;
}

static inline int8_t smin8(int8_t x, int8_t y) {
  return x < y ? x : y;
}

static inline int16_t smin16(int16_t x, int16_t y) {
  return x < y ? x : y;
}

static inline int32_t smin32(int32_t x, int32_t y) {
  return x < y ? x : y;
}

static inline int64_t smin64(int64_t x, int64_t y) {
  return x < y ? x : y;
}

static inline uint8_t umin8(uint8_t x, uint8_t y) {
  return x < y ? x : y;
}

static inline uint16_t umin16(uint16_t x, uint16_t y) {
  return x < y ? x : y;
}

static inline uint32_t umin32(uint32_t x, uint32_t y) {
  return x < y ? x : y;
}

static inline uint64_t umin64(uint64_t x, uint64_t y) {
  return x < y ? x : y;
}

static inline int8_t smax8(int8_t x, int8_t y) {
  return x < y ? y : x;
}

static inline int16_t smax16(int16_t x, int16_t y) {
  return x < y ? y : x;
}

static inline int32_t smax32(int32_t x, int32_t y) {
  return x < y ? y : x;
}

static inline int64_t smax64(int64_t x, int64_t y) {
  return x < y ? y : x;
}

static inline uint8_t umax8(uint8_t x, uint8_t y) {
  return x < y ? y : x;
}

static inline uint16_t umax16(uint16_t x, uint16_t y) {
  return x < y ? y : x;
}

static inline uint32_t umax32(uint32_t x, uint32_t y) {
  return x < y ? y : x;
}

static inline uint64_t umax64(uint64_t x, uint64_t y) {
  return x < y ? y : x;
}

static inline uint8_t shl8(uint8_t x, uint8_t y) {
  return (uint8_t)(x << y);
}

static inline uint16_t shl16(uint16_t x, uint16_t y) {
  return (uint16_t)(x << y);
}

static inline uint32_t shl32(uint32_t x, uint32_t y) {
  return x << y;
}

static inline uint64_t shl64(uint64_t x, uint64_t y) {
  return x << y;
}

static inline uint8_t lshr8(uint8_t x, uint8_t y) {
  return x >> y;
}

static inline uint16_t lshr16(uint16_t x, uint16_t y) {
  return x >> y;
}

static inline uint32_t lshr32(uint32_t x, uint32_t y) {
  return x >> y;
}

static inline uint64_t lshr64(uint64_t x, uint64_t y) {
  return x >> y;
}

static inline int8_t ashr8(int8_t x, int8_t y) {
  return x >> y;
}

static inline int16_t ashr16(int16_t x, int16_t y) {
  return x >> y;
}

static inline int32_t ashr32(int32_t x, int32_t y) {
  return x >> y;
}

static inline int64_t ashr64(int64_t x, int64_t y) {
  return x >> y;
}

static inline uint8_t and8(uint8_t x, uint8_t y) {
  return x & y;
}

static inline uint16_t and16(uint16_t x, uint16_t y) {
  return x & y;
}

static inline uint32_t and32(uint32_t x, uint32_t y) {
  return x & y;
}

static inline uint64_t and64(uint64_t x, uint64_t y) {
  return x & y;
}

static inline uint8_t or8(uint8_t x, uint8_t y) {
  return x | y;
}

static inline uint16_t or16(uint16_t x, uint16_t y) {
  return x | y;
}

static inline uint32_t or32(uint32_t x, uint32_t y) {
  return x | y;
}

static inline uint64_t or64(uint64_t x, uint64_t y) {
  return x | y;
}

static inline uint8_t xor8(uint8_t x, uint8_t y) {
  return x ^ y;
}

static inline uint16_t xor16(uint16_t x, uint16_t y) {
  return x ^ y;
}

static inline uint32_t xor32(uint32_t x, uint32_t y) {
  return x ^ y;
}

static inline uint64_t xor64(uint64_t x, uint64_t y) {
  return x ^ y;
}

static inline bool ult8(uint8_t x, uint8_t y) {
  return x < y;
}

static inline bool ult16(uint16_t x, uint16_t y) {
  return x < y;
}

static inline bool ult32(uint32_t x, uint32_t y) {
  return x < y;
}

static inline bool ult64(uint64_t x, uint64_t y) {
  return x < y;
}

static inline bool ule8(uint8_t x, uint8_t y) {
  return x <= y;
}

static inline bool ule16(uint16_t x, uint16_t y) {
  return x <= y;
}

static inline bool ule32(uint32_t x, uint32_t y) {
  return x <= y;
}

static inline bool ule64(uint64_t x, uint64_t y) {
  return x <= y;
}

static inline bool slt8(int8_t x, int8_t y) {
  return x < y;
}

static inline bool slt16(int16_t x, int16_t y) {
  return x < y;
}

static inline bool slt32(int32_t x, int32_t y) {
  return x < y;
}

static inline bool slt64(int64_t x, int64_t y) {
  return x < y;
}

static inline bool sle8(int8_t x, int8_t y) {
  return x <= y;
}

static inline bool sle16(int16_t x, int16_t y) {
  return x <= y;
}

static inline bool sle32(int32_t x, int32_t y) {
  return x <= y;
}

static inline bool sle64(int64_t x, int64_t y) {
  return x <= y;
}

static inline uint8_t pow8(uint8_t x, uint8_t y) {
  uint8_t res = 1, rem = y;

  while (rem != 0) {
    if (rem & 1)
      res *= x;
    rem >>= 1;
    x *= x;
  }
  return res;
}

static inline uint16_t pow16(uint16_t x, uint16_t y) {
  uint16_t res = 1, rem = y;

  while (rem != 0) {
    if (rem & 1)
      res *= x;
    rem >>= 1;
    x *= x;
  }
  return res;
}

static inline uint32_t pow32(uint32_t x, uint32_t y) {
  uint32_t res = 1, rem = y;

  while (rem != 0) {
    if (rem & 1)
      res *= x;
    rem >>= 1;
    x *= x;
  }
  return res;
}

static inline uint64_t pow64(uint64_t x, uint64_t y) {
  uint64_t res = 1, rem = y;

  while (rem != 0) {
    if (rem & 1)
      res *= x;
    rem >>= 1;
    x *= x;
  }
  return res;
}

static inline bool itob_i8_bool(int8_t x) {
  return x;
}

static inline bool itob_i16_bool(int16_t x) {
  return x;
}

static inline bool itob_i32_bool(int32_t x) {
  return x;
}

static inline bool itob_i64_bool(int64_t x) {
  return x;
}

static inline int8_t btoi_bool_i8(bool x) {
  return x;
}

static inline int16_t btoi_bool_i16(bool x) {
  return x;
}

static inline int32_t btoi_bool_i32(bool x) {
  return x;
}

static inline int64_t btoi_bool_i64(bool x) {
  return x;
}

#define sext_i8_i8(x) ((int8_t) (int8_t) (x))
#define sext_i8_i16(x) ((int16_t) (int8_t) (x))
#define sext_i8_i32(x) ((int32_t) (int8_t) (x))
#define sext_i8_i64(x) ((int64_t) (int8_t) (x))
#define sext_i16_i8(x) ((int8_t) (int16_t) (x))
#define sext_i16_i16(x) ((int16_t) (int16_t) (x))
#define sext_i16_i32(x) ((int32_t) (int16_t) (x))
#define sext_i16_i64(x) ((int64_t) (int16_t) (x))
#define sext_i32_i8(x) ((int8_t) (int32_t) (x))
#define sext_i32_i16(x) ((int16_t) (int32_t) (x))
#define sext_i32_i32(x) ((int32_t) (int32_t) (x))
#define sext_i32_i64(x) ((int64_t) (int32_t) (x))
#define sext_i64_i8(x) ((int8_t) (int64_t) (x))
#define sext_i64_i16(x) ((int16_t) (int64_t) (x))
#define sext_i64_i32(x) ((int32_t) (int64_t) (x))
#define sext_i64_i64(x) ((int64_t) (int64_t) (x))
#define zext_i8_i8(x) ((int8_t) (uint8_t) (x))
#define zext_i8_i16(x) ((int16_t) (uint8_t) (x))
#define zext_i8_i32(x) ((int32_t) (uint8_t) (x))
#define zext_i8_i64(x) ((int64_t) (uint8_t) (x))
#define zext_i16_i8(x) ((int8_t) (uint16_t) (x))
#define zext_i16_i16(x) ((int16_t) (uint16_t) (x))
#define zext_i16_i32(x) ((int32_t) (uint16_t) (x))
#define zext_i16_i64(x) ((int64_t) (uint16_t) (x))
#define zext_i32_i8(x) ((int8_t) (uint32_t) (x))
#define zext_i32_i16(x) ((int16_t) (uint32_t) (x))
#define zext_i32_i32(x) ((int32_t) (uint32_t) (x))
#define zext_i32_i64(x) ((int64_t) (uint32_t) (x))
#define zext_i64_i8(x) ((int8_t) (uint64_t) (x))
#define zext_i64_i16(x) ((int16_t) (uint64_t) (x))
#define zext_i64_i32(x) ((int32_t) (uint64_t) (x))
#define zext_i64_i64(x) ((int64_t) (uint64_t) (x))

static int8_t abs8(int8_t x) {
  return (int8_t)abs(x);
}

static int16_t abs16(int16_t x) {
  return (int16_t)abs(x);
}

static int32_t abs32(int32_t x) {
  return abs(x);
}

static int64_t abs64(int64_t x) {
#if defined(__OPENCL_VERSION__)
  return abs(x);
#else
  return llabs(x);
#endif
}

#if defined(__OPENCL_VERSION__)
static int32_t futrts_popc8(int8_t x) {
  return popcount(x);
}

static int32_t futrts_popc16(int16_t x) {
  return popcount(x);
}

static int32_t futrts_popc32(int32_t x) {
  return popcount(x);
}

static int32_t futrts_popc64(int64_t x) {
  return popcount(x);
}
#elif defined(__CUDA_ARCH__)

static int32_t futrts_popc8(int8_t x) {
  return __popc(zext_i8_i32(x));
}

static int32_t futrts_popc16(int16_t x) {
  return __popc(zext_i16_i32(x));
}

static int32_t futrts_popc32(int32_t x) {
  return __popc(x);
}

static int32_t futrts_popc64(int64_t x) {
  return __popcll(x);
}

#else // Not OpenCL or CUDA, but plain C.

static int32_t futrts_popc8(uint8_t x) {
  int c = 0;
  for (; x; ++c) { x &= x - 1; }
  return c;
}

static int32_t futrts_popc16(uint16_t x) {
  int c = 0;
  for (; x; ++c) { x &= x - 1; }
  return c;
}

static int32_t futrts_popc32(uint32_t x) {
  int c = 0;
  for (; x; ++c) { x &= x - 1; }
  return c;
}

static int32_t futrts_popc64(uint64_t x) {
  int c = 0;
  for (; x; ++c) { x &= x - 1; }
  return c;
}
#endif

#if defined(__OPENCL_VERSION__)
static uint8_t futrts_mul_hi8(uint8_t a, uint8_t b) {
  return mul_hi(a, b);
}

static uint16_t futrts_mul_hi16(uint16_t a, uint16_t b) {
  return mul_hi(a, b);
}

static uint32_t futrts_mul_hi32(uint32_t a, uint32_t b) {
  return mul_hi(a, b);
}

static uint64_t futrts_mul_hi64(uint64_t a, uint64_t b) {
  return mul_hi(a, b);
}

#elif defined(__CUDA_ARCH__)

static uint8_t futrts_mul_hi8(uint8_t a, uint8_t b) {
  uint16_t aa = a;
  uint16_t bb = b;

  return aa * bb >> 8;
}

static uint16_t futrts_mul_hi16(uint16_t a, uint16_t b) {
  uint32_t aa = a;
  uint32_t bb = b;

  return aa * bb >> 16;
}

static uint32_t futrts_mul_hi32(uint32_t a, uint32_t b) {
  return mulhi(a, b);
}

static uint64_t futrts_mul_hi64(uint64_t a, uint64_t b) {
  return mul64hi(a, b);
}

#else // Not OpenCL or CUDA, but plain C.

static uint8_t futrts_mul_hi8(uint8_t a, uint8_t b) {
  uint16_t aa = a;
  uint16_t bb = b;

  return aa * bb >> 8;
}

static uint16_t futrts_mul_hi16(uint16_t a, uint16_t b) {
  uint32_t aa = a;
  uint32_t bb = b;

  return aa * bb >> 16;
}

static uint32_t futrts_mul_hi32(uint32_t a, uint32_t b) {
  uint64_t aa = a;
  uint64_t bb = b;

  return aa * bb >> 32;
}

static uint64_t futrts_mul_hi64(uint64_t a, uint64_t b) {
  __uint128_t aa = a;
  __uint128_t bb = b;

  return aa * bb >> 64;
}
#endif

#if defined(__OPENCL_VERSION__)
static uint8_t futrts_mad_hi8(uint8_t a, uint8_t b, uint8_t c) {
  return mad_hi(a, b, c);
}

static uint16_t futrts_mad_hi16(uint16_t a, uint16_t b, uint16_t c) {
  return mad_hi(a, b, c);
}

static uint32_t futrts_mad_hi32(uint32_t a, uint32_t b, uint32_t c) {
  return mad_hi(a, b, c);
}

static uint64_t futrts_mad_hi64(uint64_t a, uint64_t b, uint64_t c) {
  return mad_hi(a, b, c);
}

#else // Not OpenCL

static uint8_t futrts_mad_hi8(uint8_t a, uint8_t b, uint8_t c) {
  return futrts_mul_hi8(a, b) + c;
}

static uint16_t futrts_mad_hi16(uint16_t a, uint16_t b, uint16_t c) {
  return futrts_mul_hi16(a, b) + c;
}

static uint32_t futrts_mad_hi32(uint32_t a, uint32_t b, uint32_t c) {
  return futrts_mul_hi32(a, b) + c;
}

static uint64_t futrts_mad_hi64(uint64_t a, uint64_t b, uint64_t c) {
  return futrts_mul_hi64(a, b) + c;
}
#endif

#if defined(__OPENCL_VERSION__)
static int32_t futrts_clzz8(int8_t x) {
  return clz(x);
}

static int32_t futrts_clzz16(int16_t x) {
  return clz(x);
}

static int32_t futrts_clzz32(int32_t x) {
  return clz(x);
}

static int32_t futrts_clzz64(int64_t x) {
  return clz(x);
}

#elif defined(__CUDA_ARCH__)

static int32_t futrts_clzz8(int8_t x) {
  return __clz(zext_i8_i32(x)) - 24;
}

static int32_t futrts_clzz16(int16_t x) {
  return __clz(zext_i16_i32(x)) - 16;
}

static int32_t futrts_clzz32(int32_t x) {
  return __clz(x);
}

static int32_t futrts_clzz64(int64_t x) {
  return __clzll(x);
}

#else // Not OpenCL or CUDA, but plain C.

static int32_t futrts_clzz8(int8_t x) {
  return x == 0 ? 8 : __builtin_clz((uint32_t)zext_i8_i32(x)) - 24;
}

static int32_t futrts_clzz16(int16_t x) {
  return x == 0 ? 16 : __builtin_clz((uint32_t)zext_i16_i32(x)) - 16;
}

static int32_t futrts_clzz32(int32_t x) {
  return x == 0 ? 32 : __builtin_clz((uint32_t)x);
}

static int32_t futrts_clzz64(int64_t x) {
  return x == 0 ? 64 : __builtin_clzll((uint64_t)x);
}
#endif

#if defined(__OPENCL_VERSION__)
static int32_t futrts_ctzz8(int8_t x) {
  int i = 0;
  for (; i < 8 && (x & 1) == 0; i++, x >>= 1)
    ;
  return i;
}

static int32_t futrts_ctzz16(int16_t x) {
  int i = 0;
  for (; i < 16 && (x & 1) == 0; i++, x >>= 1)
    ;
  return i;
}

static int32_t futrts_ctzz32(int32_t x) {
  int i = 0;
  for (; i < 32 && (x & 1) == 0; i++, x >>= 1)
    ;
  return i;
}

static int32_t futrts_ctzz64(int64_t x) {
  int i = 0;
  for (; i < 64 && (x & 1) == 0; i++, x >>= 1)
    ;
  return i;
}

#elif defined(__CUDA_ARCH__)

static int32_t futrts_ctzz8(int8_t x) {
  int y = __ffs(x);
  return y == 0 ? 8 : y - 1;
}

static int32_t futrts_ctzz16(int16_t x) {
  int y = __ffs(x);
  return y == 0 ? 16 : y - 1;
}

static int32_t futrts_ctzz32(int32_t x) {
  int y = __ffs(x);
  return y == 0 ? 32 : y - 1;
}

static int32_t futrts_ctzz64(int64_t x) {
  int y = __ffsll(x);
  return y == 0 ? 64 : y - 1;
}

#else // Not OpenCL or CUDA, but plain C.

static int32_t futrts_ctzz8(int8_t x) {
  return x == 0 ? 8 : __builtin_ctz((uint32_t)x);
}

static int32_t futrts_ctzz16(int16_t x) {
  return x == 0 ? 16 : __builtin_ctz((uint32_t)x);
}

static int32_t futrts_ctzz32(int32_t x) {
  return x == 0 ? 32 : __builtin_ctz((uint32_t)x);
}

static int32_t futrts_ctzz64(int64_t x) {
  return x == 0 ? 64 : __builtin_ctzll((uint64_t)x);
}
#endif

static inline float fdiv32(float x, float y) {
  return x / y;
}

static inline float fadd32(float x, float y) {
  return x + y;
}

static inline float fsub32(float x, float y) {
  return x - y;
}

static inline float fmul32(float x, float y) {
  return x * y;
}

static inline bool cmplt32(float x, float y) {
  return x < y;
}

static inline bool cmple32(float x, float y) {
  return x <= y;
}

static inline float sitofp_i8_f32(int8_t x) {
  return (float) x;
}

static inline float sitofp_i16_f32(int16_t x) {
  return (float) x;
}

static inline float sitofp_i32_f32(int32_t x) {
  return (float) x;
}

static inline float sitofp_i64_f32(int64_t x) {
  return (float) x;
}

static inline float uitofp_i8_f32(uint8_t x) {
  return (float) x;
}

static inline float uitofp_i16_f32(uint16_t x) {
  return (float) x;
}

static inline float uitofp_i32_f32(uint32_t x) {
  return (float) x;
}

static inline float uitofp_i64_f32(uint64_t x) {
  return (float) x;
}

#ifdef __OPENCL_VERSION__
static inline float fabs32(float x) {
  return fabs(x);
}

static inline float fmax32(float x, float y) {
  return fmax(x, y);
}

static inline float fmin32(float x, float y) {
  return fmin(x, y);
}

static inline float fpow32(float x, float y) {
  return pow(x, y);
}

#else // Not OpenCL, but CUDA or plain C.

static inline float fabs32(float x) {
  return fabsf(x);
}

static inline float fmax32(float x, float y) {
  return fmaxf(x, y);
}

static inline float fmin32(float x, float y) {
  return fminf(x, y);
}

static inline float fpow32(float x, float y) {
  return powf(x, y);
}
#endif

static inline bool futrts_isnan32(float x) {
  return isnan(x);
}

static inline bool futrts_isinf32(float x) {
  return isinf(x);
}

static inline int8_t fptosi_f32_i8(float x) {
  if (futrts_isnan32(x) || futrts_isinf32(x)) {
    return 0;
  } else {
    return (int8_t) x;
  }
}

static inline int16_t fptosi_f32_i16(float x) {
  if (futrts_isnan32(x) || futrts_isinf32(x)) {
    return 0;
  } else {
    return (int16_t) x;
  }
}

static inline int32_t fptosi_f32_i32(float x) {
  if (futrts_isnan32(x) || futrts_isinf32(x)) {
    return 0;
  } else {
    return (int32_t) x;
  }
}

static inline int64_t fptosi_f32_i64(float x) {
  if (futrts_isnan32(x) || futrts_isinf32(x)) {
    return 0;
  } else {
    return (int64_t) x;
  };
}

static inline uint8_t fptoui_f32_i8(float x) {
  if (futrts_isnan32(x) || futrts_isinf32(x)) {
    return 0;
  } else {
    return (uint8_t) (int8_t) x;
  }
}

static inline uint16_t fptoui_f32_i16(float x) {
  if (futrts_isnan32(x) || futrts_isinf32(x)) {
    return 0;
  } else {
    return (uint16_t) (int16_t) x;
  }
}

static inline uint32_t fptoui_f32_i32(float x) {
  if (futrts_isnan32(x) || futrts_isinf32(x)) {
    return 0;
  } else {
    return (uint32_t) (int32_t) x;
  }
}

static inline uint64_t fptoui_f32_i64(float x) {
  if (futrts_isnan32(x) || futrts_isinf32(x)) {
    return 0;
  } else {
    return (uint64_t) (int64_t) x;
  }
}

static inline bool ftob_f32_bool(float x) {
  return x != 0;
}

static inline float btof_bool_f32(bool x) {
  return x ? 1 : 0;
}

#ifdef __OPENCL_VERSION__
static inline float futrts_log32(float x) {
  return log(x);
}

static inline float futrts_log2_32(float x) {
  return log2(x);
}

static inline float futrts_log10_32(float x) {
  return log10(x);
}

static inline float futrts_sqrt32(float x) {
  return sqrt(x);
}

static inline float futrts_exp32(float x) {
  return exp(x);
}

static inline float futrts_cos32(float x) {
  return cos(x);
}

static inline float futrts_sin32(float x) {
  return sin(x);
}

static inline float futrts_tan32(float x) {
  return tan(x);
}

static inline float futrts_acos32(float x) {
  return acos(x);
}

static inline float futrts_asin32(float x) {
  return asin(x);
}

static inline float futrts_atan32(float x) {
  return atan(x);
}

static inline float futrts_cosh32(float x) {
  return cosh(x);
}

static inline float futrts_sinh32(float x) {
  return sinh(x);
}

static inline float futrts_tanh32(float x) {
  return tanh(x);
}

static inline float futrts_acosh32(float x) {
  return acosh(x);
}

static inline float futrts_asinh32(float x) {
  return asinh(x);
}

static inline float futrts_atanh32(float x) {
  return atanh(x);
}

static inline float futrts_atan2_32(float x, float y) {
  return atan2(x, y);
}

static inline float futrts_hypot32(float x, float y) {
  return hypot(x, y);
}

static inline float futrts_gamma32(float x) {
  return tgamma(x);
}

static inline float futrts_lgamma32(float x) {
  return lgamma(x);
}

static inline float fmod32(float x, float y) {
  return fmod(x, y);
}

static inline float futrts_round32(float x) {
  return rint(x);
}

static inline float futrts_floor32(float x) {
  return floor(x);
}

static inline float futrts_ceil32(float x) {
  return ceil(x);
}

static inline float futrts_lerp32(float v0, float v1, float t) {
  return mix(v0, v1, t);
}

static inline float futrts_mad32(float a, float b, float c) {
  return mad(a, b, c);
}

static inline float futrts_fma32(float a, float b, float c) {
  return fma(a, b, c);
}

#else // Not OpenCL, but CUDA or plain C.

static inline float futrts_log32(float x) {
  return logf(x);
}

static inline float futrts_log2_32(float x) {
  return log2f(x);
}

static inline float futrts_log10_32(float x) {
  return log10f(x);
}

static inline float futrts_sqrt32(float x) {
  return sqrtf(x);
}

static inline float futrts_exp32(float x) {
  return expf(x);
}

static inline float futrts_cos32(float x) {
  return cosf(x);
}

static inline float futrts_sin32(float x) {
  return sinf(x);
}

static inline float futrts_tan32(float x) {
  return tanf(x);
}

static inline float futrts_acos32(float x) {
  return acosf(x);
}

static inline float futrts_asin32(float x) {
  return asinf(x);
}

static inline float futrts_atan32(float x) {
  return atanf(x);
}

static inline float futrts_cosh32(float x) {
  return coshf(x);
}

static inline float futrts_sinh32(float x) {
  return sinhf(x);
}

static inline float futrts_tanh32(float x) {
  return tanhf(x);
}

static inline float futrts_acosh32(float x) {
  return acoshf(x);
}

static inline float futrts_asinh32(float x) {
  return asinhf(x);
}

static inline float futrts_atanh32(float x) {
  return atanhf(x);
}

static inline float futrts_atan2_32(float x, float y) {
  return atan2f(x, y);
}

static inline float futrts_hypot32(float x, float y) {
  return hypotf(x, y);
}

static inline float futrts_gamma32(float x) {
  return tgammaf(x);
}

static inline float futrts_lgamma32(float x) {
  return lgammaf(x);
}

static inline float fmod32(float x, float y) {
  return fmodf(x, y);
}

static inline float futrts_round32(float x) {
  return rintf(x);
}

static inline float futrts_floor32(float x) {
  return floorf(x);
}

static inline float futrts_ceil32(float x) {
  return ceilf(x);
}

static inline float futrts_lerp32(float v0, float v1, float t) {
  return v0 + (v1 - v0) * t;
}

static inline float futrts_mad32(float a, float b, float c) {
  return a * b + c;
}

static inline float futrts_fma32(float a, float b, float c) {
  return fmaf(a, b, c);
}
#endif

static inline int32_t futrts_to_bits32(float x) {
  union {
    float f;
    int32_t t;
  } p;

  p.f = x;
  return p.t;
}

static inline float futrts_from_bits32(int32_t x) {
  union {
    int32_t f;
    float t;
  } p;

  p.f = x;
  return p.t;
}

static inline float fsignum32(float x) {
  return futrts_isnan32(x) ? x : (x > 0) - (x < 0);
}

#ifdef FUTHARK_F64_ENABLED

static inline double fdiv64(double x, double y) {
  return x / y;
}

static inline double fadd64(double x, double y) {
  return x + y;
}

static inline double fsub64(double x, double y) {
  return x - y;
}

static inline double fmul64(double x, double y) {
  return x * y;
}

static inline bool cmplt64(double x, double y) {
  return x < y;
}

static inline bool cmple64(double x, double y) {
  return x <= y;
}

static inline double sitofp_i8_f64(int8_t x) {
  return (double) x;
}

static inline double sitofp_i16_f64(int16_t x) {
  return (double) x;
}

static inline double sitofp_i32_f64(int32_t x) {
  return (double) x;
}

static inline double sitofp_i64_f64(int64_t x) {
  return (double) x;
}

static inline double uitofp_i8_f64(uint8_t x) {
  return (double) x;
}

static inline double uitofp_i16_f64(uint16_t x) {
  return (double) x;
}

static inline double uitofp_i32_f64(uint32_t x) {
  return (double) x;
}

static inline double uitofp_i64_f64(uint64_t x) {
  return (double) x;
}

static inline double fabs64(double x) {
  return fabs(x);
}

static inline double fmax64(double x, double y) {
  return fmax(x, y);
}

static inline double fmin64(double x, double y) {
  return fmin(x, y);
}

static inline double fpow64(double x, double y) {
  return pow(x, y);
}

static inline double futrts_log64(double x) {
  return log(x);
}

static inline double futrts_log2_64(double x) {
  return log2(x);
}

static inline double futrts_log10_64(double x) {
  return log10(x);
}

static inline double futrts_sqrt64(double x) {
  return sqrt(x);
}

static inline double futrts_exp64(double x) {
  return exp(x);
}

static inline double futrts_cos64(double x) {
  return cos(x);
}

static inline double futrts_sin64(double x) {
  return sin(x);
}

static inline double futrts_tan64(double x) {
  return tan(x);
}

static inline double futrts_acos64(double x) {
  return acos(x);
}

static inline double futrts_asin64(double x) {
  return asin(x);
}

static inline double futrts_atan64(double x) {
  return atan(x);
}

static inline double futrts_cosh64(double x) {
  return cosh(x);
}

static inline double futrts_sinh64(double x) {
  return sinh(x);
}

static inline double futrts_tanh64(double x) {
  return tanh(x);
}

static inline double futrts_acosh64(double x) {
  return acosh(x);
}

static inline double futrts_asinh64(double x) {
  return asinh(x);
}

static inline double futrts_atanh64(double x) {
  return atanh(x);
}

static inline double futrts_atan2_64(double x, double y) {
  return atan2(x, y);
}

static inline double futrts_hypot64(double x, double y) {
  return hypot(x, y);
}

static inline double futrts_gamma64(double x) {
  return tgamma(x);
}

static inline double futrts_lgamma64(double x) {
  return lgamma(x);
}

static inline double futrts_fma64(double a, double b, double c) {
  return fma(a, b, c);
}

static inline double futrts_round64(double x) {
  return rint(x);
}

static inline double futrts_ceil64(double x) {
  return ceil(x);
}

static inline double futrts_floor64(double x) {
  return floor(x);
}

static inline bool futrts_isnan64(double x) {
  return isnan(x);
}

static inline bool futrts_isinf64(double x) {
  return isinf(x);
}

static inline int8_t fptosi_f64_i8(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (int8_t) x;
  }
}

static inline int16_t fptosi_f64_i16(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (int16_t) x;
  }
}

static inline int32_t fptosi_f64_i32(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (int32_t) x;
  }
}

static inline int64_t fptosi_f64_i64(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (int64_t) x;
  }
}

static inline uint8_t fptoui_f64_i8(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (uint8_t) (int8_t) x;
  }
}

static inline uint16_t fptoui_f64_i16(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (uint16_t) (int16_t) x;
  }
}

static inline uint32_t fptoui_f64_i32(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (uint32_t) (int32_t) x;
  }
}

static inline uint64_t fptoui_f64_i64(double x) {
  if (futrts_isnan64(x) || futrts_isinf64(x)) {
    return 0;
  } else {
    return (uint64_t) (int64_t) x;
  }
}

static inline bool ftob_f64_bool(double x) {
  return x != 0;
}

static inline double btof_bool_f64(bool x) {
  return x ? 1 : 0;
}

static inline int64_t futrts_to_bits64(double x) {
  union {
    double f;
    int64_t t;
  } p;

  p.f = x;
  return p.t;
}

static inline double futrts_from_bits64(int64_t x) {
  union {
    int64_t f;
    double t;
  } p;

  p.f = x;
  return p.t;
}

static inline double fmod64(double x, double y) {
  return fmod(x, y);
}

static inline double fsignum64(double x) {
  return futrts_isnan64(x) ? x : (x > 0) - (x < 0);
}

static inline double futrts_lerp64(double v0, double v1, double t) {
#ifdef __OPENCL_VERSION__
  return mix(v0, v1, t);
#else
  return v0 + (v1 - v0) * t;
#endif
}

static inline double futrts_mad64(double a, double b, double c) {
#ifdef __OPENCL_VERSION__
  return mad(a, b, c);
#else
  return a * b + c;
#endif
}

static inline float fpconv_f32_f32(float x) {
  return (float) x;
}

static inline double fpconv_f32_f64(float x) {
  return (double) x;
}

static inline float fpconv_f64_f32(double x) {
  return (float) x;
}

static inline double fpconv_f64_f64(double x) {
  return (double) x;
}

#endif

// End of scalar.h.
// Start of scalar_f16.h.

// Half-precision is emulated if needed (e.g. in straight C) with the
// native type used if possible.  The emulation works by typedef'ing
// 'float' to 'f16', and then implementing all operations on single
// precision.  To cut down on duplication, we use the same code for
// those Futhark functions that require just operators or casts.  The
// in-memory representation for arrays will still be 16 bits even
// under emulation, so the compiler will have to be careful when
// generating reads or writes.

#if !defined(cl_khr_fp16) && !(defined(__CUDA_ARCH__) && __CUDA_ARCH__ >= 600)
#define EMULATE_F16
#endif

#if !defined(EMULATE_F16) && defined(__OPENCL_VERSION__)
#pragma OPENCL EXTENSION cl_khr_fp16 : enable
#endif

#ifdef EMULATE_F16

// Note that the half-precision storage format is still 16 bits - the
// compiler will have to be real careful!
typedef float f16;

#else

#ifdef __CUDA_ARCH__
#include <cuda_fp16.h>
#endif

typedef half f16;

#endif

// Some of these functions convert to single precision because half
// precision versions are not available.

static inline f16 fadd16(f16 x, f16 y) {
  return x + y;
}

static inline f16 fsub16(f16 x, f16 y) {
  return x - y;
}

static inline f16 fmul16(f16 x, f16 y) {
  return x * y;
}

static inline bool cmplt16(f16 x, f16 y) {
  return x < y;
}

static inline bool cmple16(f16 x, f16 y) {
  return x <= y;
}

static inline f16 sitofp_i8_f16(int8_t x) {
  return (f16) x;
}

static inline f16 sitofp_i16_f16(int16_t x) {
  return (f16) x;
}

static inline f16 sitofp_i32_f16(int32_t x) {
  return (f16) x;
}

static inline f16 sitofp_i64_f16(int64_t x) {
  return (f16) x;
}

static inline f16 uitofp_i8_f16(uint8_t x) {
  return (f16) x;
}

static inline f16 uitofp_i16_f16(uint16_t x) {
  return (f16) x;
}

static inline f16 uitofp_i32_f16(uint32_t x) {
  return (f16) x;
}

static inline f16 uitofp_i64_f16(uint64_t x) {
  return (f16) x;
}

static inline int8_t fptosi_f16_i8(f16 x) {
  return (int8_t) (float) x;
}

static inline int16_t fptosi_f16_i16(f16 x) {
  return (int16_t) x;
}

static inline int32_t fptosi_f16_i32(f16 x) {
  return (int32_t) x;
}

static inline int64_t fptosi_f16_i64(f16 x) {
  return (int64_t) x;
}

static inline uint8_t fptoui_f16_i8(f16 x) {
  return (uint8_t) (float) x;
}

static inline uint16_t fptoui_f16_i16(f16 x) {
  return (uint16_t) x;
}

static inline uint32_t fptoui_f16_i32(f16 x) {
  return (uint32_t) x;
}

static inline uint64_t fptoui_f16_i64(f16 x) {
  return (uint64_t) x;
}

static inline bool ftob_f16_bool(f16 x) {
  return x != (f16)0;
}

static inline f16 btof_bool_f16(bool x) {
  return x ? 1 : 0;
}

#ifndef EMULATE_F16

#ifdef __OPENCL_VERSION__
static inline f16 fabs16(f16 x) {
  return fabs(x);
}

static inline f16 fmax16(f16 x, f16 y) {
  return fmax(x, y);
}

static inline f16 fmin16(f16 x, f16 y) {
  return fmin(x, y);
}

static inline f16 fpow16(f16 x, f16 y) {
  return pow(x, y);
}

#else // Assuming CUDA.

static inline f16 fabs16(f16 x) {
  return fabsf(x);
}

static inline f16 fmax16(f16 x, f16 y) {
  return fmaxf(x, y);
}

static inline f16 fmin16(f16 x, f16 y) {
  return fminf(x, y);
}

static inline f16 fpow16(f16 x, f16 y) {
  return powf(x, y);
}
#endif

static inline bool futrts_isnan16(f16 x) {
  return isnan((float)x);
}

static inline bool futrts_isinf16(f16 x) {
  return isinf((float)x);
}

#ifdef __OPENCL_VERSION__
static inline f16 futrts_log16(f16 x) {
  return log(x);
}

static inline f16 futrts_log2_16(f16 x) {
  return log2(x);
}

static inline f16 futrts_log10_16(f16 x) {
  return log10(x);
}

static inline f16 futrts_sqrt16(f16 x) {
  return sqrt(x);
}

static inline f16 futrts_exp16(f16 x) {
  return exp(x);
}

static inline f16 futrts_cos16(f16 x) {
  return cos(x);
}

static inline f16 futrts_sin16(f16 x) {
  return sin(x);
}

static inline f16 futrts_tan16(f16 x) {
  return tan(x);
}

static inline f16 futrts_acos16(f16 x) {
  return acos(x);
}

static inline f16 futrts_asin16(f16 x) {
  return asin(x);
}

static inline f16 futrts_atan16(f16 x) {
  return atan(x);
}

static inline f16 futrts_cosh16(f16 x) {
  return cosh(x);
}

static inline f16 futrts_sinh16(f16 x) {
  return sinh(x);
}

static inline f16 futrts_tanh16(f16 x) {
  return tanh(x);
}

static inline f16 futrts_acosh16(f16 x) {
  return acosh(x);
}

static inline f16 futrts_asinh16(f16 x) {
  return asinh(x);
}

static inline f16 futrts_atanh16(f16 x) {
  return atanh(x);
}

static inline f16 futrts_atan2_16(f16 x, f16 y) {
  return atan2(x, y);
}

static inline f16 futrts_hypot16(f16 x, f16 y) {
  return hypot(x, y);
}

static inline f16 futrts_gamma16(f16 x) {
  return tgamma(x);
}

static inline f16 futrts_lgamma16(f16 x) {
  return lgamma(x);
}

static inline f16 fmod16(f16 x, f16 y) {
  return fmod(x, y);
}

static inline f16 futrts_round16(f16 x) {
  return rint(x);
}

static inline f16 futrts_floor16(f16 x) {
  return floor(x);
}

static inline f16 futrts_ceil16(f16 x) {
  return ceil(x);
}

static inline f16 futrts_lerp16(f16 v0, f16 v1, f16 t) {
  return mix(v0, v1, t);
}

static inline f16 futrts_mad16(f16 a, f16 b, f16 c) {
  return mad(a, b, c);
}

static inline f16 futrts_fma16(f16 a, f16 b, f16 c) {
  return fma(a, b, c);
}

#else // Assume CUDA.

static inline f16 futrts_log16(f16 x) {
  return hlog(x);
}

static inline f16 futrts_log2_16(f16 x) {
  return hlog2(x);
}

static inline f16 futrts_log10_16(f16 x) {
  return hlog10(x);
}

static inline f16 futrts_sqrt16(f16 x) {
  return hsqrt(x);
}

static inline f16 futrts_exp16(f16 x) {
  return hexp(x);
}

static inline f16 futrts_cos16(f16 x) {
  return hcos(x);
}

static inline f16 futrts_sin16(f16 x) {
  return hsin(x);
}

static inline f16 futrts_tan16(f16 x) {
  return tanf(x);
}

static inline f16 futrts_acos16(f16 x) {
  return acosf(x);
}

static inline f16 futrts_asin16(f16 x) {
  return asinf(x);
}

static inline f16 futrts_atan16(f16 x) {
  return atanf(x);
}

static inline f16 futrts_cosh16(f16 x) {
  return coshf(x);
}

static inline f16 futrts_sinh16(f16 x) {
  return sinhf(x);
}

static inline f16 futrts_tanh16(f16 x) {
  return tanhf(x);
}

static inline f16 futrts_acosh16(f16 x) {
  return acoshf(x);
}

static inline f16 futrts_asinh16(f16 x) {
  return asinhf(x);
}

static inline f16 futrts_atanh16(f16 x) {
  return atanhf(x);
}

static inline f16 futrts_atan2_16(f16 x, f16 y) {
  return atan2f(x, y);
}

static inline f16 futrts_hypot16(f16 x, f16 y) {
  return hypotf(x, y);
}

static inline f16 futrts_gamma16(f16 x) {
  return tgammaf(x);
}

static inline f16 futrts_lgamma16(f16 x) {
  return lgammaf(x);
}

static inline f16 fmod16(f16 x, f16 y) {
  return fmodf(x, y);
}

static inline f16 futrts_round16(f16 x) {
  return rintf(x);
}

static inline f16 futrts_floor16(f16 x) {
  return hfloor(x);
}

static inline f16 futrts_ceil16(f16 x) {
  return hceil(x);
}

static inline f16 futrts_lerp16(f16 v0, f16 v1, f16 t) {
  return v0 + (v1 - v0) * t;
}

static inline f16 futrts_mad16(f16 a, f16 b, f16 c) {
  return a * b + c;
}

static inline f16 futrts_fma16(f16 a, f16 b, f16 c) {
  return fmaf(a, b, c);
}

#endif

// The CUDA __half type cannot be put in unions for some reason, so we
// use bespoke conversion functions instead.
#ifdef __CUDA_ARCH__
static inline int16_t futrts_to_bits16(f16 x) {
  return __half_as_ushort(x);
}
static inline f16 futrts_from_bits16(int16_t x) {
  return __ushort_as_half(x);
}
#else
static inline int16_t futrts_to_bits16(f16 x) {
  union {
    f16 f;
    int16_t t;
  } p;

  p.f = x;
  return p.t;
}

static inline f16 futrts_from_bits16(int16_t x) {
  union {
    int16_t f;
    f16 t;
  } p;

  p.f = x;
  return p.t;
}
#endif

#else // No native f16 - emulate.

static inline f16 fabs16(f16 x) {
  return fabs32(x);
}

static inline f16 fmax16(f16 x, f16 y) {
  return fmax32(x, y);
}

static inline f16 fmin16(f16 x, f16 y) {
  return fmin32(x, y);
}

static inline f16 fpow16(f16 x, f16 y) {
  return fpow32(x, y);
}

static inline bool futrts_isnan16(f16 x) {
  return futrts_isnan32(x);
}

static inline bool futrts_isinf16(f16 x) {
  return futrts_isinf32(x);
}

static inline f16 futrts_log16(f16 x) {
  return futrts_log32(x);
}

static inline f16 futrts_log2_16(f16 x) {
  return futrts_log2_32(x);
}

static inline f16 futrts_log10_16(f16 x) {
  return futrts_log10_32(x);
}

static inline f16 futrts_sqrt16(f16 x) {
  return futrts_sqrt32(x);
}

static inline f16 futrts_exp16(f16 x) {
  return futrts_exp32(x);
}

static inline f16 futrts_cos16(f16 x) {
  return futrts_cos32(x);
}

static inline f16 futrts_sin16(f16 x) {
  return futrts_sin32(x);
}

static inline f16 futrts_tan16(f16 x) {
  return futrts_tan32(x);
}

static inline f16 futrts_acos16(f16 x) {
  return futrts_acos32(x);
}

static inline f16 futrts_asin16(f16 x) {
  return futrts_asin32(x);
}

static inline f16 futrts_atan16(f16 x) {
  return futrts_atan32(x);
}

static inline f16 futrts_cosh16(f16 x) {
  return futrts_cosh32(x);
}

static inline f16 futrts_sinh16(f16 x) {
  return futrts_sinh32(x);
}

static inline f16 futrts_tanh16(f16 x) {
  return futrts_tanh32(x);
}

static inline f16 futrts_acosh16(f16 x) {
  return futrts_acosh32(x);
}

static inline f16 futrts_asinh16(f16 x) {
  return futrts_asinh32(x);
}

static inline f16 futrts_atanh16(f16 x) {
  return futrts_atanh32(x);
}

static inline f16 futrts_atan2_16(f16 x, f16 y) {
  return futrts_atan2_32(x, y);
}

static inline f16 futrts_hypot16(f16 x, f16 y) {
  return futrts_hypot32(x, y);
}

static inline f16 futrts_gamma16(f16 x) {
  return futrts_gamma32(x);
}

static inline f16 futrts_lgamma16(f16 x) {
  return futrts_lgamma32(x);
}

static inline f16 fmod16(f16 x, f16 y) {
  return fmod32(x, y);
}

static inline f16 futrts_round16(f16 x) {
  return futrts_round32(x);
}

static inline f16 futrts_floor16(f16 x) {
  return futrts_floor32(x);
}

static inline f16 futrts_ceil16(f16 x) {
  return futrts_ceil32(x);
}

static inline f16 futrts_lerp16(f16 v0, f16 v1, f16 t) {
  return futrts_lerp32(v0, v1, t);
}

static inline f16 futrts_mad16(f16 a, f16 b, f16 c) {
  return futrts_mad32(a, b, c);
}

static inline f16 futrts_fma16(f16 a, f16 b, f16 c) {
  return futrts_fma32(a, b, c);
}

// Even when we are using an OpenCL that does not support cl_khr_fp16,
// it must still support vload_half for actually creating a
// half-precision number, which can then be efficiently converted to a
// float.  Similarly for vstore_half.
#ifdef __OPENCL_VERSION__

static inline int16_t futrts_to_bits16(f16 x) {
  int16_t y;
  // Violating strict aliasing here.
  vstore_half((float)x, 0, (half*)&y);
  return y;
}

static inline f16 futrts_from_bits16(int16_t x) {
  return (f16)vload_half(0, (half*)&x);
}

#else

static inline int16_t futrts_to_bits16(f16 x) {
  return (int16_t)float2halfbits(x);
}

static inline f16 futrts_from_bits16(int16_t x) {
  return halfbits2float((uint16_t)x);
}

static inline f16 fsignum16(f16 x) {
  return futrts_isnan16(x) ? x : (x > 0) - (x < 0);
}

#endif

#endif

static inline float fpconv_f16_f16(f16 x) {
  return x;
}

static inline float fpconv_f16_f32(f16 x) {
  return x;
}

static inline f16 fpconv_f32_f16(float x) {
  return x;
}

#ifdef FUTHARK_F64_ENABLED

static inline double fpconv_f16_f64(f16 x) {
  return (double) x;
}

static inline f16 fpconv_f64_f16(double x) {
  return (f16) x;
}

#endif


// End of scalar_f16.h.

static int init_constants(struct futhark_context *);
static int free_constants(struct futhark_context *);
static int32_t mainzistatic_array_realtype_33587[3] = {2, 0, 0};
struct memblock {
    int *references;
    unsigned char *mem;
    int64_t size;
    const char *desc;
};
struct futhark_context_config {
    int debugging;
    int in_use;
};
struct futhark_context_config *futhark_context_config_new(void)
{
    struct futhark_context_config *cfg =
                                  (struct futhark_context_config *) malloc(sizeof(struct futhark_context_config));
    
    if (cfg == NULL)
        return NULL;
    cfg->in_use = 0;
    cfg->debugging = 0;
    return cfg;
}
void futhark_context_config_free(struct futhark_context_config *cfg)
{
    assert(!cfg->in_use);
    free(cfg);
}
void futhark_context_config_set_debugging(struct futhark_context_config *cfg,
                                          int detail)
{
    cfg->debugging = detail;
}
void futhark_context_config_set_profiling(struct futhark_context_config *cfg,
                                          int flag)
{
    (void) cfg;
    (void) flag;
}
void futhark_context_config_set_logging(struct futhark_context_config *cfg,
                                        int detail)
{
    // Does nothing for this backend.
    (void) cfg;
    (void) detail;
}
struct futhark_context {
    struct futhark_context_config *cfg;
    int detail_memory;
    int debugging;
    int profiling;
    int logging;
    lock_t lock;
    char *error;
    FILE *log;
    int profiling_paused;
    int64_t peak_mem_usage_default;
    int64_t cur_mem_usage_default;
    struct {
        int dummy;
    } constants;
    struct memblock mainzistatic_array_33500;
};
struct futhark_context *futhark_context_new(struct futhark_context_config *cfg)
{
    assert(!cfg->in_use);
    
    struct futhark_context *ctx =
                           (struct futhark_context *) malloc(sizeof(struct futhark_context));
    
    if (ctx == NULL)
        return NULL;
    ctx->cfg = cfg;
    ctx->cfg->in_use = 1;
    ctx->detail_memory = cfg->debugging;
    ctx->debugging = cfg->debugging;
    ctx->profiling = cfg->debugging;
    ctx->logging = cfg->debugging;
    ctx->error = NULL;
    ctx->log = stderr;
    create_lock(&ctx->lock);
    ctx->peak_mem_usage_default = 0;
    ctx->cur_mem_usage_default = 0;
    ctx->mainzistatic_array_33500 = (struct memblock) {NULL,
                                                       (char *) mainzistatic_array_realtype_33587,
                                                       0};
    init_constants(ctx);
    return ctx;
}
void futhark_context_free(struct futhark_context *ctx)
{
    free_constants(ctx);
    free_lock(&ctx->lock);
    ctx->cfg->in_use = 0;
    free(ctx);
}
int futhark_context_sync(struct futhark_context *ctx)
{
    (void) ctx;
    return 0;
}
static const char *tuning_param_names[0];
static const char *tuning_param_vars[0];
static const char *tuning_param_classes[0];
int futhark_context_config_set_tuning_param(struct futhark_context_config *cfg,
                                            const char *param_name,
                                            size_t param_value)
{
    (void) cfg;
    (void) param_name;
    (void) param_value;
    return 1;
}
static int memblock_unref(struct futhark_context *ctx, struct memblock *block,
                          const char *desc)
{
    if (block->references != NULL) {
        *block->references -= 1;
        if (ctx->detail_memory)
            fprintf(ctx->log,
                    "Unreferencing block %s (allocated as %s) in %s: %d references remaining.\n",
                    desc, block->desc, "default space", *block->references);
        if (*block->references == 0) {
            ctx->cur_mem_usage_default -= block->size;
            free(block->mem);
            free(block->references);
            if (ctx->detail_memory)
                fprintf(ctx->log,
                        "%lld bytes freed (now allocated: %lld bytes)\n",
                        (long long) block->size,
                        (long long) ctx->cur_mem_usage_default);
        }
        block->references = NULL;
    }
    return 0;
}
static int memblock_alloc(struct futhark_context *ctx, struct memblock *block,
                          int64_t size, const char *desc)
{
    if (size < 0)
        futhark_panic(1,
                      "Negative allocation of %lld bytes attempted for %s in %s.\n",
                      (long long) size, desc, "default space",
                      ctx->cur_mem_usage_default);
    
    int ret = memblock_unref(ctx, block, desc);
    
    if (ret != FUTHARK_SUCCESS)
        return ret;
    if (ctx->detail_memory)
        fprintf(ctx->log,
                "Allocating %lld bytes for %s in %s (then allocated: %lld bytes)",
                (long long) size, desc, "default space",
                (long long) ctx->cur_mem_usage_default + size);
    if (ctx->cur_mem_usage_default > ctx->peak_mem_usage_default) {
        ctx->peak_mem_usage_default = ctx->cur_mem_usage_default;
        if (ctx->detail_memory)
            fprintf(ctx->log, " (new peak).\n");
    } else if (ctx->detail_memory)
        fprintf(ctx->log, ".\n");
    block->mem = (unsigned char *) malloc((size_t) size);
    if (ctx->error == NULL) {
        block->references = (int *) malloc(sizeof(int));
        *block->references = 1;
        block->size = size;
        block->desc = desc;
        ctx->cur_mem_usage_default += size;
        return FUTHARK_SUCCESS;
    } else {
        char *old_error = ctx->error;
        
        ctx->error =
            msgprintf("Failed to allocate memory in %s.\nAttempted allocation: %12lld bytes\nCurrently allocated:  %12lld bytes\n%s",
                      "default space", (long long) size,
                      (long long) ctx->cur_mem_usage_default, old_error);
        free(old_error);
        return FUTHARK_OUT_OF_MEMORY;
    }
}
static int memblock_set(struct futhark_context *ctx, struct memblock *lhs,
                        struct memblock *rhs, const char *lhs_desc)
{
    int ret = memblock_unref(ctx, lhs, lhs_desc);
    
    if (rhs->references != NULL)
        (*rhs->references)++;
    *lhs = *rhs;
    return ret;
}
int futhark_get_tuning_param_count(void)
{
    return sizeof(tuning_param_names) / sizeof(tuning_param_names[0]);
}
const char *futhark_get_tuning_param_name(int i)
{
    return tuning_param_names[i];
}
const char *futhark_get_tuning_param_class(int i)
{
    return tuning_param_classes[i];
}
char *futhark_context_report(struct futhark_context *ctx)
{
    if (futhark_context_sync(ctx) != 0)
        return NULL;
    
    struct str_builder builder;
    
    str_builder_init(&builder);
    if (ctx->detail_memory || ctx->profiling || ctx->logging) {
        { }
    }
    if (ctx->profiling) { }
    return builder.str;
}
char *futhark_context_get_error(struct futhark_context *ctx)
{
    char *error = ctx->error;
    
    ctx->error = NULL;
    return error;
}
void futhark_context_set_logging_file(struct futhark_context *ctx, FILE *f)
{
    ctx->log = f;
}
void futhark_context_pause_profiling(struct futhark_context *ctx)
{
    ctx->profiling_paused = 1;
}
void futhark_context_unpause_profiling(struct futhark_context *ctx)
{
    ctx->profiling_paused = 0;
}
int futhark_context_clear_caches(struct futhark_context *ctx)
{
    lock_lock(&ctx->lock);
    ctx->peak_mem_usage_default = 0;
    lock_unlock(&ctx->lock);
    return ctx->error != NULL;
}

static int futrts_entry_main(struct futhark_context *ctx,
                             struct memblock *mem_out_p_33550,
                             struct memblock *mem_out_p_33551,
                             struct memblock *mem_out_p_33552,
                             struct memblock *mem_out_p_33553,
                             struct memblock *mem_out_p_33554,
                             struct memblock *mem_out_p_33555,
                             struct memblock *mem_out_p_33556,
                             struct memblock xps_mem_32337,
                             struct memblock yps_mem_32338,
                             struct memblock zzps_mem_32339,
                             struct memblock ms_mem_32340,
                             struct memblock xvs_mem_32341,
                             struct memblock yvs_mem_32342,
                             struct memblock zzvs_mem_32343, int64_t n_29481,
                             int32_t n_steps_29482, float epsilon_29483,
                             float time_step_29484);

static int init_constants(struct futhark_context *ctx)
{
    (void) ctx;
    
    int err = 0;
    
    
  cleanup:
    return err;
}
static int free_constants(struct futhark_context *ctx)
{
    (void) ctx;
    return 0;
}
struct futhark_f32_1d {
    struct memblock mem;
    int64_t shape[1];
};
struct futhark_f32_1d *futhark_new_f32_1d(struct futhark_context *ctx, const
                                          float *data, int64_t dim0)
{
    struct futhark_f32_1d *bad = NULL;
    struct futhark_f32_1d *arr =
                          (struct futhark_f32_1d *) malloc(sizeof(struct futhark_f32_1d));
    
    if (arr == NULL)
        return bad;
    lock_lock(&ctx->lock);
    arr->mem.references = NULL;
    if (memblock_alloc(ctx, &arr->mem, dim0 * 4, "arr->mem"))
        return NULL;
    arr->shape[0] = dim0;
    if ((size_t) dim0 * 4 > 0)
        memmove(arr->mem.mem + 0, data + 0, (size_t) dim0 * 4);
    lock_unlock(&ctx->lock);
    return arr;
}
struct futhark_f32_1d *futhark_new_raw_f32_1d(struct futhark_context *ctx, const
                                              unsigned char *data,
                                              int64_t offset, int64_t dim0)
{
    struct futhark_f32_1d *bad = NULL;
    struct futhark_f32_1d *arr =
                          (struct futhark_f32_1d *) malloc(sizeof(struct futhark_f32_1d));
    
    if (arr == NULL)
        return bad;
    lock_lock(&ctx->lock);
    arr->mem.references = NULL;
    if (memblock_alloc(ctx, &arr->mem, dim0 * 4, "arr->mem"))
        return NULL;
    arr->shape[0] = dim0;
    if ((size_t) dim0 * 4 > 0)
        memmove(arr->mem.mem + 0, data + offset, (size_t) dim0 * 4);
    lock_unlock(&ctx->lock);
    return arr;
}
int futhark_free_f32_1d(struct futhark_context *ctx, struct futhark_f32_1d *arr)
{
    lock_lock(&ctx->lock);
    if (memblock_unref(ctx, &arr->mem, "arr->mem") != 0)
        return 1;
    lock_unlock(&ctx->lock);
    free(arr);
    return 0;
}
int futhark_values_f32_1d(struct futhark_context *ctx,
                          struct futhark_f32_1d *arr, float *data)
{
    lock_lock(&ctx->lock);
    if ((size_t) arr->shape[0] * 4 > 0)
        memmove(data + 0, arr->mem.mem + 0, (size_t) arr->shape[0] * 4);
    lock_unlock(&ctx->lock);
    return 0;
}
unsigned char *futhark_values_raw_f32_1d(struct futhark_context *ctx,
                                         struct futhark_f32_1d *arr)
{
    (void) ctx;
    return arr->mem.mem;
}
const int64_t *futhark_shape_f32_1d(struct futhark_context *ctx,
                                    struct futhark_f32_1d *arr)
{
    (void) ctx;
    return arr->shape;
}

static int futrts_entry_main(struct futhark_context *ctx,
                             struct memblock *mem_out_p_33550,
                             struct memblock *mem_out_p_33551,
                             struct memblock *mem_out_p_33552,
                             struct memblock *mem_out_p_33553,
                             struct memblock *mem_out_p_33554,
                             struct memblock *mem_out_p_33555,
                             struct memblock *mem_out_p_33556,
                             struct memblock xps_mem_32337,
                             struct memblock yps_mem_32338,
                             struct memblock zzps_mem_32339,
                             struct memblock ms_mem_32340,
                             struct memblock xvs_mem_32341,
                             struct memblock yvs_mem_32342,
                             struct memblock zzvs_mem_32343, int64_t n_29481,
                             int32_t n_steps_29482, float epsilon_29483,
                             float time_step_29484)
{
    (void) ctx;
    
    int err = 0;
    size_t mem_32425_cached_sizze_33557 = 0;
    unsigned char *mem_32425 = NULL;
    size_t mem_32428_cached_sizze_33558 = 0;
    unsigned char *mem_32428 = NULL;
    size_t mem_32431_cached_sizze_33559 = 0;
    unsigned char *mem_32431 = NULL;
    size_t mem_32434_cached_sizze_33560 = 0;
    unsigned char *mem_32434 = NULL;
    size_t mem_32437_cached_sizze_33561 = 0;
    unsigned char *mem_32437 = NULL;
    size_t mem_32540_cached_sizze_33562 = 0;
    unsigned char *mem_32540 = NULL;
    size_t mem_32546_cached_sizze_33563 = 0;
    unsigned char *mem_32546 = NULL;
    size_t mem_32549_cached_sizze_33564 = 0;
    unsigned char *mem_32549 = NULL;
    size_t mem_32552_cached_sizze_33565 = 0;
    unsigned char *mem_32552 = NULL;
    size_t mem_32555_cached_sizze_33566 = 0;
    unsigned char *mem_32555 = NULL;
    size_t mem_32558_cached_sizze_33567 = 0;
    unsigned char *mem_32558 = NULL;
    size_t mem_32561_cached_sizze_33568 = 0;
    unsigned char *mem_32561 = NULL;
    size_t mem_32660_cached_sizze_33569 = 0;
    unsigned char *mem_32660 = NULL;
    size_t mem_32662_cached_sizze_33570 = 0;
    unsigned char *mem_32662 = NULL;
    size_t mem_32665_cached_sizze_33571 = 0;
    unsigned char *mem_32665 = NULL;
    size_t mem_32667_cached_sizze_33572 = 0;
    unsigned char *mem_32667 = NULL;
    size_t mem_32670_cached_sizze_33573 = 0;
    unsigned char *mem_32670 = NULL;
    size_t mem_32673_cached_sizze_33574 = 0;
    unsigned char *mem_32673 = NULL;
    size_t mem_32676_cached_sizze_33575 = 0;
    unsigned char *mem_32676 = NULL;
    size_t mem_32679_cached_sizze_33576 = 0;
    unsigned char *mem_32679 = NULL;
    size_t mem_32778_cached_sizze_33577 = 0;
    unsigned char *mem_32778 = NULL;
    size_t mem_32793_cached_sizze_33578 = 0;
    unsigned char *mem_32793 = NULL;
    size_t mem_32796_cached_sizze_33579 = 0;
    unsigned char *mem_32796 = NULL;
    size_t mem_32799_cached_sizze_33580 = 0;
    unsigned char *mem_32799 = NULL;
    size_t mem_32838_cached_sizze_33581 = 0;
    unsigned char *mem_32838 = NULL;
    size_t mem_32853_cached_sizze_33582 = 0;
    unsigned char *mem_32853 = NULL;
    size_t mem_32954_cached_sizze_33583 = 0;
    unsigned char *mem_32954 = NULL;
    size_t mem_32956_cached_sizze_33584 = 0;
    unsigned char *mem_32956 = NULL;
    size_t mem_32999_cached_sizze_33585 = 0;
    unsigned char *mem_32999 = NULL;
    size_t mem_33213_cached_sizze_33586 = 0;
    unsigned char *mem_33213 = NULL;
    struct memblock mem_33365;
    
    mem_33365.references = NULL;
    
    struct memblock mem_33361;
    
    mem_33361.references = NULL;
    
    struct memblock mem_33357;
    
    mem_33357.references = NULL;
    
    struct memblock mem_33353;
    
    mem_33353.references = NULL;
    
    struct memblock mem_33349;
    
    mem_33349.references = NULL;
    
    struct memblock mem_33345;
    
    mem_33345.references = NULL;
    
    struct memblock mem_33341;
    
    mem_33341.references = NULL;
    
    struct memblock mem_param_tmp_33424;
    
    mem_param_tmp_33424.references = NULL;
    
    struct memblock mem_param_tmp_33423;
    
    mem_param_tmp_33423.references = NULL;
    
    struct memblock mem_param_tmp_33422;
    
    mem_param_tmp_33422.references = NULL;
    
    struct memblock mem_param_tmp_33421;
    
    mem_param_tmp_33421.references = NULL;
    
    struct memblock mem_param_tmp_33420;
    
    mem_param_tmp_33420.references = NULL;
    
    struct memblock mem_param_tmp_33419;
    
    mem_param_tmp_33419.references = NULL;
    
    struct memblock mem_param_tmp_33418;
    
    mem_param_tmp_33418.references = NULL;
    
    struct memblock mem_33231;
    
    mem_33231.references = NULL;
    
    struct memblock mem_33228;
    
    mem_33228.references = NULL;
    
    struct memblock mem_33225;
    
    mem_33225.references = NULL;
    
    struct memblock mem_33222;
    
    mem_33222.references = NULL;
    
    struct memblock mem_33219;
    
    mem_33219.references = NULL;
    
    struct memblock mem_33216;
    
    mem_33216.references = NULL;
    
    struct memblock mem_param_tmp_33514;
    
    mem_param_tmp_33514.references = NULL;
    
    struct memblock mem_param_tmp_33513;
    
    mem_param_tmp_33513.references = NULL;
    
    struct memblock mem_param_tmp_33512;
    
    mem_param_tmp_33512.references = NULL;
    
    struct memblock mem_param_tmp_33511;
    
    mem_param_tmp_33511.references = NULL;
    
    struct memblock mem_param_tmp_33510;
    
    mem_param_tmp_33510.references = NULL;
    
    struct memblock mem_param_tmp_33509;
    
    mem_param_tmp_33509.references = NULL;
    
    struct memblock mem_param_tmp_33508;
    
    mem_param_tmp_33508.references = NULL;
    
    struct memblock mem_param_tmp_33507;
    
    mem_param_tmp_33507.references = NULL;
    
    struct memblock mem_33109;
    
    mem_33109.references = NULL;
    
    struct memblock mem_33106;
    
    mem_33106.references = NULL;
    
    struct memblock mem_33103;
    
    mem_33103.references = NULL;
    
    struct memblock mem_33100;
    
    mem_33100.references = NULL;
    
    struct memblock mem_33097;
    
    mem_33097.references = NULL;
    
    struct memblock mem_33093;
    
    mem_33093.references = NULL;
    
    struct memblock mem_33090;
    
    mem_33090.references = NULL;
    
    struct memblock mem_33087;
    
    mem_33087.references = NULL;
    
    struct memblock mem_param_33085;
    
    mem_param_33085.references = NULL;
    
    struct memblock mem_param_33080;
    
    mem_param_33080.references = NULL;
    
    struct memblock mem_param_33075;
    
    mem_param_33075.references = NULL;
    
    struct memblock mem_param_33070;
    
    mem_param_33070.references = NULL;
    
    struct memblock mem_param_33062;
    
    mem_param_33062.references = NULL;
    
    struct memblock mem_param_33057;
    
    mem_param_33057.references = NULL;
    
    struct memblock mem_param_33052;
    
    mem_param_33052.references = NULL;
    
    struct memblock mem_param_33047;
    
    mem_param_33047.references = NULL;
    
    struct memblock ext_mem_33169;
    
    ext_mem_33169.references = NULL;
    
    struct memblock ext_mem_33170;
    
    ext_mem_33170.references = NULL;
    
    struct memblock ext_mem_33171;
    
    ext_mem_33171.references = NULL;
    
    struct memblock ext_mem_33172;
    
    ext_mem_33172.references = NULL;
    
    struct memblock ext_mem_33173;
    
    ext_mem_33173.references = NULL;
    
    struct memblock ext_mem_33174;
    
    ext_mem_33174.references = NULL;
    
    struct memblock ext_mem_33175;
    
    ext_mem_33175.references = NULL;
    
    struct memblock ext_mem_33176;
    
    ext_mem_33176.references = NULL;
    
    struct memblock mem_32890;
    
    mem_32890.references = NULL;
    
    struct memblock mem_32887;
    
    mem_32887.references = NULL;
    
    struct memblock mem_32884;
    
    mem_32884.references = NULL;
    
    struct memblock mem_32882;
    
    mem_32882.references = NULL;
    
    struct memblock mem_32878;
    
    mem_32878.references = NULL;
    
    struct memblock mem_32875;
    
    mem_32875.references = NULL;
    
    struct memblock mem_32872;
    
    mem_32872.references = NULL;
    
    struct memblock mem_32869;
    
    mem_32869.references = NULL;
    
    struct memblock mem_32543;
    
    mem_32543.references = NULL;
    
    struct memblock mem_param_tmp_33440;
    
    mem_param_tmp_33440.references = NULL;
    
    struct memblock mem_param_tmp_33439;
    
    mem_param_tmp_33439.references = NULL;
    
    struct memblock mem_32503;
    
    mem_32503.references = NULL;
    
    struct memblock mem_32500;
    
    mem_32500.references = NULL;
    
    struct memblock mem_param_32420;
    
    mem_param_32420.references = NULL;
    
    struct memblock mem_param_32415;
    
    mem_param_32415.references = NULL;
    
    struct memblock ext_mem_32528;
    
    ext_mem_32528.references = NULL;
    
    struct memblock ext_mem_32529;
    
    ext_mem_32529.references = NULL;
    
    struct memblock mem_param_32381;
    
    mem_param_32381.references = NULL;
    
    struct memblock mem_param_32376;
    
    mem_param_32376.references = NULL;
    
    struct memblock mem_param_32371;
    
    mem_param_32371.references = NULL;
    
    struct memblock mem_param_32366;
    
    mem_param_32366.references = NULL;
    
    struct memblock mem_param_32361;
    
    mem_param_32361.references = NULL;
    
    struct memblock mem_param_32356;
    
    mem_param_32356.references = NULL;
    
    struct memblock mem_param_32351;
    
    mem_param_32351.references = NULL;
    
    struct memblock ext_mem_33304;
    
    ext_mem_33304.references = NULL;
    
    struct memblock ext_mem_33305;
    
    ext_mem_33305.references = NULL;
    
    struct memblock ext_mem_33306;
    
    ext_mem_33306.references = NULL;
    
    struct memblock ext_mem_33307;
    
    ext_mem_33307.references = NULL;
    
    struct memblock ext_mem_33308;
    
    ext_mem_33308.references = NULL;
    
    struct memblock ext_mem_33309;
    
    ext_mem_33309.references = NULL;
    
    struct memblock ext_mem_33310;
    
    ext_mem_33310.references = NULL;
    
    struct memblock mem_32398;
    
    mem_32398.references = NULL;
    
    struct memblock mem_32346;
    
    mem_32346.references = NULL;
    
    struct memblock mem_out_33415;
    
    mem_out_33415.references = NULL;
    
    struct memblock mem_out_33414;
    
    mem_out_33414.references = NULL;
    
    struct memblock mem_out_33413;
    
    mem_out_33413.references = NULL;
    
    struct memblock mem_out_33412;
    
    mem_out_33412.references = NULL;
    
    struct memblock mem_out_33411;
    
    mem_out_33411.references = NULL;
    
    struct memblock mem_out_33410;
    
    mem_out_33410.references = NULL;
    
    struct memblock mem_out_33409;
    
    mem_out_33409.references = NULL;
    
    bool loop_nonempty_29492 = slt32(0, n_steps_29482);
    bool cond_29493 = n_29481 == (int64_t) 0;
    int32_t iters_29494;
    
    if (cond_29493) {
        iters_29494 = 0;
    } else {
        iters_29494 = 16;
    }
    
    bool loop_nonempty_29495 = slt32(0, iters_29494);
    int64_t i_29496 = sub64(n_29481, (int64_t) 1);
    bool x_29497 = sle64((int64_t) 0, i_29496);
    bool y_29498 = slt64(i_29496, n_29481);
    bool bounds_check_29499 = x_29497 && y_29498;
    bool loop_not_taken_29500 = !loop_nonempty_29495;
    bool protect_assert_disj_29501 = bounds_check_29499 || loop_not_taken_29500;
    bool loop_not_taken_29502 = !loop_nonempty_29492;
    bool protect_assert_disj_29503 = protect_assert_disj_29501 ||
         loop_not_taken_29502;
    bool index_certs_29504;
    
    if (!protect_assert_disj_29503) {
        ctx->error = msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                               "Index [", (long long) i_29496,
                               "] out of bounds for array of shape [",
                               (long long) n_29481, "].",
                               "-> #0  /prelude/array.fut:26:29-34\n   #1  sample_programs/lib/github.com/diku-dk/sorts/radix_sort.fut:25:24-35\n   #2  sample_programs/lib/github.com/diku-dk/sorts/radix_sort.fut:53:31-62\n   #3  /prelude/functional.fut:9:42-44\n   #4  sample_programs/lib/github.com/diku-dk/sorts/radix_sort.fut:59:3-61:47\n   #5  sample_programs/lib/github.com/diku-dk/sorts/radix_sort.fut:68:3-51\n   #6  sample_programs/octree.fut:197:5-79\n   #7  sample_programs/nbody.fut:62:5-25\n   #8  sample_programs/nbody.fut:69:26-57\n   #9  sample_programs/nbody.fut:75:5-49\n   #10 sample_programs/nbody.fut:102:17-75\n   #11 sample_programs/nbody.fut:89:1-106:46\n");
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t k_29505 = mul64((int64_t) 2, i_29496);
    int64_t conc_tmp_29506 = i_29496 + i_29496;
    bool dim_match_29507 = k_29505 == conc_tmp_29506;
    bool protect_assert_disj_29508 = loop_not_taken_29502 || dim_match_29507;
    bool empty_or_match_cert_29509;
    
    if (!protect_assert_disj_29508) {
        ctx->error = msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                               "Value of (core language) shape (",
                               (long long) conc_tmp_29506,
                               ") cannot match shape of type `*[",
                               (long long) k_29505, "]t`.",
                               "-> #0  /prelude/array.fut:73:66-82\n   #1  sample_programs/radixtree.fut:76:26-78:55\n   #2  sample_programs/octree.fut:199:16-36\n   #3  sample_programs/nbody.fut:62:5-25\n   #4  sample_programs/nbody.fut:69:26-57\n   #5  sample_programs/nbody.fut:75:5-49\n   #6  sample_programs/nbody.fut:102:17-75\n   #7  sample_programs/nbody.fut:89:1-106:46\n");
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    bool y_29510 = slt64((int64_t) 0, i_29496);
    bool protect_assert_disj_29511 = loop_not_taken_29502 || y_29510;
    bool index_certs_29512;
    
    if (!protect_assert_disj_29511) {
        ctx->error = msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                               "Index [", (long long) (int64_t) 0,
                               "] out of bounds for array of shape [",
                               (long long) i_29496, "].",
                               "-> #0  sample_programs/octree.fut:26:20-28\n   #1  sample_programs/octree.fut:201:16-38\n   #2  sample_programs/nbody.fut:62:5-25\n   #3  sample_programs/nbody.fut:69:26-57\n   #4  sample_programs/nbody.fut:75:5-49\n   #5  sample_programs/nbody.fut:102:17-75\n   #6  sample_programs/nbody.fut:89:1-106:46\n");
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t i_29513 = sub64(i_29496, (int64_t) 1);
    bool x_29514 = sle64((int64_t) 0, i_29513);
    bool y_29515 = slt64(i_29513, i_29496);
    bool bounds_check_29516 = x_29514 && y_29515;
    bool protect_assert_disj_29517 = loop_not_taken_29502 || bounds_check_29516;
    bool index_certs_29518;
    
    if (!protect_assert_disj_29517) {
        ctx->error = msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                               "Index [", (long long) i_29513,
                               "] out of bounds for array of shape [",
                               (long long) i_29496, "].",
                               "-> #0  /prelude/array.fut:26:29-34\n   #1  sample_programs/octree.fut:41:23-37\n   #2  sample_programs/octree.fut:201:16-38\n   #3  sample_programs/nbody.fut:62:5-25\n   #4  sample_programs/nbody.fut:69:26-57\n   #5  sample_programs/nbody.fut:75:5-49\n   #6  sample_programs/nbody.fut:102:17-75\n   #7  sample_programs/nbody.fut:89:1-106:46\n");
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    bool empty_slice_29519 = i_29513 == (int64_t) 0;
    bool i_lte_j_29520 = sle64((int64_t) 1, i_29496);
    bool y_29521 = bounds_check_29516 && i_lte_j_29520;
    bool ok_or_empty_29522 = empty_slice_29519 || y_29521;
    bool protect_assert_disj_29523 = loop_not_taken_29502 || ok_or_empty_29522;
    bool index_certs_29524;
    
    if (!protect_assert_disj_29523) {
        ctx->error = msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                               "Index [", (long long) (int64_t) 1,
                               ":] out of bounds for array of shape [",
                               (long long) i_29496, "].",
                               "-> #0  /prelude/array.fut:31:29-33\n   #1  sample_programs/octree.fut:43:46-56\n   #2  sample_programs/octree.fut:201:16-38\n   #3  sample_programs/nbody.fut:62:5-25\n   #4  sample_programs/nbody.fut:69:26-57\n   #5  sample_programs/nbody.fut:75:5-49\n   #6  sample_programs/nbody.fut:102:17-75\n   #7  sample_programs/nbody.fut:89:1-106:46\n");
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int64_t binop_y_32344 = (int64_t) 8 * n_29481;
    int64_t bytes_32345 = smax64((int64_t) 0, binop_y_32344);
    
    if (memblock_alloc(ctx, &mem_32346, bytes_32345, "mem_32346")) {
        err = 1;
        goto cleanup;
    }
    for (int64_t i_33416 = 0; i_33416 < n_29481; i_33416++) {
        int64_t x_33417 = (int64_t) 0 + i_33416 * (int64_t) 1;
        
        ((int64_t *) mem_32346.mem)[i_33416] = x_33417;
    }
    
    bool bounds_invalid_upwards_29527 = slt64(i_29496, (int64_t) 0);
    bool valid_29528 = !bounds_invalid_upwards_29527;
    bool protect_assert_disj_29529 = loop_not_taken_29502 || valid_29528;
    bool range_valid_c_29530;
    
    if (!protect_assert_disj_29529) {
        ctx->error = msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s",
                               "Range ", (long long) (int64_t) 0, "..",
                               (long long) (int64_t) 1, "..<",
                               (long long) i_29496, " is invalid.",
                               "-> #0  /prelude/array.fut:90:3-10\n   #1  /prelude/array.fut:195:11-16\n   #2  sample_programs/radixtree.fut:70:40-58\n   #3  sample_programs/octree.fut:199:16-36\n   #4  sample_programs/nbody.fut:62:5-25\n   #5  sample_programs/nbody.fut:69:26-57\n   #6  sample_programs/nbody.fut:75:5-49\n   #7  sample_programs/nbody.fut:102:17-75\n   #8  sample_programs/nbody.fut:89:1-106:46\n");
        err = FUTHARK_PROGRAM_ERROR;
        goto cleanup;
    }
    
    int32_t i64_res_29532 = sext_i64_i32(n_29481);
    int64_t binop_y_32396 = (int64_t) 4 * n_29481;
    int64_t bytes_32397 = smax64((int64_t) 0, binop_y_32396);
    
    if (memblock_alloc(ctx, &mem_32398, bytes_32397, "mem_32398")) {
        err = 1;
        goto cleanup;
    }
    if (mem_32425_cached_sizze_33557 < bytes_32345) {
        err = lexical_realloc(&ctx->error, &mem_32425,
                              &mem_32425_cached_sizze_33557, bytes_32345);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_32428_cached_sizze_33558 < bytes_32345) {
        err = lexical_realloc(&ctx->error, &mem_32428,
                              &mem_32428_cached_sizze_33558, bytes_32345);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_32431_cached_sizze_33559 < bytes_32345) {
        err = lexical_realloc(&ctx->error, &mem_32431,
                              &mem_32431_cached_sizze_33559, bytes_32345);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_32434_cached_sizze_33560 < bytes_32345) {
        err = lexical_realloc(&ctx->error, &mem_32434,
                              &mem_32434_cached_sizze_33560, bytes_32345);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_32437_cached_sizze_33561 < bytes_32397) {
        err = lexical_realloc(&ctx->error, &mem_32437,
                              &mem_32437_cached_sizze_33561, bytes_32397);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_32540_cached_sizze_33562 < bytes_32397) {
        err = lexical_realloc(&ctx->error, &mem_32540,
                              &mem_32540_cached_sizze_33562, bytes_32397);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_32546_cached_sizze_33563 < bytes_32397) {
        err = lexical_realloc(&ctx->error, &mem_32546,
                              &mem_32546_cached_sizze_33563, bytes_32397);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_32549_cached_sizze_33564 < bytes_32397) {
        err = lexical_realloc(&ctx->error, &mem_32549,
                              &mem_32549_cached_sizze_33564, bytes_32397);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_32552_cached_sizze_33565 < bytes_32397) {
        err = lexical_realloc(&ctx->error, &mem_32552,
                              &mem_32552_cached_sizze_33565, bytes_32397);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_32555_cached_sizze_33566 < bytes_32397) {
        err = lexical_realloc(&ctx->error, &mem_32555,
                              &mem_32555_cached_sizze_33566, bytes_32397);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_32558_cached_sizze_33567 < bytes_32397) {
        err = lexical_realloc(&ctx->error, &mem_32558,
                              &mem_32558_cached_sizze_33567, bytes_32397);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_32561_cached_sizze_33568 < bytes_32397) {
        err = lexical_realloc(&ctx->error, &mem_32561,
                              &mem_32561_cached_sizze_33568, bytes_32397);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    
    int64_t binop_y_32658 = (int64_t) 4 * i_29496;
    int64_t bytes_32659 = smax64((int64_t) 0, binop_y_32658);
    
    if (mem_32660_cached_sizze_33569 < bytes_32659) {
        err = lexical_realloc(&ctx->error, &mem_32660,
                              &mem_32660_cached_sizze_33569, bytes_32659);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    
    int64_t bytes_32661 = smax64((int64_t) 0, i_29496);
    
    if (mem_32662_cached_sizze_33570 < bytes_32661) {
        err = lexical_realloc(&ctx->error, &mem_32662,
                              &mem_32662_cached_sizze_33570, bytes_32661);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_32665_cached_sizze_33571 < bytes_32659) {
        err = lexical_realloc(&ctx->error, &mem_32665,
                              &mem_32665_cached_sizze_33571, bytes_32659);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_32667_cached_sizze_33572 < bytes_32661) {
        err = lexical_realloc(&ctx->error, &mem_32667,
                              &mem_32667_cached_sizze_33572, bytes_32661);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_32670_cached_sizze_33573 < bytes_32659) {
        err = lexical_realloc(&ctx->error, &mem_32670,
                              &mem_32670_cached_sizze_33573, bytes_32659);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_32673_cached_sizze_33574 < bytes_32659) {
        err = lexical_realloc(&ctx->error, &mem_32673,
                              &mem_32673_cached_sizze_33574, bytes_32659);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_32676_cached_sizze_33575 < bytes_32659) {
        err = lexical_realloc(&ctx->error, &mem_32676,
                              &mem_32676_cached_sizze_33575, bytes_32659);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_32679_cached_sizze_33576 < bytes_32659) {
        err = lexical_realloc(&ctx->error, &mem_32679,
                              &mem_32679_cached_sizze_33576, bytes_32659);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_32778_cached_sizze_33577 < bytes_32659) {
        err = lexical_realloc(&ctx->error, &mem_32778,
                              &mem_32778_cached_sizze_33577, bytes_32659);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_32793_cached_sizze_33578 < bytes_32659) {
        err = lexical_realloc(&ctx->error, &mem_32793,
                              &mem_32793_cached_sizze_33578, bytes_32659);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_32796_cached_sizze_33579 < bytes_32659) {
        err = lexical_realloc(&ctx->error, &mem_32796,
                              &mem_32796_cached_sizze_33579, bytes_32659);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_32799_cached_sizze_33580 < bytes_32659) {
        err = lexical_realloc(&ctx->error, &mem_32799,
                              &mem_32799_cached_sizze_33580, bytes_32659);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_32838_cached_sizze_33581 < bytes_32659) {
        err = lexical_realloc(&ctx->error, &mem_32838,
                              &mem_32838_cached_sizze_33581, bytes_32659);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_32954_cached_sizze_33583 < (int64_t) 32) {
        err = lexical_realloc(&ctx->error, &mem_32954,
                              &mem_32954_cached_sizze_33583, (int64_t) 32);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_32956_cached_sizze_33584 < (int64_t) 12) {
        err = lexical_realloc(&ctx->error, &mem_32956,
                              &mem_32956_cached_sizze_33584, (int64_t) 12);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_32999_cached_sizze_33585 < (int64_t) 32) {
        err = lexical_realloc(&ctx->error, &mem_32999,
                              &mem_32999_cached_sizze_33585, (int64_t) 32);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (mem_33213_cached_sizze_33586 < (int64_t) 12) {
        err = lexical_realloc(&ctx->error, &mem_33213,
                              &mem_33213_cached_sizze_33586, (int64_t) 12);
        if (err != FUTHARK_SUCCESS)
            goto cleanup;
    }
    if (memblock_set(ctx, &mem_param_32351, &ms_mem_32340, "ms_mem_32340") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_32356, &xps_mem_32337, "xps_mem_32337") !=
        0)
        return 1;
    if (memblock_set(ctx, &mem_param_32361, &yps_mem_32338, "yps_mem_32338") !=
        0)
        return 1;
    if (memblock_set(ctx, &mem_param_32366, &zzps_mem_32339,
                     "zzps_mem_32339") != 0)
        return 1;
    if (memblock_set(ctx, &mem_param_32371, &xvs_mem_32341, "xvs_mem_32341") !=
        0)
        return 1;
    if (memblock_set(ctx, &mem_param_32376, &yvs_mem_32342, "yvs_mem_32342") !=
        0)
        return 1;
    if (memblock_set(ctx, &mem_param_32381, &zzvs_mem_32343,
                     "zzvs_mem_32343") != 0)
        return 1;
    for (int32_t _i_29540 = 0; _i_29540 < n_steps_29482; _i_29540++) {
        float defunc_2_reduce_res_29573;
        float defunc_2_reduce_res_29574;
        float defunc_2_reduce_res_29575;
        float defunc_2_reduce_res_29576;
        float defunc_2_reduce_res_29577;
        float defunc_2_reduce_res_29578;
        float redout_31864;
        float redout_31865;
        float redout_31866;
        float redout_31867;
        float redout_31868;
        float redout_31869;
        
        redout_31864 = -INFINITY;
        redout_31865 = -INFINITY;
        redout_31866 = -INFINITY;
        redout_31867 = INFINITY;
        redout_31868 = INFINITY;
        redout_31869 = INFINITY;
        for (int64_t i_31870 = 0; i_31870 < n_29481; i_31870++) {
            float x_29597;
            
            x_29597 = ((float *) mem_param_32356.mem)[i_31870];
            
            float x_29598;
            
            x_29598 = ((float *) mem_param_32361.mem)[i_31870];
            
            float x_29599;
            
            x_29599 = ((float *) mem_param_32366.mem)[i_31870];
            
            float defunc_1_op_res_29581 = fmax32(x_29597, redout_31864);
            float defunc_1_op_res_29584 = fmax32(x_29598, redout_31865);
            float defunc_1_op_res_29587 = fmax32(x_29599, redout_31866);
            float defunc_1_op_res_29590 = fmin32(x_29597, redout_31867);
            float defunc_1_op_res_29593 = fmin32(x_29598, redout_31868);
            float defunc_1_op_res_29596 = fmin32(x_29599, redout_31869);
            float redout_tmp_33432 = defunc_1_op_res_29581;
            float redout_tmp_33433 = defunc_1_op_res_29584;
            float redout_tmp_33434 = defunc_1_op_res_29587;
            float redout_tmp_33435 = defunc_1_op_res_29590;
            float redout_tmp_33436 = defunc_1_op_res_29593;
            float redout_tmp_33437 = defunc_1_op_res_29596;
            
            redout_31864 = redout_tmp_33432;
            redout_31865 = redout_tmp_33433;
            redout_31866 = redout_tmp_33434;
            redout_31867 = redout_tmp_33435;
            redout_31868 = redout_tmp_33436;
            redout_31869 = redout_tmp_33437;
        }
        defunc_2_reduce_res_29573 = redout_31864;
        defunc_2_reduce_res_29574 = redout_31865;
        defunc_2_reduce_res_29575 = redout_31866;
        defunc_2_reduce_res_29576 = redout_31867;
        defunc_2_reduce_res_29577 = redout_31868;
        defunc_2_reduce_res_29578 = redout_31869;
        
        float y_29606 = defunc_2_reduce_res_29573 - defunc_2_reduce_res_29576;
        float y_29607 = defunc_2_reduce_res_29574 - defunc_2_reduce_res_29577;
        float y_29608 = defunc_2_reduce_res_29575 - defunc_2_reduce_res_29578;
        
        for (int64_t i_31873 = 0; i_31873 < n_29481; i_31873++) {
            float x_29610;
            
            x_29610 = ((float *) mem_param_32356.mem)[i_31873];
            
            float x_29611;
            
            x_29611 = ((float *) mem_param_32361.mem)[i_31873];
            
            float x_29612;
            
            x_29612 = ((float *) mem_param_32366.mem)[i_31873];
            
            float x_29613 = x_29610 - defunc_2_reduce_res_29576;
            float defunc_0_f_res_29614 = x_29613 / y_29606;
            float x_29615 = x_29611 - defunc_2_reduce_res_29577;
            float defunc_0_f_res_29616 = x_29615 / y_29607;
            float x_29617 = x_29612 - defunc_2_reduce_res_29578;
            float defunc_0_f_res_29618 = x_29617 / y_29608;
            float max_arg_29619 = 1024.0F * defunc_0_f_res_29614;
            float max_res_29620 = fmax32(0.0F, max_arg_29619);
            float min_res_29621 = fmin32(1023.0F, max_res_29620);
            float max_arg_29622 = 1024.0F * defunc_0_f_res_29616;
            float max_res_29623 = fmax32(0.0F, max_arg_29622);
            float min_res_29624 = fmin32(1023.0F, max_res_29623);
            float max_arg_29625 = 1024.0F * defunc_0_f_res_29618;
            float max_res_29626 = fmax32(0.0F, max_arg_29625);
            float min_res_29627 = fmin32(1023.0F, max_res_29626);
            int32_t unsign_arg_29628 = fptoui_f32_i32(min_res_29621);
            int32_t x_29629 = mul32(65537, unsign_arg_29628);
            int32_t v_29630 = -16776961 & x_29629;
            int32_t x_29631 = mul32(257, v_29630);
            int32_t v_29632 = 251719695 & x_29631;
            int32_t x_29633 = mul32(17, v_29632);
            int32_t v_29634 = -1022611261 & x_29633;
            int32_t x_29635 = mul32(5, v_29634);
            int32_t v_29636 = 1227133513 & x_29635;
            int32_t unsign_arg_29637 = fptoui_f32_i32(min_res_29624);
            int32_t x_29638 = mul32(65537, unsign_arg_29637);
            int32_t v_29639 = -16776961 & x_29638;
            int32_t x_29640 = mul32(257, v_29639);
            int32_t v_29641 = 251719695 & x_29640;
            int32_t x_29642 = mul32(17, v_29641);
            int32_t v_29643 = -1022611261 & x_29642;
            int32_t x_29644 = mul32(5, v_29643);
            int32_t v_29645 = 1227133513 & x_29644;
            int32_t unsign_arg_29646 = fptoui_f32_i32(min_res_29627);
            int32_t x_29647 = mul32(65537, unsign_arg_29646);
            int32_t v_29648 = -16776961 & x_29647;
            int32_t x_29649 = mul32(257, v_29648);
            int32_t v_29650 = 251719695 & x_29649;
            int32_t x_29651 = mul32(17, v_29650);
            int32_t v_29652 = -1022611261 & x_29651;
            int32_t x_29653 = mul32(5, v_29652);
            int32_t v_29654 = 1227133513 & x_29653;
            int32_t x_29655 = mul32(4, v_29636);
            int32_t y_29656 = mul32(2, v_29645);
            int32_t x_29657 = add32(x_29655, y_29656);
            int32_t defunc_0_g_res_29658 = add32(v_29654, x_29657);
            
            ((int32_t *) mem_32398.mem)[i_31873] = defunc_0_g_res_29658;
        }
        if (memblock_set(ctx, &mem_param_32415, &mem_32398, "mem_32398") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_32420, &mem_32346, "mem_32346") != 0)
            return 1;
        for (int32_t i_29661 = 0; i_29661 < iters_29494; i_29661++) {
            int32_t defunc_2_radix_sort_step_arg_29664 = mul32(2, i_29661);
            int32_t defunc_0_get_bit_arg_29665 = add32(1,
                                                       defunc_2_radix_sort_step_arg_29664);
            int64_t discard_31895;
            int64_t discard_31896;
            int64_t discard_31897;
            int64_t discard_31898;
            int64_t scanacc_31880;
            int64_t scanacc_31881;
            int64_t scanacc_31882;
            int64_t scanacc_31883;
            
            scanacc_31880 = (int64_t) 0;
            scanacc_31881 = (int64_t) 0;
            scanacc_31882 = (int64_t) 0;
            scanacc_31883 = (int64_t) 0;
            for (int64_t i_31889 = 0; i_31889 < n_29481; i_31889++) {
                int32_t x_29667;
                
                x_29667 = ((int32_t *) mem_param_32415.mem)[i_31889];
                
                int32_t unsign_arg_29668 = ashr32(x_29667,
                                                  defunc_0_get_bit_arg_29665);
                int32_t unsign_arg_29669 = 1 & unsign_arg_29668;
                int32_t x_29670 = mul32(2, unsign_arg_29669);
                int32_t unsign_arg_29671 = ashr32(x_29667,
                                                  defunc_2_radix_sort_step_arg_29664);
                int32_t unsign_arg_29672 = 1 & unsign_arg_29671;
                int32_t defunc_0_f_res_29673 = add32(x_29670, unsign_arg_29672);
                bool cond_29709 = defunc_0_f_res_29673 == 0;
                int64_t defunc_0_f_res_29710 = btoi_bool_i64(cond_29709);
                int64_t defunc_0_f_res_29711;
                int64_t defunc_0_f_res_29712;
                int64_t defunc_0_f_res_29713;
                
                if (cond_29709) {
                    defunc_0_f_res_29711 = (int64_t) 0;
                    defunc_0_f_res_29712 = (int64_t) 0;
                    defunc_0_f_res_29713 = (int64_t) 0;
                } else {
                    bool cond_31399 = defunc_0_f_res_29673 == 1;
                    int64_t defunc_0_f_res_f_res_31400 =
                            btoi_bool_i64(cond_31399);
                    int64_t defunc_0_f_res_f_res_31401;
                    int64_t defunc_0_f_res_f_res_31402;
                    
                    if (cond_31399) {
                        defunc_0_f_res_f_res_31401 = (int64_t) 0;
                        defunc_0_f_res_f_res_31402 = (int64_t) 0;
                    } else {
                        bool cond_31403 = defunc_0_f_res_29673 == 2;
                        int64_t defunc_0_f_res_f_res_f_res_31404 =
                                btoi_bool_i64(cond_31403);
                        bool cond_neg_31405 = !cond_31403;
                        int64_t defunc_0_f_res_f_res_f_res_31406 =
                                btoi_bool_i64(cond_neg_31405);
                        
                        defunc_0_f_res_f_res_31401 =
                            defunc_0_f_res_f_res_f_res_31404;
                        defunc_0_f_res_f_res_31402 =
                            defunc_0_f_res_f_res_f_res_31406;
                    }
                    defunc_0_f_res_29711 = defunc_0_f_res_f_res_31400;
                    defunc_0_f_res_29712 = defunc_0_f_res_f_res_31401;
                    defunc_0_f_res_29713 = defunc_0_f_res_f_res_31402;
                }
                
                int64_t defunc_1_op_res_29704 = add64(defunc_0_f_res_29710,
                                                      scanacc_31880);
                int64_t defunc_1_op_res_29705 = add64(defunc_0_f_res_29711,
                                                      scanacc_31881);
                int64_t defunc_1_op_res_29706 = add64(defunc_0_f_res_29712,
                                                      scanacc_31882);
                int64_t defunc_1_op_res_29707 = add64(defunc_0_f_res_29713,
                                                      scanacc_31883);
                
                ((int64_t *) mem_32425)[i_31889] = defunc_1_op_res_29704;
                ((int64_t *) mem_32428)[i_31889] = defunc_1_op_res_29705;
                ((int64_t *) mem_32431)[i_31889] = defunc_1_op_res_29706;
                ((int64_t *) mem_32434)[i_31889] = defunc_1_op_res_29707;
                ((int32_t *) mem_32437)[i_31889] = defunc_0_f_res_29673;
                
                int64_t scanacc_tmp_33443 = defunc_1_op_res_29704;
                int64_t scanacc_tmp_33444 = defunc_1_op_res_29705;
                int64_t scanacc_tmp_33445 = defunc_1_op_res_29706;
                int64_t scanacc_tmp_33446 = defunc_1_op_res_29707;
                
                scanacc_31880 = scanacc_tmp_33443;
                scanacc_31881 = scanacc_tmp_33444;
                scanacc_31882 = scanacc_tmp_33445;
                scanacc_31883 = scanacc_tmp_33446;
            }
            discard_31895 = scanacc_31880;
            discard_31896 = scanacc_31881;
            discard_31897 = scanacc_31882;
            discard_31898 = scanacc_31883;
            
            int64_t last_res_29726;
            
            last_res_29726 = ((int64_t *) mem_32425)[i_29496];
            
            int64_t last_res_29727;
            
            last_res_29727 = ((int64_t *) mem_32428)[i_29496];
            
            int64_t last_res_29728;
            
            last_res_29728 = ((int64_t *) mem_32431)[i_29496];
            if (memblock_alloc(ctx, &mem_32500, bytes_32397, "mem_32500")) {
                err = 1;
                goto cleanup;
            }
            if (n_29481 * (int64_t) 4 > 0)
                memmove(mem_32500.mem + (int64_t) 0, mem_param_32415.mem +
                        (int64_t) 0, n_29481 * (int64_t) 4);
            if (memblock_alloc(ctx, &mem_32503, bytes_32345, "mem_32503")) {
                err = 1;
                goto cleanup;
            }
            if (n_29481 * (int64_t) 8 > 0)
                memmove(mem_32503.mem + (int64_t) 0, mem_param_32420.mem +
                        (int64_t) 0, n_29481 * (int64_t) 8);
            for (int64_t write_iter_31899 = 0; write_iter_31899 < n_29481;
                 write_iter_31899++) {
                int32_t write_iv_31902;
                
                write_iv_31902 = ((int32_t *) mem_32437)[write_iter_31899];
                
                int64_t write_iv_31903;
                
                write_iv_31903 = ((int64_t *) mem_32425)[write_iter_31899];
                
                int64_t write_iv_31904;
                
                write_iv_31904 = ((int64_t *) mem_32428)[write_iter_31899];
                
                int64_t write_iv_31905;
                
                write_iv_31905 = ((int64_t *) mem_32431)[write_iter_31899];
                
                int64_t write_iv_31906;
                
                write_iv_31906 = ((int64_t *) mem_32434)[write_iter_31899];
                
                bool match_lit_29762 = 0 == write_iv_31902;
                int64_t defunc_1_f_res_29763;
                
                if (match_lit_29762) {
                    int64_t case_res_29764 = sub64(write_iv_31903, (int64_t) 1);
                    
                    defunc_1_f_res_29763 = case_res_29764;
                } else {
                    bool match_lit_31420 = 1 == write_iv_31902;
                    int64_t x_31421;
                    
                    if (match_lit_31420) {
                        int64_t x_31422 = add64(last_res_29726, write_iv_31904);
                        int64_t case_res_31423 = sub64(x_31422, (int64_t) 1);
                        
                        x_31421 = case_res_31423;
                    } else {
                        bool match_lit_31424 = 2 == write_iv_31902;
                        int64_t x_31425;
                        
                        if (match_lit_31424) {
                            int64_t x_31426 = add64(last_res_29726,
                                                    last_res_29727);
                            int64_t x_31427 = add64(x_31426, write_iv_31905);
                            int64_t case_res_31428 = sub64(x_31427,
                                                           (int64_t) 1);
                            
                            x_31425 = case_res_31428;
                        } else {
                            int64_t x_31429 = add64(last_res_29726,
                                                    last_res_29727);
                            int64_t x_31430 = add64(last_res_29728, x_31429);
                            int64_t x_31431 = add64(x_31430, write_iv_31906);
                            int64_t defunc_1_f_res_res_31432 = sub64(x_31431,
                                                                     (int64_t) 1);
                            
                            x_31425 = defunc_1_f_res_res_31432;
                        }
                        x_31421 = x_31425;
                    }
                    defunc_1_f_res_29763 = x_31421;
                }
                if (sle64((int64_t) 0, defunc_1_f_res_29763) &&
                    slt64(defunc_1_f_res_29763, n_29481)) {
                    if ((int64_t) 4 > 0)
                        memmove(mem_32500.mem + defunc_1_f_res_29763 *
                                (int64_t) 4, mem_param_32415.mem +
                                ((int64_t) 0 + (int64_t) 1 * write_iter_31899) *
                                (int64_t) 4, (int64_t) 4);
                }
                if (sle64((int64_t) 0, defunc_1_f_res_29763) &&
                    slt64(defunc_1_f_res_29763, n_29481)) {
                    if ((int64_t) 8 > 0)
                        memmove(mem_32503.mem + defunc_1_f_res_29763 *
                                (int64_t) 8, mem_param_32420.mem +
                                ((int64_t) 0 + (int64_t) 1 * write_iter_31899) *
                                (int64_t) 8, (int64_t) 8);
                }
            }
            if (memblock_set(ctx, &mem_param_tmp_33439, &mem_32500,
                             "mem_32500") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_33440, &mem_32503,
                             "mem_32503") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_32415, &mem_param_tmp_33439,
                             "mem_param_tmp_33439") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_32420, &mem_param_tmp_33440,
                             "mem_param_tmp_33440") != 0)
                return 1;
        }
        if (memblock_set(ctx, &ext_mem_32529, &mem_param_32415,
                         "mem_param_32415") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_32528, &mem_param_32420,
                         "mem_param_32420") != 0)
            return 1;
        if (memblock_alloc(ctx, &mem_32543, bytes_32397, "mem_32543")) {
            err = 1;
            goto cleanup;
        }
        for (int64_t i_31927 = 0; i_31927 < n_29481; i_31927++) {
            int64_t x_29807;
            
            x_29807 = ((int64_t *) ext_mem_32528.mem)[i_31927];
            
            bool x_29808 = sle64((int64_t) 0, x_29807);
            bool y_29809 = slt64(x_29807, n_29481);
            bool bounds_check_29810 = x_29808 && y_29809;
            bool index_certs_29811;
            
            if (!bounds_check_29810) {
                ctx->error =
                    msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                              "Index [", (long long) x_29807,
                              "] out of bounds for array of shape [",
                              (long long) n_29481, "].",
                              "-> #0  sample_programs/lib/github.com/diku-dk/sorts/radix_sort.fut:62:28-32\n   #1  /prelude/functional.fut:9:42-44\n   #2  sample_programs/lib/github.com/diku-dk/sorts/radix_sort.fut:59:3-62:33\n   #3  sample_programs/lib/github.com/diku-dk/sorts/radix_sort.fut:68:3-51\n   #4  sample_programs/octree.fut:197:5-79\n   #5  sample_programs/nbody.fut:62:5-25\n   #6  sample_programs/nbody.fut:69:26-57\n   #7  sample_programs/nbody.fut:75:5-49\n   #8  sample_programs/nbody.fut:102:17-75\n   #9  sample_programs/nbody.fut:89:1-106:46\n");
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            float defunc_0_f_res_29813;
            
            defunc_0_f_res_29813 = ((float *) mem_param_32356.mem)[x_29807];
            
            float defunc_0_f_res_29814;
            
            defunc_0_f_res_29814 = ((float *) mem_param_32361.mem)[x_29807];
            
            float defunc_0_f_res_29815;
            
            defunc_0_f_res_29815 = ((float *) mem_param_32366.mem)[x_29807];
            
            float x_29819 = defunc_0_f_res_29813 - defunc_2_reduce_res_29576;
            float defunc_0_f_res_29820 = x_29819 / y_29606;
            float x_29821 = defunc_0_f_res_29814 - defunc_2_reduce_res_29577;
            float defunc_0_f_res_29822 = x_29821 / y_29607;
            float x_29823 = defunc_0_f_res_29815 - defunc_2_reduce_res_29578;
            float defunc_0_f_res_29824 = x_29823 / y_29608;
            float max_arg_29825 = 1024.0F * defunc_0_f_res_29820;
            float max_res_29826 = fmax32(0.0F, max_arg_29825);
            float min_res_29827 = fmin32(1023.0F, max_res_29826);
            float max_arg_29828 = 1024.0F * defunc_0_f_res_29822;
            float max_res_29829 = fmax32(0.0F, max_arg_29828);
            float min_res_29830 = fmin32(1023.0F, max_res_29829);
            float max_arg_29831 = 1024.0F * defunc_0_f_res_29824;
            float max_res_29832 = fmax32(0.0F, max_arg_29831);
            float min_res_29833 = fmin32(1023.0F, max_res_29832);
            int32_t unsign_arg_29834 = fptoui_f32_i32(min_res_29827);
            int32_t x_29835 = mul32(65537, unsign_arg_29834);
            int32_t v_29836 = -16776961 & x_29835;
            int32_t x_29837 = mul32(257, v_29836);
            int32_t v_29838 = 251719695 & x_29837;
            int32_t x_29839 = mul32(17, v_29838);
            int32_t v_29840 = -1022611261 & x_29839;
            int32_t x_29841 = mul32(5, v_29840);
            int32_t v_29842 = 1227133513 & x_29841;
            int32_t unsign_arg_29843 = fptoui_f32_i32(min_res_29830);
            int32_t x_29844 = mul32(65537, unsign_arg_29843);
            int32_t v_29845 = -16776961 & x_29844;
            int32_t x_29846 = mul32(257, v_29845);
            int32_t v_29847 = 251719695 & x_29846;
            int32_t x_29848 = mul32(17, v_29847);
            int32_t v_29849 = -1022611261 & x_29848;
            int32_t x_29850 = mul32(5, v_29849);
            int32_t v_29851 = 1227133513 & x_29850;
            int32_t unsign_arg_29852 = fptoui_f32_i32(min_res_29833);
            int32_t x_29853 = mul32(65537, unsign_arg_29852);
            int32_t v_29854 = -16776961 & x_29853;
            int32_t x_29855 = mul32(257, v_29854);
            int32_t v_29856 = 251719695 & x_29855;
            int32_t x_29857 = mul32(17, v_29856);
            int32_t v_29858 = -1022611261 & x_29857;
            int32_t x_29859 = mul32(5, v_29858);
            int32_t v_29860 = 1227133513 & x_29859;
            int32_t x_29861 = mul32(4, v_29842);
            int32_t y_29862 = mul32(2, v_29851);
            int32_t x_29863 = add32(x_29861, y_29862);
            int32_t defunc_0_g_res_29864 = add32(v_29860, x_29863);
            
            ((int32_t *) mem_32540)[i_31927] = defunc_0_g_res_29864;
            if ((int64_t) 4 > 0)
                memmove(mem_32543.mem + i_31927 * (int64_t) 4,
                        mem_param_32351.mem + ((int64_t) 0 + (int64_t) 1 *
                                               x_29807) * (int64_t) 4,
                        (int64_t) 4);
            if ((int64_t) 4 > 0)
                memmove(mem_32546 + i_31927 * (int64_t) 4, mem_param_32356.mem +
                        ((int64_t) 0 + (int64_t) 1 * x_29807) * (int64_t) 4,
                        (int64_t) 4);
            if ((int64_t) 4 > 0)
                memmove(mem_32549 + i_31927 * (int64_t) 4, mem_param_32361.mem +
                        ((int64_t) 0 + (int64_t) 1 * x_29807) * (int64_t) 4,
                        (int64_t) 4);
            if ((int64_t) 4 > 0)
                memmove(mem_32552 + i_31927 * (int64_t) 4, mem_param_32366.mem +
                        ((int64_t) 0 + (int64_t) 1 * x_29807) * (int64_t) 4,
                        (int64_t) 4);
            if ((int64_t) 4 > 0)
                memmove(mem_32555 + i_31927 * (int64_t) 4, mem_param_32371.mem +
                        ((int64_t) 0 + (int64_t) 1 * x_29807) * (int64_t) 4,
                        (int64_t) 4);
            if ((int64_t) 4 > 0)
                memmove(mem_32558 + i_31927 * (int64_t) 4, mem_param_32376.mem +
                        ((int64_t) 0 + (int64_t) 1 * x_29807) * (int64_t) 4,
                        (int64_t) 4);
            if ((int64_t) 4 > 0)
                memmove(mem_32561 + i_31927 * (int64_t) 4, mem_param_32381.mem +
                        ((int64_t) 0 + (int64_t) 1 * x_29807) * (int64_t) 4,
                        (int64_t) 4);
        }
        if (memblock_unref(ctx, &ext_mem_32528, "ext_mem_32528") != 0)
            return 1;
        for (int64_t i_31952 = 0; i_31952 < i_29496; i_31952++) {
            int32_t i64_res_29882 = sext_i64_i32(i_31952);
            int32_t lifted_delta_arg_29883 = add32(1, i64_res_29882);
            bool cond_29884 = sle32(0, lifted_delta_arg_29883);
            bool cond_t_res_29885 = slt32(lifted_delta_arg_29883,
                                          i64_res_29532);
            bool x_29886 = cond_29884 && cond_t_res_29885;
            int32_t lifted_delta_res_29887;
            
            if (x_29886) {
                int64_t i_29888 = sext_i32_i64(i64_res_29882);
                bool x_29889 = sle64((int64_t) 0, i_29888);
                bool y_29890 = slt64(i_29888, n_29481);
                bool bounds_check_29891 = x_29889 && y_29890;
                bool index_certs_29892;
                
                if (!bounds_check_29891) {
                    ctx->error =
                        msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                  "Index [", (long long) i_29888,
                                  "] out of bounds for array of shape [",
                                  (long long) n_29481, "].",
                                  "-> #0  sample_programs/radixtree.fut:19:19-22\n   #1  sample_programs/radixtree.fut:31:22-33\n   #2  /prelude/soacs.fut:59:3-10\n   #3  /prelude/array.fut:195:3-17\n   #4  sample_programs/radixtree.fut:70:40-58\n   #5  sample_programs/octree.fut:199:16-36\n   #6  sample_programs/nbody.fut:62:5-25\n   #7  sample_programs/nbody.fut:69:26-57\n   #8  sample_programs/nbody.fut:75:5-49\n   #9  sample_programs/nbody.fut:102:17-75\n   #10 sample_programs/nbody.fut:89:1-106:46\n");
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int32_t Li_29893;
                
                Li_29893 = ((int32_t *) mem_32540)[i_29888];
                
                int64_t j_29894 = sext_i32_i64(lifted_delta_arg_29883);
                bool x_29895 = sle64((int64_t) 0, j_29894);
                bool y_29896 = slt64(j_29894, n_29481);
                bool bounds_check_29897 = x_29895 && y_29896;
                bool index_certs_29898;
                
                if (!bounds_check_29897) {
                    ctx->error =
                        msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                  "Index [", (long long) j_29894,
                                  "] out of bounds for array of shape [",
                                  (long long) n_29481, "].",
                                  "-> #0  sample_programs/radixtree.fut:20:19-22\n   #1  sample_programs/radixtree.fut:31:22-33\n   #2  /prelude/soacs.fut:59:3-10\n   #3  /prelude/array.fut:195:3-17\n   #4  sample_programs/radixtree.fut:70:40-58\n   #5  sample_programs/octree.fut:199:16-36\n   #6  sample_programs/nbody.fut:62:5-25\n   #7  sample_programs/nbody.fut:69:26-57\n   #8  sample_programs/nbody.fut:75:5-49\n   #9  sample_programs/nbody.fut:102:17-75\n   #10 sample_programs/nbody.fut:89:1-106:46\n");
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int32_t Lj_29899;
                
                Lj_29899 = ((int32_t *) mem_32540)[j_29894];
                
                bool cond_29900 = Li_29893 == Lj_29899;
                int32_t lifted_delta_res_t_res_29901;
                
                if (cond_29900) {
                    int32_t clzz_arg_29902 = i64_res_29882 ^
                            lifted_delta_arg_29883;
                    int32_t clzz_res_29903;
                    
                    clzz_res_29903 = futrts_clzz32(clzz_arg_29902);
                    
                    int32_t lifted_delta_res_t_res_t_res_29904 = add32(32,
                                                                       clzz_res_29903);
                    
                    lifted_delta_res_t_res_29901 =
                        lifted_delta_res_t_res_t_res_29904;
                } else {
                    int32_t clzz_arg_31433 = Li_29893 ^ Lj_29899;
                    int32_t clzz_res_31434;
                    
                    clzz_res_31434 = futrts_clzz32(clzz_arg_31433);
                    lifted_delta_res_t_res_29901 = clzz_res_31434;
                }
                lifted_delta_res_29887 = lifted_delta_res_t_res_29901;
            } else {
                lifted_delta_res_29887 = -1;
            }
            
            int32_t lifted_delta_arg_29907 = sub32(i64_res_29882, 1);
            bool cond_29908 = sle32(0, lifted_delta_arg_29907);
            bool cond_t_res_29909 = slt32(lifted_delta_arg_29907,
                                          i64_res_29532);
            bool x_29910 = cond_29908 && cond_t_res_29909;
            int32_t lifted_delta_res_29911;
            
            if (x_29910) {
                int64_t i_29912 = sext_i32_i64(i64_res_29882);
                bool x_29913 = sle64((int64_t) 0, i_29912);
                bool y_29914 = slt64(i_29912, n_29481);
                bool bounds_check_29915 = x_29913 && y_29914;
                bool index_certs_29916;
                
                if (!bounds_check_29915) {
                    ctx->error =
                        msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                  "Index [", (long long) i_29912,
                                  "] out of bounds for array of shape [",
                                  (long long) n_29481, "].",
                                  "-> #0  sample_programs/radixtree.fut:19:19-22\n   #1  sample_programs/radixtree.fut:31:37-48\n   #2  /prelude/soacs.fut:59:3-10\n   #3  /prelude/array.fut:195:3-17\n   #4  sample_programs/radixtree.fut:70:40-58\n   #5  sample_programs/octree.fut:199:16-36\n   #6  sample_programs/nbody.fut:62:5-25\n   #7  sample_programs/nbody.fut:69:26-57\n   #8  sample_programs/nbody.fut:75:5-49\n   #9  sample_programs/nbody.fut:102:17-75\n   #10 sample_programs/nbody.fut:89:1-106:46\n");
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int32_t Li_29917;
                
                Li_29917 = ((int32_t *) mem_32540)[i_29912];
                
                int64_t j_29918 = sext_i32_i64(lifted_delta_arg_29907);
                bool x_29919 = sle64((int64_t) 0, j_29918);
                bool y_29920 = slt64(j_29918, n_29481);
                bool bounds_check_29921 = x_29919 && y_29920;
                bool index_certs_29922;
                
                if (!bounds_check_29921) {
                    ctx->error =
                        msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                  "Index [", (long long) j_29918,
                                  "] out of bounds for array of shape [",
                                  (long long) n_29481, "].",
                                  "-> #0  sample_programs/radixtree.fut:20:19-22\n   #1  sample_programs/radixtree.fut:31:37-48\n   #2  /prelude/soacs.fut:59:3-10\n   #3  /prelude/array.fut:195:3-17\n   #4  sample_programs/radixtree.fut:70:40-58\n   #5  sample_programs/octree.fut:199:16-36\n   #6  sample_programs/nbody.fut:62:5-25\n   #7  sample_programs/nbody.fut:69:26-57\n   #8  sample_programs/nbody.fut:75:5-49\n   #9  sample_programs/nbody.fut:102:17-75\n   #10 sample_programs/nbody.fut:89:1-106:46\n");
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int32_t Lj_29923;
                
                Lj_29923 = ((int32_t *) mem_32540)[j_29918];
                
                bool cond_29924 = Li_29917 == Lj_29923;
                int32_t lifted_delta_res_t_res_29925;
                
                if (cond_29924) {
                    int32_t clzz_arg_29926 = i64_res_29882 ^
                            lifted_delta_arg_29907;
                    int32_t clzz_res_29927;
                    
                    clzz_res_29927 = futrts_clzz32(clzz_arg_29926);
                    
                    int32_t lifted_delta_res_t_res_t_res_29928 = add32(32,
                                                                       clzz_res_29927);
                    
                    lifted_delta_res_t_res_29925 =
                        lifted_delta_res_t_res_t_res_29928;
                } else {
                    int32_t clzz_arg_31435 = Li_29917 ^ Lj_29923;
                    int32_t clzz_res_31436;
                    
                    clzz_res_31436 = futrts_clzz32(clzz_arg_31435);
                    lifted_delta_res_t_res_29925 = clzz_res_31436;
                }
                lifted_delta_res_29911 = lifted_delta_res_t_res_29925;
            } else {
                lifted_delta_res_29911 = -1;
            }
            
            int32_t sgn_arg_29931 = sub32(lifted_delta_res_29887,
                                          lifted_delta_res_29911);
            int32_t sgn_res_29932 = (sgn_arg_29931 > 0) - (sgn_arg_29931 < 0);
            int32_t lifted_delta_arg_29933 = sub32(i64_res_29882,
                                                   sgn_res_29932);
            bool cond_29934 = sle32(0, lifted_delta_arg_29933);
            bool cond_t_res_29935 = slt32(lifted_delta_arg_29933,
                                          i64_res_29532);
            bool x_29936 = cond_29934 && cond_t_res_29935;
            int32_t lifted_delta_res_29937;
            
            if (x_29936) {
                int64_t i_29938 = sext_i32_i64(i64_res_29882);
                bool x_29939 = sle64((int64_t) 0, i_29938);
                bool y_29940 = slt64(i_29938, n_29481);
                bool bounds_check_29941 = x_29939 && y_29940;
                bool index_certs_29942;
                
                if (!bounds_check_29941) {
                    ctx->error =
                        msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                  "Index [", (long long) i_29938,
                                  "] out of bounds for array of shape [",
                                  (long long) n_29481, "].",
                                  "-> #0  sample_programs/radixtree.fut:19:19-22\n   #1  sample_programs/radixtree.fut:34:21-32\n   #2  /prelude/soacs.fut:59:3-10\n   #3  /prelude/array.fut:195:3-17\n   #4  sample_programs/radixtree.fut:70:40-58\n   #5  sample_programs/octree.fut:199:16-36\n   #6  sample_programs/nbody.fut:62:5-25\n   #7  sample_programs/nbody.fut:69:26-57\n   #8  sample_programs/nbody.fut:75:5-49\n   #9  sample_programs/nbody.fut:102:17-75\n   #10 sample_programs/nbody.fut:89:1-106:46\n");
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int32_t Li_29943;
                
                Li_29943 = ((int32_t *) mem_32540)[i_29938];
                
                int64_t j_29944 = sext_i32_i64(lifted_delta_arg_29933);
                bool x_29945 = sle64((int64_t) 0, j_29944);
                bool y_29946 = slt64(j_29944, n_29481);
                bool bounds_check_29947 = x_29945 && y_29946;
                bool index_certs_29948;
                
                if (!bounds_check_29947) {
                    ctx->error =
                        msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                  "Index [", (long long) j_29944,
                                  "] out of bounds for array of shape [",
                                  (long long) n_29481, "].",
                                  "-> #0  sample_programs/radixtree.fut:20:19-22\n   #1  sample_programs/radixtree.fut:34:21-32\n   #2  /prelude/soacs.fut:59:3-10\n   #3  /prelude/array.fut:195:3-17\n   #4  sample_programs/radixtree.fut:70:40-58\n   #5  sample_programs/octree.fut:199:16-36\n   #6  sample_programs/nbody.fut:62:5-25\n   #7  sample_programs/nbody.fut:69:26-57\n   #8  sample_programs/nbody.fut:75:5-49\n   #9  sample_programs/nbody.fut:102:17-75\n   #10 sample_programs/nbody.fut:89:1-106:46\n");
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int32_t Lj_29949;
                
                Lj_29949 = ((int32_t *) mem_32540)[j_29944];
                
                bool cond_29950 = Li_29943 == Lj_29949;
                int32_t lifted_delta_res_t_res_29951;
                
                if (cond_29950) {
                    int32_t clzz_arg_29952 = i64_res_29882 ^
                            lifted_delta_arg_29933;
                    int32_t clzz_res_29953;
                    
                    clzz_res_29953 = futrts_clzz32(clzz_arg_29952);
                    
                    int32_t lifted_delta_res_t_res_t_res_29954 = add32(32,
                                                                       clzz_res_29953);
                    
                    lifted_delta_res_t_res_29951 =
                        lifted_delta_res_t_res_t_res_29954;
                } else {
                    int32_t clzz_arg_31437 = Li_29943 ^ Lj_29949;
                    int32_t clzz_res_31438;
                    
                    clzz_res_31438 = futrts_clzz32(clzz_arg_31437);
                    lifted_delta_res_t_res_29951 = clzz_res_31438;
                }
                lifted_delta_res_29937 = lifted_delta_res_t_res_29951;
            } else {
                lifted_delta_res_29937 = -1;
            }
            
            int32_t y_29957 = mul32(2, sgn_res_29932);
            int32_t lifted_delta_arg_29958 = add32(i64_res_29882, y_29957);
            bool cond_29959 = sle32(0, lifted_delta_arg_29958);
            bool cond_t_res_29960 = slt32(lifted_delta_arg_29958,
                                          i64_res_29532);
            bool x_29961 = cond_29959 && cond_t_res_29960;
            int32_t lifted_delta_res_29962;
            
            if (x_29961) {
                int64_t i_29963 = sext_i32_i64(i64_res_29882);
                bool x_29964 = sle64((int64_t) 0, i_29963);
                bool y_29965 = slt64(i_29963, n_29481);
                bool bounds_check_29966 = x_29964 && y_29965;
                bool index_certs_29967;
                
                if (!bounds_check_29966) {
                    ctx->error =
                        msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                  "Index [", (long long) i_29963,
                                  "] out of bounds for array of shape [",
                                  (long long) n_29481, "].",
                                  "-> #0  sample_programs/radixtree.fut:19:19-22\n   #1  sample_programs/radixtree.fut:36:23-41\n   #2  /prelude/soacs.fut:59:3-10\n   #3  /prelude/array.fut:195:3-17\n   #4  sample_programs/radixtree.fut:70:40-58\n   #5  sample_programs/octree.fut:199:16-36\n   #6  sample_programs/nbody.fut:62:5-25\n   #7  sample_programs/nbody.fut:69:26-57\n   #8  sample_programs/nbody.fut:75:5-49\n   #9  sample_programs/nbody.fut:102:17-75\n   #10 sample_programs/nbody.fut:89:1-106:46\n");
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int32_t Li_29968;
                
                Li_29968 = ((int32_t *) mem_32540)[i_29963];
                
                int64_t j_29969 = sext_i32_i64(lifted_delta_arg_29958);
                bool x_29970 = sle64((int64_t) 0, j_29969);
                bool y_29971 = slt64(j_29969, n_29481);
                bool bounds_check_29972 = x_29970 && y_29971;
                bool index_certs_29973;
                
                if (!bounds_check_29972) {
                    ctx->error =
                        msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                  "Index [", (long long) j_29969,
                                  "] out of bounds for array of shape [",
                                  (long long) n_29481, "].",
                                  "-> #0  sample_programs/radixtree.fut:20:19-22\n   #1  sample_programs/radixtree.fut:36:23-41\n   #2  /prelude/soacs.fut:59:3-10\n   #3  /prelude/array.fut:195:3-17\n   #4  sample_programs/radixtree.fut:70:40-58\n   #5  sample_programs/octree.fut:199:16-36\n   #6  sample_programs/nbody.fut:62:5-25\n   #7  sample_programs/nbody.fut:69:26-57\n   #8  sample_programs/nbody.fut:75:5-49\n   #9  sample_programs/nbody.fut:102:17-75\n   #10 sample_programs/nbody.fut:89:1-106:46\n");
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int32_t Lj_29974;
                
                Lj_29974 = ((int32_t *) mem_32540)[j_29969];
                
                bool cond_29975 = Li_29968 == Lj_29974;
                int32_t lifted_delta_res_t_res_29976;
                
                if (cond_29975) {
                    int32_t clzz_arg_29977 = i64_res_29882 ^
                            lifted_delta_arg_29958;
                    int32_t clzz_res_29978;
                    
                    clzz_res_29978 = futrts_clzz32(clzz_arg_29977);
                    
                    int32_t lifted_delta_res_t_res_t_res_29979 = add32(32,
                                                                       clzz_res_29978);
                    
                    lifted_delta_res_t_res_29976 =
                        lifted_delta_res_t_res_t_res_29979;
                } else {
                    int32_t clzz_arg_31439 = Li_29968 ^ Lj_29974;
                    int32_t clzz_res_31440;
                    
                    clzz_res_31440 = futrts_clzz32(clzz_arg_31439);
                    lifted_delta_res_t_res_29976 = clzz_res_31440;
                }
                lifted_delta_res_29962 = lifted_delta_res_t_res_29976;
            } else {
                lifted_delta_res_29962 = -1;
            }
            
            bool loop_cond_29982 = slt32(lifted_delta_res_29937,
                                         lifted_delta_res_29962);
            bool l_max_29983;
            int32_t l_max_29984;
            bool loop_while_29985;
            int32_t l_max_29986;
            
            loop_while_29985 = loop_cond_29982;
            l_max_29986 = 2;
            while (loop_while_29985) {
                int32_t loopres_29987 = mul32(2, l_max_29986);
                int32_t y_29988 = mul32(sgn_res_29932, loopres_29987);
                int32_t lifted_delta_arg_29989 = add32(i64_res_29882, y_29988);
                bool cond_29990 = sle32(0, lifted_delta_arg_29989);
                bool cond_t_res_29991 = slt32(lifted_delta_arg_29989,
                                              i64_res_29532);
                bool x_29992 = cond_29990 && cond_t_res_29991;
                int32_t lifted_delta_res_29993;
                
                if (x_29992) {
                    int64_t i_29994 = sext_i32_i64(i64_res_29882);
                    bool x_29995 = sle64((int64_t) 0, i_29994);
                    bool y_29996 = slt64(i_29994, n_29481);
                    bool bounds_check_29997 = x_29995 && y_29996;
                    bool index_certs_29998;
                    
                    if (!bounds_check_29997) {
                        ctx->error =
                            msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                      "Index [", (long long) i_29994,
                                      "] out of bounds for array of shape [",
                                      (long long) n_29481, "].",
                                      "-> #0  sample_programs/radixtree.fut:19:19-22\n   #1  sample_programs/radixtree.fut:36:23-41\n   #2  /prelude/soacs.fut:59:3-10\n   #3  /prelude/array.fut:195:3-17\n   #4  sample_programs/radixtree.fut:70:40-58\n   #5  sample_programs/octree.fut:199:16-36\n   #6  sample_programs/nbody.fut:62:5-25\n   #7  sample_programs/nbody.fut:69:26-57\n   #8  sample_programs/nbody.fut:75:5-49\n   #9  sample_programs/nbody.fut:102:17-75\n   #10 sample_programs/nbody.fut:89:1-106:46\n");
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int32_t Li_29999;
                    
                    Li_29999 = ((int32_t *) mem_32540)[i_29994];
                    
                    int64_t j_30000 = sext_i32_i64(lifted_delta_arg_29989);
                    bool x_30001 = sle64((int64_t) 0, j_30000);
                    bool y_30002 = slt64(j_30000, n_29481);
                    bool bounds_check_30003 = x_30001 && y_30002;
                    bool index_certs_30004;
                    
                    if (!bounds_check_30003) {
                        ctx->error =
                            msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                      "Index [", (long long) j_30000,
                                      "] out of bounds for array of shape [",
                                      (long long) n_29481, "].",
                                      "-> #0  sample_programs/radixtree.fut:20:19-22\n   #1  sample_programs/radixtree.fut:36:23-41\n   #2  /prelude/soacs.fut:59:3-10\n   #3  /prelude/array.fut:195:3-17\n   #4  sample_programs/radixtree.fut:70:40-58\n   #5  sample_programs/octree.fut:199:16-36\n   #6  sample_programs/nbody.fut:62:5-25\n   #7  sample_programs/nbody.fut:69:26-57\n   #8  sample_programs/nbody.fut:75:5-49\n   #9  sample_programs/nbody.fut:102:17-75\n   #10 sample_programs/nbody.fut:89:1-106:46\n");
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int32_t Lj_30005;
                    
                    Lj_30005 = ((int32_t *) mem_32540)[j_30000];
                    
                    bool cond_30006 = Li_29999 == Lj_30005;
                    int32_t lifted_delta_res_t_res_30007;
                    
                    if (cond_30006) {
                        int32_t clzz_arg_30008 = i64_res_29882 ^
                                lifted_delta_arg_29989;
                        int32_t clzz_res_30009;
                        
                        clzz_res_30009 = futrts_clzz32(clzz_arg_30008);
                        
                        int32_t lifted_delta_res_t_res_t_res_30010 = add32(32,
                                                                           clzz_res_30009);
                        
                        lifted_delta_res_t_res_30007 =
                            lifted_delta_res_t_res_t_res_30010;
                    } else {
                        int32_t clzz_arg_31441 = Li_29999 ^ Lj_30005;
                        int32_t clzz_res_31442;
                        
                        clzz_res_31442 = futrts_clzz32(clzz_arg_31441);
                        lifted_delta_res_t_res_30007 = clzz_res_31442;
                    }
                    lifted_delta_res_29993 = lifted_delta_res_t_res_30007;
                } else {
                    lifted_delta_res_29993 = -1;
                }
                
                bool loop_cond_30013 = slt32(lifted_delta_res_29937,
                                             lifted_delta_res_29993);
                bool loop_while_tmp_33470 = loop_cond_30013;
                int32_t l_max_tmp_33471 = loopres_29987;
                
                loop_while_29985 = loop_while_tmp_33470;
                l_max_29986 = l_max_tmp_33471;
            }
            l_max_29983 = loop_while_29985;
            l_max_29984 = l_max_29986;
            
            int32_t loop_init_30014 = sdiv32(l_max_29984, 2);
            bool loop_cond_30015 = slt32(0, loop_init_30014);
            bool l_30016;
            int32_t l_30017;
            int32_t l_30018;
            bool loop_while_30019;
            int32_t l_30020;
            int32_t t_30021;
            
            loop_while_30019 = loop_cond_30015;
            l_30020 = 0;
            t_30021 = loop_init_30014;
            while (loop_while_30019) {
                int32_t x_30022 = add32(l_30020, t_30021);
                int32_t y_30023 = mul32(sgn_res_29932, x_30022);
                int32_t lifted_delta_arg_30024 = add32(i64_res_29882, y_30023);
                bool cond_30025 = sle32(0, lifted_delta_arg_30024);
                bool cond_t_res_30026 = slt32(lifted_delta_arg_30024,
                                              i64_res_29532);
                bool x_30027 = cond_30025 && cond_t_res_30026;
                int32_t lifted_delta_res_30028;
                
                if (x_30027) {
                    int64_t i_30029 = sext_i32_i64(i64_res_29882);
                    bool x_30030 = sle64((int64_t) 0, i_30029);
                    bool y_30031 = slt64(i_30029, n_29481);
                    bool bounds_check_30032 = x_30030 && y_30031;
                    bool index_certs_30033;
                    
                    if (!bounds_check_30032) {
                        ctx->error =
                            msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                      "Index [", (long long) i_30029,
                                      "] out of bounds for array of shape [",
                                      (long long) n_29481, "].",
                                      "-> #0  sample_programs/radixtree.fut:19:19-22\n   #1  sample_programs/radixtree.fut:42:23-41\n   #2  /prelude/soacs.fut:59:3-10\n   #3  /prelude/array.fut:195:3-17\n   #4  sample_programs/radixtree.fut:70:40-58\n   #5  sample_programs/octree.fut:199:16-36\n   #6  sample_programs/nbody.fut:62:5-25\n   #7  sample_programs/nbody.fut:69:26-57\n   #8  sample_programs/nbody.fut:75:5-49\n   #9  sample_programs/nbody.fut:102:17-75\n   #10 sample_programs/nbody.fut:89:1-106:46\n");
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int32_t Li_30034;
                    
                    Li_30034 = ((int32_t *) mem_32540)[i_30029];
                    
                    int64_t j_30035 = sext_i32_i64(lifted_delta_arg_30024);
                    bool x_30036 = sle64((int64_t) 0, j_30035);
                    bool y_30037 = slt64(j_30035, n_29481);
                    bool bounds_check_30038 = x_30036 && y_30037;
                    bool index_certs_30039;
                    
                    if (!bounds_check_30038) {
                        ctx->error =
                            msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                      "Index [", (long long) j_30035,
                                      "] out of bounds for array of shape [",
                                      (long long) n_29481, "].",
                                      "-> #0  sample_programs/radixtree.fut:20:19-22\n   #1  sample_programs/radixtree.fut:42:23-41\n   #2  /prelude/soacs.fut:59:3-10\n   #3  /prelude/array.fut:195:3-17\n   #4  sample_programs/radixtree.fut:70:40-58\n   #5  sample_programs/octree.fut:199:16-36\n   #6  sample_programs/nbody.fut:62:5-25\n   #7  sample_programs/nbody.fut:69:26-57\n   #8  sample_programs/nbody.fut:75:5-49\n   #9  sample_programs/nbody.fut:102:17-75\n   #10 sample_programs/nbody.fut:89:1-106:46\n");
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int32_t Lj_30040;
                    
                    Lj_30040 = ((int32_t *) mem_32540)[j_30035];
                    
                    bool cond_30041 = Li_30034 == Lj_30040;
                    int32_t lifted_delta_res_t_res_30042;
                    
                    if (cond_30041) {
                        int32_t clzz_arg_30043 = i64_res_29882 ^
                                lifted_delta_arg_30024;
                        int32_t clzz_res_30044;
                        
                        clzz_res_30044 = futrts_clzz32(clzz_arg_30043);
                        
                        int32_t lifted_delta_res_t_res_t_res_30045 = add32(32,
                                                                           clzz_res_30044);
                        
                        lifted_delta_res_t_res_30042 =
                            lifted_delta_res_t_res_t_res_30045;
                    } else {
                        int32_t clzz_arg_31443 = Li_30034 ^ Lj_30040;
                        int32_t clzz_res_31444;
                        
                        clzz_res_31444 = futrts_clzz32(clzz_arg_31443);
                        lifted_delta_res_t_res_30042 = clzz_res_31444;
                    }
                    lifted_delta_res_30028 = lifted_delta_res_t_res_30042;
                } else {
                    lifted_delta_res_30028 = -1;
                }
                
                bool cond_30048 = slt32(lifted_delta_res_29937,
                                        lifted_delta_res_30028);
                int32_t loopres_30049;
                
                if (cond_30048) {
                    loopres_30049 = x_30022;
                } else {
                    loopres_30049 = l_30020;
                }
                
                int32_t loopres_30050;
                
                if (cond_30048) {
                    int32_t loopres_t_res_30051 = sdiv32(t_30021, 2);
                    
                    loopres_30050 = loopres_t_res_30051;
                } else {
                    int32_t loopres_f_res_31445 = sdiv32(t_30021, 2);
                    
                    loopres_30050 = loopres_f_res_31445;
                }
                
                bool loop_cond_30053 = slt32(0, loopres_30050);
                bool loop_while_tmp_33472 = loop_cond_30053;
                int32_t l_tmp_33473 = loopres_30049;
                int32_t t_tmp_33474 = loopres_30050;
                
                loop_while_30019 = loop_while_tmp_33472;
                l_30020 = l_tmp_33473;
                t_30021 = t_tmp_33474;
            }
            l_30016 = loop_while_30019;
            l_30017 = l_30020;
            l_30018 = t_30021;
            
            int32_t y_30054 = mul32(sgn_res_29932, l_30017);
            int32_t j_30055 = add32(i64_res_29882, y_30054);
            bool cond_30056 = sle32(0, j_30055);
            bool cond_t_res_30057 = slt32(j_30055, i64_res_29532);
            bool x_30058 = cond_30056 && cond_t_res_30057;
            int32_t lifted_delta_res_30059;
            
            if (x_30058) {
                int64_t i_30060 = sext_i32_i64(i64_res_29882);
                bool x_30061 = sle64((int64_t) 0, i_30060);
                bool y_30062 = slt64(i_30060, n_29481);
                bool bounds_check_30063 = x_30061 && y_30062;
                bool index_certs_30064;
                
                if (!bounds_check_30063) {
                    ctx->error =
                        msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                  "Index [", (long long) i_30060,
                                  "] out of bounds for array of shape [",
                                  (long long) n_29481, "].",
                                  "-> #0  sample_programs/radixtree.fut:19:19-22\n   #1  sample_programs/radixtree.fut:48:22-32\n   #2  /prelude/soacs.fut:59:3-10\n   #3  /prelude/array.fut:195:3-17\n   #4  sample_programs/radixtree.fut:70:40-58\n   #5  sample_programs/octree.fut:199:16-36\n   #6  sample_programs/nbody.fut:62:5-25\n   #7  sample_programs/nbody.fut:69:26-57\n   #8  sample_programs/nbody.fut:75:5-49\n   #9  sample_programs/nbody.fut:102:17-75\n   #10 sample_programs/nbody.fut:89:1-106:46\n");
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int32_t Li_30065;
                
                Li_30065 = ((int32_t *) mem_32540)[i_30060];
                
                int64_t j_30066 = sext_i32_i64(j_30055);
                bool x_30067 = sle64((int64_t) 0, j_30066);
                bool y_30068 = slt64(j_30066, n_29481);
                bool bounds_check_30069 = x_30067 && y_30068;
                bool index_certs_30070;
                
                if (!bounds_check_30069) {
                    ctx->error =
                        msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                  "Index [", (long long) j_30066,
                                  "] out of bounds for array of shape [",
                                  (long long) n_29481, "].",
                                  "-> #0  sample_programs/radixtree.fut:20:19-22\n   #1  sample_programs/radixtree.fut:48:22-32\n   #2  /prelude/soacs.fut:59:3-10\n   #3  /prelude/array.fut:195:3-17\n   #4  sample_programs/radixtree.fut:70:40-58\n   #5  sample_programs/octree.fut:199:16-36\n   #6  sample_programs/nbody.fut:62:5-25\n   #7  sample_programs/nbody.fut:69:26-57\n   #8  sample_programs/nbody.fut:75:5-49\n   #9  sample_programs/nbody.fut:102:17-75\n   #10 sample_programs/nbody.fut:89:1-106:46\n");
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int32_t Lj_30071;
                
                Lj_30071 = ((int32_t *) mem_32540)[j_30066];
                
                bool cond_30072 = Li_30065 == Lj_30071;
                int32_t lifted_delta_res_t_res_30073;
                
                if (cond_30072) {
                    int32_t clzz_arg_30074 = i64_res_29882 ^ j_30055;
                    int32_t clzz_res_30075;
                    
                    clzz_res_30075 = futrts_clzz32(clzz_arg_30074);
                    
                    int32_t lifted_delta_res_t_res_t_res_30076 = add32(32,
                                                                       clzz_res_30075);
                    
                    lifted_delta_res_t_res_30073 =
                        lifted_delta_res_t_res_t_res_30076;
                } else {
                    int32_t clzz_arg_31446 = Li_30065 ^ Lj_30071;
                    int32_t clzz_res_31447;
                    
                    clzz_res_31447 = futrts_clzz32(clzz_arg_31446);
                    lifted_delta_res_t_res_30073 = clzz_res_31447;
                }
                lifted_delta_res_30059 = lifted_delta_res_t_res_30073;
            } else {
                lifted_delta_res_30059 = -1;
            }
            
            bool loop_cond_30079 = sle32(1, l_30017);
            bool s_30080;
            int32_t s_30081;
            int32_t s_30082;
            bool loop_while_30083;
            int32_t s_30084;
            int32_t q_30085;
            
            loop_while_30083 = loop_cond_30079;
            s_30084 = 0;
            q_30085 = 1;
            while (loop_while_30083) {
                int32_t div_rounding_up_arg_30086 = mul32(2, q_30085);
                int32_t x_30087 = add32(l_30017, div_rounding_up_arg_30086);
                int32_t x_30088 = sub32(x_30087, 1);
                bool zzero_30089 = div_rounding_up_arg_30086 == 0;
                bool nonzzero_30090 = !zzero_30089;
                bool nonzzero_cert_30091;
                
                if (!nonzzero_30090) {
                    ctx->error = msgprintf("Error: %s\n\nBacktrace:\n%s",
                                           "division by zero",
                                           "-> #0  sample_programs/radixtree.fut:8:33-47\n   #1  sample_programs/radixtree.fut:51:26-50\n   #2  /prelude/soacs.fut:59:3-10\n   #3  /prelude/array.fut:195:3-17\n   #4  sample_programs/radixtree.fut:70:40-58\n   #5  sample_programs/octree.fut:199:16-36\n   #6  sample_programs/nbody.fut:62:5-25\n   #7  sample_programs/nbody.fut:69:26-57\n   #8  sample_programs/nbody.fut:75:5-49\n   #9  sample_programs/nbody.fut:102:17-75\n   #10 sample_programs/nbody.fut:89:1-106:46\n");
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                int32_t div_rounding_up_res_30092 = sdiv32(x_30088,
                                                           div_rounding_up_arg_30086);
                int32_t x_30093 = add32(s_30084, div_rounding_up_res_30092);
                int32_t y_30094 = mul32(sgn_res_29932, x_30093);
                int32_t lifted_delta_arg_30095 = add32(i64_res_29882, y_30094);
                bool cond_30096 = sle32(0, lifted_delta_arg_30095);
                bool cond_t_res_30097 = slt32(lifted_delta_arg_30095,
                                              i64_res_29532);
                bool x_30098 = cond_30096 && cond_t_res_30097;
                int32_t lifted_delta_res_30099;
                
                if (x_30098) {
                    int64_t i_30100 = sext_i32_i64(i64_res_29882);
                    bool x_30101 = sle64((int64_t) 0, i_30100);
                    bool y_30102 = slt64(i_30100, n_29481);
                    bool bounds_check_30103 = x_30101 && y_30102;
                    bool index_certs_30104;
                    
                    if (!bounds_check_30103) {
                        ctx->error =
                            msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                      "Index [", (long long) i_30100,
                                      "] out of bounds for array of shape [",
                                      (long long) n_29481, "].",
                                      "-> #0  sample_programs/radixtree.fut:19:19-22\n   #1  sample_programs/radixtree.fut:52:24-42\n   #2  /prelude/soacs.fut:59:3-10\n   #3  /prelude/array.fut:195:3-17\n   #4  sample_programs/radixtree.fut:70:40-58\n   #5  sample_programs/octree.fut:199:16-36\n   #6  sample_programs/nbody.fut:62:5-25\n   #7  sample_programs/nbody.fut:69:26-57\n   #8  sample_programs/nbody.fut:75:5-49\n   #9  sample_programs/nbody.fut:102:17-75\n   #10 sample_programs/nbody.fut:89:1-106:46\n");
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int32_t Li_30105;
                    
                    Li_30105 = ((int32_t *) mem_32540)[i_30100];
                    
                    int64_t j_30106 = sext_i32_i64(lifted_delta_arg_30095);
                    bool x_30107 = sle64((int64_t) 0, j_30106);
                    bool y_30108 = slt64(j_30106, n_29481);
                    bool bounds_check_30109 = x_30107 && y_30108;
                    bool index_certs_30110;
                    
                    if (!bounds_check_30109) {
                        ctx->error =
                            msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                      "Index [", (long long) j_30106,
                                      "] out of bounds for array of shape [",
                                      (long long) n_29481, "].",
                                      "-> #0  sample_programs/radixtree.fut:20:19-22\n   #1  sample_programs/radixtree.fut:52:24-42\n   #2  /prelude/soacs.fut:59:3-10\n   #3  /prelude/array.fut:195:3-17\n   #4  sample_programs/radixtree.fut:70:40-58\n   #5  sample_programs/octree.fut:199:16-36\n   #6  sample_programs/nbody.fut:62:5-25\n   #7  sample_programs/nbody.fut:69:26-57\n   #8  sample_programs/nbody.fut:75:5-49\n   #9  sample_programs/nbody.fut:102:17-75\n   #10 sample_programs/nbody.fut:89:1-106:46\n");
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int32_t Lj_30111;
                    
                    Lj_30111 = ((int32_t *) mem_32540)[j_30106];
                    
                    bool cond_30112 = Li_30105 == Lj_30111;
                    int32_t lifted_delta_res_t_res_30113;
                    
                    if (cond_30112) {
                        int32_t clzz_arg_30114 = i64_res_29882 ^
                                lifted_delta_arg_30095;
                        int32_t clzz_res_30115;
                        
                        clzz_res_30115 = futrts_clzz32(clzz_arg_30114);
                        
                        int32_t lifted_delta_res_t_res_t_res_30116 = add32(32,
                                                                           clzz_res_30115);
                        
                        lifted_delta_res_t_res_30113 =
                            lifted_delta_res_t_res_t_res_30116;
                    } else {
                        int32_t clzz_arg_31448 = Li_30105 ^ Lj_30111;
                        int32_t clzz_res_31449;
                        
                        clzz_res_31449 = futrts_clzz32(clzz_arg_31448);
                        lifted_delta_res_t_res_30113 = clzz_res_31449;
                    }
                    lifted_delta_res_30099 = lifted_delta_res_t_res_30113;
                } else {
                    lifted_delta_res_30099 = -1;
                }
                
                bool cond_30119 = slt32(lifted_delta_res_30059,
                                        lifted_delta_res_30099);
                int32_t loopres_30120;
                
                if (cond_30119) {
                    loopres_30120 = x_30093;
                } else {
                    loopres_30120 = s_30084;
                }
                
                bool loop_cond_30121 = sle32(div_rounding_up_arg_30086,
                                             l_30017);
                bool loop_while_tmp_33475 = loop_cond_30121;
                int32_t s_tmp_33476 = loopres_30120;
                int32_t q_tmp_33477 = div_rounding_up_arg_30086;
                
                loop_while_30083 = loop_while_tmp_33475;
                s_30084 = s_tmp_33476;
                q_30085 = q_tmp_33477;
            }
            s_30080 = loop_while_30083;
            s_30081 = s_30084;
            s_30082 = q_30085;
            
            int32_t y_30122 = mul32(sgn_res_29932, s_30081);
            int32_t x_30123 = add32(i64_res_29882, y_30122);
            int32_t min_res_30124 = smin32(0, sgn_res_29932);
            int32_t gamma_30125 = add32(x_30123, min_res_30124);
            int32_t min_res_30126 = smin32(i64_res_29882, j_30055);
            bool cond_30127 = min_res_30126 == gamma_30125;
            int8_t defunc_0_f_res_30128 = btoi_bool_i8(cond_30127);
            int32_t defunc_0_f_res_30129;
            
            if (cond_30127) {
                defunc_0_f_res_30129 = -1;
            } else {
                defunc_0_f_res_30129 = gamma_30125;
            }
            
            int32_t max_res_30130 = smax32(i64_res_29882, j_30055);
            int32_t y_30131 = add32(1, gamma_30125);
            bool cond_30132 = max_res_30130 == y_30131;
            int8_t defunc_0_f_res_30133 = btoi_bool_i8(cond_30132);
            int32_t defunc_0_f_res_30134;
            
            if (cond_30132) {
                defunc_0_f_res_30134 = -1;
            } else {
                defunc_0_f_res_30134 = y_30131;
            }
            ((int32_t *) mem_32660)[i_31952] = lifted_delta_res_30059;
            ((int8_t *) mem_32662)[i_31952] = defunc_0_f_res_30128;
            ((int32_t *) mem_32665)[i_31952] = gamma_30125;
            ((int8_t *) mem_32667)[i_31952] = defunc_0_f_res_30133;
            ((int32_t *) mem_32670)[i_31952] = y_30131;
            ((int32_t *) mem_32673)[i_31952] = defunc_0_f_res_30129;
            ((int32_t *) mem_32676)[i_31952] = i64_res_29882;
            ((int32_t *) mem_32679)[i_31952] = defunc_0_f_res_30134;
        }
        for (int64_t i_33478 = 0; i_33478 < i_29496; i_33478++) {
            ((int32_t *) mem_32778)[i_33478] = -1;
        }
        for (int64_t write_iter_31961 = 0; write_iter_31961 < i_29496;
             write_iter_31961++) {
            int32_t write_iv_31963;
            
            write_iv_31963 = ((int32_t *) mem_32679)[write_iter_31961];
            
            int32_t write_iv_31964;
            
            write_iv_31964 = ((int32_t *) mem_32673)[write_iter_31961];
            
            int64_t defunc_0_g_res_30146 = sext_i32_i64(write_iv_31963);
            int64_t defunc_0_g_res_30147 = sext_i32_i64(write_iv_31964);
            
            if (sle64((int64_t) 0, defunc_0_g_res_30147) &&
                slt64(defunc_0_g_res_30147, i_29496)) {
                if ((int64_t) 4 > 0)
                    memmove(mem_32778 + defunc_0_g_res_30147 * (int64_t) 4,
                            mem_32676 + ((int64_t) 0 + (int64_t) 1 *
                                         write_iter_31961) * (int64_t) 4,
                            (int64_t) 4);
            }
            if (sle64((int64_t) 0, defunc_0_g_res_30146) &&
                slt64(defunc_0_g_res_30146, i_29496)) {
                if ((int64_t) 4 > 0)
                    memmove(mem_32778 + defunc_0_g_res_30146 * (int64_t) 4,
                            mem_32676 + ((int64_t) 0 + (int64_t) 1 *
                                         write_iter_31961) * (int64_t) 4,
                            (int64_t) 4);
            }
        }
        
        int32_t root_delta_30149;
        
        root_delta_30149 = ((int32_t *) mem_32660)[(int64_t) 0];
        
        int32_t discard_31979;
        int32_t scanacc_31971 = 0;
        
        for (int64_t i_31975 = 0; i_31975 < i_29496; i_31975++) {
            int32_t x_30152;
            
            x_30152 = ((int32_t *) mem_32660)[i_31975];
            
            int8_t x_30153;
            
            x_30153 = ((int8_t *) mem_32662)[i_31975];
            
            int32_t x_30154;
            
            x_30154 = ((int32_t *) mem_32665)[i_31975];
            
            int8_t x_30155;
            
            x_30155 = ((int8_t *) mem_32667)[i_31975];
            
            int32_t x_30156;
            
            x_30156 = ((int32_t *) mem_32670)[i_31975];
            
            bool match_constr_30157 = (int8_t) 1 == x_30153;
            int32_t lifted_get_delta_res_30158;
            
            if (match_constr_30157) {
                lifted_get_delta_res_30158 = 66;
            } else {
                int64_t i_31450 = sext_i32_i64(x_30154);
                int32_t lifted_get_delta_res_res_31451;
                
                lifted_get_delta_res_res_31451 =
                    ((int32_t *) mem_32660)[i_31450];
                lifted_get_delta_res_30158 = lifted_get_delta_res_res_31451;
            }
            
            int32_t x_30161 = sdiv32(lifted_get_delta_res_30158, 3);
            int32_t y_30162 = sdiv32(x_30152, 3);
            int32_t lifted_edge_res_30163 = sub32(x_30161, y_30162);
            bool match_constr_30164 = (int8_t) 1 == x_30155;
            int32_t lifted_get_delta_res_30165;
            
            if (match_constr_30164) {
                lifted_get_delta_res_30165 = 66;
            } else {
                int64_t i_31452 = sext_i32_i64(x_30156);
                int32_t lifted_get_delta_res_res_31453;
                
                lifted_get_delta_res_res_31453 =
                    ((int32_t *) mem_32660)[i_31452];
                lifted_get_delta_res_30165 = lifted_get_delta_res_res_31453;
            }
            
            int32_t x_30168 = sdiv32(lifted_get_delta_res_30165, 3);
            int32_t lifted_edge_res_30169 = sub32(x_30168, y_30162);
            bool bool_arg_30184 = slt32(0, lifted_edge_res_30163);
            int32_t bool_res_30185 = btoi_bool_i32(bool_arg_30184);
            bool bool_arg_30186 = slt32(0, lifted_edge_res_30169);
            int32_t bool_res_30187 = btoi_bool_i32(bool_arg_30186);
            int32_t defunc_0_f_res_30188 = add32(bool_res_30185,
                                                 bool_res_30187);
            int32_t defunc_1_op_res_30181 = add32(defunc_0_f_res_30188,
                                                  scanacc_31971);
            
            ((int32_t *) mem_32793)[i_31975] = defunc_1_op_res_30181;
            ((int32_t *) mem_32796)[i_31975] = lifted_edge_res_30163;
            ((int32_t *) mem_32799)[i_31975] = lifted_edge_res_30169;
            
            int32_t scanacc_tmp_33480 = defunc_1_op_res_30181;
            
            scanacc_31971 = scanacc_tmp_33480;
        }
        discard_31979 = scanacc_31971;
        
        int32_t last_res_30190;
        
        last_res_30190 = ((int32_t *) mem_32793)[i_29513];
        
        int64_t i32_res_30191 = sext_i32_i64(last_res_30190);
        int64_t sizze_30192 = add64((int64_t) 1, i32_res_30191);
        
        for (int64_t i_31982 = 0; i_31982 < i_29496; i_31982++) {
            int64_t i_p_o_32322 = add64((int64_t) -1, i_31982);
            int64_t rot_i_32323 = smod64(i_p_o_32322, i_29496);
            int32_t x_30195;
            
            x_30195 = ((int32_t *) mem_32793)[rot_i_32323];
            
            int32_t defunc_0_f_res_30196 = add32(1, x_30195);
            
            ((int32_t *) mem_32838)[i_31982] = defunc_0_f_res_30196;
        }
        ((int32_t *) mem_32838)[(int64_t) 0] = 1;
        
        int64_t binop_y_32851 = (int64_t) 4 * sizze_30192;
        int64_t bytes_32852 = smax64((int64_t) 0, binop_y_32851);
        
        if (mem_32853_cached_sizze_33582 < bytes_32852) {
            err = lexical_realloc(&ctx->error, &mem_32853,
                                  &mem_32853_cached_sizze_33582, bytes_32852);
            if (err != FUTHARK_SUCCESS)
                goto cleanup;
        }
        for (int64_t i_33485 = 0; i_33485 < sizze_30192; i_33485++) {
            ((int32_t *) mem_32853)[i_33485] = 0;
        }
        for (int64_t iter_31984 = 0; iter_31984 < i_29513; iter_31984++) {
            int64_t slice_32321 = (int64_t) 1 + iter_31984;
            int32_t pixel_31986;
            
            pixel_31986 = ((int32_t *) mem_32838)[slice_32321];
            
            int64_t i32_res_30209 = sext_i32_i64(pixel_31986);
            bool less_than_zzero_31988 = slt64(i32_res_30209, (int64_t) 0);
            bool greater_than_sizze_31989 = sle64(sizze_30192, i32_res_30209);
            bool outside_bounds_dim_31990 = less_than_zzero_31988 ||
                 greater_than_sizze_31989;
            
            if (!outside_bounds_dim_31990) {
                int32_t read_hist_31992;
                
                read_hist_31992 = ((int32_t *) mem_32853)[i32_res_30209];
                
                int32_t defunc_1_f_res_30206 = add32(1, read_hist_31992);
                
                ((int32_t *) mem_32853)[i32_res_30209] = defunc_1_f_res_30206;
            }
        }
        
        int32_t y_30217 = sdiv32(root_delta_30149, 3);
        
        if (memblock_alloc(ctx, &mem_32869, bytes_32852, "mem_32869")) {
            err = 1;
            goto cleanup;
        }
        if (memblock_alloc(ctx, &mem_32872, bytes_32852, "mem_32872")) {
            err = 1;
            goto cleanup;
        }
        if (memblock_alloc(ctx, &mem_32875, bytes_32852, "mem_32875")) {
            err = 1;
            goto cleanup;
        }
        if (memblock_alloc(ctx, &mem_32878, bytes_32852, "mem_32878")) {
            err = 1;
            goto cleanup;
        }
        
        int64_t binop_y_32880 = (int64_t) 32 * sizze_30192;
        int64_t bytes_32881 = smax64((int64_t) 0, binop_y_32880);
        
        if (memblock_alloc(ctx, &mem_32882, bytes_32881, "mem_32882")) {
            err = 1;
            goto cleanup;
        }
        
        int64_t bytes_32883 = smax64((int64_t) 0, sizze_30192);
        
        if (memblock_alloc(ctx, &mem_32884, bytes_32883, "mem_32884")) {
            err = 1;
            goto cleanup;
        }
        if (memblock_alloc(ctx, &mem_32887, bytes_32852, "mem_32887")) {
            err = 1;
            goto cleanup;
        }
        if (memblock_alloc(ctx, &mem_32890, bytes_32852, "mem_32890")) {
            err = 1;
            goto cleanup;
        }
        
        int32_t inpacc_30218;
        int32_t inpacc_30228 = 0;
        
        for (int64_t i_32042 = 0; i_32042 < sizze_30192; i_32042++) {
            int32_t x_32092;
            
            x_32092 = ((int32_t *) mem_32853)[i_32042];
            
            int32_t defunc_1_op_res_30243 = add32(inpacc_30228, x_32092);
            int32_t i64_res_32109 = sext_i64_i32(i_32042);
            int64_t rp_32110 = sext_i32_i64(defunc_1_op_res_30243);
            bool x_32111 = sle64((int64_t) 0, rp_32110);
            bool y_32112 = slt64(rp_32110, i_29496);
            bool bounds_check_32113 = x_32111 && y_32112;
            bool index_certs_32114;
            
            if (!bounds_check_32113) {
                ctx->error =
                    msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                              "Index [", (long long) rp_32110,
                              "] out of bounds for array of shape [",
                              (long long) i_29496, "].",
                              "-> #0  sample_programs/octree.fut:51:31-40\n   #1  /prelude/soacs.fut:67:19-23\n   #2  /prelude/soacs.fut:67:3-37\n   #3  sample_programs/octree.fut:48:5-163:28\n   #4  sample_programs/octree.fut:201:16-38\n   #5  sample_programs/nbody.fut:62:5-25\n   #6  sample_programs/nbody.fut:69:26-57\n   #7  sample_programs/nbody.fut:75:5-49\n   #8  sample_programs/nbody.fut:102:17-75\n   #9  sample_programs/nbody.fut:89:1-106:46\n");
                err = FUTHARK_PROGRAM_ERROR;
                goto cleanup;
            }
            
            int32_t defunc_1_f_res_32115;
            
            defunc_1_f_res_32115 = ((int32_t *) mem_32660)[rp_32110];
            
            int8_t defunc_1_f_res_32116;
            
            defunc_1_f_res_32116 = ((int8_t *) mem_32662)[rp_32110];
            
            int8_t defunc_1_f_res_32117;
            
            defunc_1_f_res_32117 = ((int8_t *) mem_32667)[rp_32110];
            
            int32_t beginning_32118;
            
            beginning_32118 = ((int32_t *) mem_32838)[rp_32110];
            
            bool is_left_t_res_32119 = beginning_32118 == i64_res_32109;
            int32_t defunc_1_f_res_32120;
            
            defunc_1_f_res_32120 = ((int32_t *) mem_32796)[rp_32110];
            
            bool cond_32121 = slt32(0, defunc_1_f_res_32120);
            bool x_32122 = is_left_t_res_32119 && cond_32121;
            int32_t child_32123;
            
            if (x_32122) {
                int32_t defunc_1_f_res_32124;
                
                defunc_1_f_res_32124 = ((int32_t *) mem_32665)[rp_32110];
                child_32123 = defunc_1_f_res_32124;
            } else {
                int32_t defunc_1_f_res_32125;
                
                defunc_1_f_res_32125 = ((int32_t *) mem_32670)[rp_32110];
                child_32123 = defunc_1_f_res_32125;
            }
            
            bool cond_32126 = i64_res_32109 == 0;
            int32_t x_32127 = sdiv32(defunc_1_f_res_32115, 3);
            int32_t node_level_32128 = sub32(x_32127, y_30217);
            int32_t tree_level_32129;
            
            if (cond_32126) {
                tree_level_32129 = 0;
            } else {
                int32_t y_32130;
                
                if (x_32122) {
                    y_32130 = defunc_1_f_res_32120;
                } else {
                    int32_t defunc_1_f_res_32131;
                    
                    defunc_1_f_res_32131 = ((int32_t *) mem_32799)[rp_32110];
                    y_32130 = defunc_1_f_res_32131;
                }
                
                int32_t tree_level_f_res_32132 = add32(node_level_32128,
                                                       y_32130);
                
                tree_level_32129 = tree_level_f_res_32132;
            }
            
            bool cond_32133 = !cond_32126;
            bool eq_x_y_32134 = (int8_t) 1 == defunc_1_f_res_32116;
            bool eq_x_zz_32135 = (int8_t) 1 == defunc_1_f_res_32117;
            bool p_and_eq_x_y_32136 = x_32122 && eq_x_y_32134;
            bool not_p_32137 = !x_32122;
            bool p_and_eq_x_y_32138 = eq_x_zz_32135 && not_p_32137;
            bool match_constr_32139 = p_and_eq_x_y_32136 || p_and_eq_x_y_32138;
            bool x_32140 = cond_32133 && match_constr_32139;
            float defunc_1_f_res_32141;
            float defunc_1_f_res_32142;
            float defunc_1_f_res_32143;
            float defunc_1_f_res_32144;
            
            if (x_32140) {
                int64_t i_32145 = sext_i32_i64(child_32123);
                bool x_32146 = sle64((int64_t) 0, i_32145);
                bool y_32147 = slt64(i_32145, n_29481);
                bool bounds_check_32148 = x_32146 && y_32147;
                bool index_certs_32149;
                
                if (!bounds_check_32148) {
                    ctx->error =
                        msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                  "Index [", (long long) i_32145,
                                  "] out of bounds for array of shape [",
                                  (long long) n_29481, "].",
                                  "-> #0  sample_programs/octree.fut:76:31-45\n   #1  /prelude/soacs.fut:67:19-23\n   #2  /prelude/soacs.fut:67:3-37\n   #3  sample_programs/octree.fut:48:5-163:28\n   #4  sample_programs/octree.fut:201:16-38\n   #5  sample_programs/nbody.fut:62:5-25\n   #6  sample_programs/nbody.fut:69:26-57\n   #7  sample_programs/nbody.fut:75:5-49\n   #8  sample_programs/nbody.fut:102:17-75\n   #9  sample_programs/nbody.fut:89:1-106:46\n");
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                float defunc_1_f_res_t_res_32150;
                
                defunc_1_f_res_t_res_32150 = ((float *) mem_32543.mem)[i_32145];
                
                float defunc_1_f_res_t_res_32151;
                
                defunc_1_f_res_t_res_32151 = ((float *) mem_32546)[i_32145];
                
                float defunc_1_f_res_t_res_32152;
                
                defunc_1_f_res_t_res_32152 = ((float *) mem_32549)[i_32145];
                
                float defunc_1_f_res_t_res_32153;
                
                defunc_1_f_res_t_res_32153 = ((float *) mem_32552)[i_32145];
                
                float zt_res_32154 = defunc_1_f_res_t_res_32150 *
                      defunc_1_f_res_t_res_32151;
                float zt_res_32155 = defunc_1_f_res_t_res_32150 *
                      defunc_1_f_res_t_res_32152;
                float zt_res_32156 = defunc_1_f_res_t_res_32150 *
                      defunc_1_f_res_t_res_32153;
                
                defunc_1_f_res_32141 = defunc_1_f_res_t_res_32150;
                defunc_1_f_res_32142 = zt_res_32154;
                defunc_1_f_res_32143 = zt_res_32155;
                defunc_1_f_res_32144 = zt_res_32156;
            } else {
                defunc_1_f_res_32141 = 0.0F;
                defunc_1_f_res_32142 = 0.0F;
                defunc_1_f_res_32143 = 0.0F;
                defunc_1_f_res_32144 = 0.0F;
            }
            
            int32_t parent_32157;
            
            if (cond_32126) {
                parent_32157 = -1;
            } else {
                bool parentzq_32158;
                int32_t parentzq_32159;
                int32_t parentzq_32160;
                bool loop_while_32161;
                int32_t parentzq_32162;
                int32_t ridx_32163;
                
                loop_while_32161 = 1;
                parentzq_32162 = -1;
                ridx_32163 = defunc_1_op_res_30243;
                while (loop_while_32161) {
                    int64_t ridx_32164 = sext_i32_i64(ridx_32163);
                    bool x_32165 = sle64((int64_t) 0, ridx_32164);
                    bool y_32166 = slt64(ridx_32164, i_29496);
                    bool bounds_check_32167 = x_32165 && y_32166;
                    bool index_certs_32168;
                    
                    if (!bounds_check_32167) {
                        ctx->error =
                            msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                      "Index [", (long long) ridx_32164,
                                      "] out of bounds for array of shape [",
                                      (long long) i_29496, "].",
                                      "-> #0  sample_programs/octree.fut:88:41-52\n   #1  /prelude/soacs.fut:67:19-23\n   #2  /prelude/soacs.fut:67:3-37\n   #3  sample_programs/octree.fut:48:5-163:28\n   #4  sample_programs/octree.fut:201:16-38\n   #5  sample_programs/nbody.fut:62:5-25\n   #6  sample_programs/nbody.fut:69:26-57\n   #7  sample_programs/nbody.fut:75:5-49\n   #8  sample_programs/nbody.fut:102:17-75\n   #9  sample_programs/nbody.fut:89:1-106:46\n");
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int32_t parent_ridx_32169;
                    
                    parent_ridx_32169 = ((int32_t *) mem_32778)[ridx_32164];
                    
                    bool cond_32170 = parent_ridx_32169 == -1;
                    int32_t loopres_32171;
                    
                    if (cond_32170) {
                        loopres_32171 = 0;
                    } else {
                        int64_t parent_ridx_32172 =
                                sext_i32_i64(parent_ridx_32169);
                        bool x_32173 = sle64((int64_t) 0, parent_ridx_32172);
                        bool y_32174 = slt64(parent_ridx_32172, i_29496);
                        bool bounds_check_32175 = x_32173 && y_32174;
                        bool index_certs_32176;
                        
                        if (!bounds_check_32175) {
                            ctx->error =
                                msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                          "Index [",
                                          (long long) parent_ridx_32172,
                                          "] out of bounds for array of shape [",
                                          (long long) i_29496, "].",
                                          "-> #0  sample_programs/octree.fut:96:36-54\n   #1  /prelude/soacs.fut:67:19-23\n   #2  /prelude/soacs.fut:67:3-37\n   #3  sample_programs/octree.fut:48:5-163:28\n   #4  sample_programs/octree.fut:201:16-38\n   #5  sample_programs/nbody.fut:62:5-25\n   #6  sample_programs/nbody.fut:69:26-57\n   #7  sample_programs/nbody.fut:75:5-49\n   #8  sample_programs/nbody.fut:102:17-75\n   #9  sample_programs/nbody.fut:89:1-106:46\n");
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int32_t lifted_unpack_arg_32177;
                        
                        lifted_unpack_arg_32177 =
                            ((int32_t *) mem_32665)[parent_ridx_32172];
                        
                        int32_t loopres_f_res_32178;
                        
                        loopres_f_res_32178 =
                            ((int32_t *) mem_32796)[parent_ridx_32172];
                        
                        int32_t loopres_f_res_32179;
                        
                        loopres_f_res_32179 =
                            ((int32_t *) mem_32799)[parent_ridx_32172];
                        
                        bool is_left_32180 = lifted_unpack_arg_32177 ==
                             ridx_32163;
                        bool eq_x_y_32181 = 0 == loopres_f_res_32178;
                        bool eq_x_zz_32182 = 0 == loopres_f_res_32179;
                        bool p_and_eq_x_y_32183 = is_left_32180 && eq_x_y_32181;
                        bool not_p_32184 = !is_left_32180;
                        bool p_and_eq_x_y_32185 = eq_x_zz_32182 && not_p_32184;
                        bool cond_32186 = p_and_eq_x_y_32183 ||
                             p_and_eq_x_y_32185;
                        bool cond_32187 = !cond_32186;
                        int32_t loopres_f_res_32188;
                        
                        if (cond_32187) {
                            int32_t start_32189;
                            
                            start_32189 =
                                ((int32_t *) mem_32838)[parent_ridx_32172];
                            
                            int32_t loopres_f_res_t_res_32190;
                            
                            if (is_left_32180) {
                                loopres_f_res_t_res_32190 = start_32189;
                            } else {
                                bool bool_arg_32191 = slt32(0,
                                                            loopres_f_res_32178);
                                int32_t bool_res_32192 =
                                        btoi_bool_i32(bool_arg_32191);
                                int32_t loopres_f_res_t_res_f_res_32193 =
                                        add32(start_32189, bool_res_32192);
                                
                                loopres_f_res_t_res_32190 =
                                    loopres_f_res_t_res_f_res_32193;
                            }
                            loopres_f_res_32188 = loopres_f_res_t_res_32190;
                        } else {
                            loopres_f_res_32188 = parentzq_32162;
                        }
                        loopres_32171 = loopres_f_res_32188;
                    }
                    
                    bool loop_cond_32194 = loopres_32171 == -1;
                    bool loop_while_tmp_33496 = loop_cond_32194;
                    int32_t parentzq_tmp_33497 = loopres_32171;
                    int32_t ridx_tmp_33498 = parent_ridx_32169;
                    
                    loop_while_32161 = loop_while_tmp_33496;
                    parentzq_32162 = parentzq_tmp_33497;
                    ridx_32163 = ridx_tmp_33498;
                }
                parentzq_32158 = loop_while_32161;
                parentzq_32159 = parentzq_32162;
                parentzq_32160 = ridx_32163;
                parent_32157 = parentzq_32159;
            }
            for (int64_t i_33499 = 0; i_33499 < (int64_t) 8; i_33499++) {
                ((int32_t *) mem_32954)[i_33499] = -1;
            }
            
            struct memblock mainzistatic_array_33500 =
                            ctx->mainzistatic_array_33500;
            
            if ((int64_t) 12 > 0)
                memmove(mem_32956 + (int64_t) 0, mainzistatic_array_33500.mem +
                        (int64_t) 0, (int64_t) 12);
            if (!x_32140) {
                int32_t ridx_32198;
                
                if (cond_32126) {
                    ridx_32198 = 0;
                } else {
                    ridx_32198 = child_32123;
                }
                
                bool arrzq_32199;
                int32_t arrzq_32202;
                int32_t arrzq_32203;
                int32_t arrzq_32204;
                bool loop_while_32205;
                int32_t child_idx_32208;
                int32_t ridx_32209;
                int32_t lvl_32210;
                
                loop_while_32205 = 1;
                child_idx_32208 = 0;
                ridx_32209 = ridx_32198;
                lvl_32210 = 0;
                while (loop_while_32205) {
                    int64_t lvl_32211 = sext_i32_i64(lvl_32210);
                    bool x_32212 = sle64((int64_t) 0, lvl_32211);
                    bool y_32213 = slt64(lvl_32211, (int64_t) 3);
                    bool bounds_check_32214 = x_32212 && y_32213;
                    bool index_certs_32215;
                    
                    if (!bounds_check_32214) {
                        ctx->error =
                            msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                      "Index [", (long long) lvl_32211,
                                      "] out of bounds for array of shape [",
                                      (long long) (int64_t) 3, "].",
                                      "-> #0  sample_programs/octree.fut:131:25-37\n   #1  /prelude/soacs.fut:67:19-23\n   #2  /prelude/soacs.fut:67:3-37\n   #3  sample_programs/octree.fut:48:5-163:28\n   #4  sample_programs/octree.fut:201:16-38\n   #5  sample_programs/nbody.fut:62:5-25\n   #6  sample_programs/nbody.fut:69:26-57\n   #7  sample_programs/nbody.fut:75:5-49\n   #8  sample_programs/nbody.fut:102:17-75\n   #9  sample_programs/nbody.fut:89:1-106:46\n");
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int32_t x_32216;
                    
                    x_32216 = ((int32_t *) mem_32956)[lvl_32211];
                    
                    bool cond_32217 = x_32216 == 2;
                    int32_t loopres_32220;
                    int32_t loopres_32221;
                    int32_t loopres_32222;
                    
                    if (cond_32217) {
                        int64_t ridx_32223 = sext_i32_i64(ridx_32209);
                        bool x_32224 = sle64((int64_t) 0, ridx_32223);
                        bool y_32225 = slt64(ridx_32223, i_29496);
                        bool bounds_check_32226 = x_32224 && y_32225;
                        bool index_certs_32227;
                        
                        if (!bounds_check_32226) {
                            ctx->error =
                                msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                          "Index [", (long long) ridx_32223,
                                          "] out of bounds for array of shape [",
                                          (long long) i_29496, "].",
                                          "-> #0  sample_programs/octree.fut:132:27-37\n   #1  /prelude/soacs.fut:67:19-23\n   #2  /prelude/soacs.fut:67:3-37\n   #3  sample_programs/octree.fut:48:5-163:28\n   #4  sample_programs/octree.fut:201:16-38\n   #5  sample_programs/nbody.fut:62:5-25\n   #6  sample_programs/nbody.fut:69:26-57\n   #7  sample_programs/nbody.fut:75:5-49\n   #8  sample_programs/nbody.fut:102:17-75\n   #9  sample_programs/nbody.fut:89:1-106:46\n");
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int32_t x_32228;
                        
                        x_32228 = ((int32_t *) mem_32796)[ridx_32223];
                        
                        bool cond_32229 = x_32228 == 0;
                        bool cond_32230 = !cond_32229;
                        int32_t loopres_t_res_32233;
                        int32_t loopres_t_res_32234;
                        int32_t loopres_t_res_32235;
                        
                        if (cond_32230) {
                            int64_t child_idx_32236 =
                                    sext_i32_i64(child_idx_32208);
                            bool x_32237 = sle64((int64_t) 0, child_idx_32236);
                            bool y_32238 = slt64(child_idx_32236, (int64_t) 8);
                            bool bounds_check_32239 = x_32237 && y_32238;
                            bool index_certs_32240;
                            
                            if (!bounds_check_32239) {
                                ctx->error =
                                    msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                              "Index [",
                                              (long long) child_idx_32236,
                                              "] out of bounds for array of shape [",
                                              (long long) (int64_t) 8, "].",
                                              "-> #0  sample_programs/octree.fut:134:26-137:65\n   #1  /prelude/soacs.fut:67:19-23\n   #2  /prelude/soacs.fut:67:3-37\n   #3  sample_programs/octree.fut:48:5-163:28\n   #4  sample_programs/octree.fut:201:16-38\n   #5  sample_programs/nbody.fut:62:5-25\n   #6  sample_programs/nbody.fut:69:26-57\n   #7  sample_programs/nbody.fut:75:5-49\n   #8  sample_programs/nbody.fut:102:17-75\n   #9  sample_programs/nbody.fut:89:1-106:46\n");
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            if ((int64_t) 4 > 0)
                                memmove(mem_32954 + child_idx_32236 *
                                        (int64_t) 4, mem_32838 + ((int64_t) 0 +
                                                                  (int64_t) 1 *
                                                                  ridx_32223) *
                                        (int64_t) 4, (int64_t) 4);
                            
                            int32_t child_idx_32243 = add32(1, child_idx_32208);
                            
                            ((int32_t *) mem_32956)[lvl_32211] = 1;
                            loopres_t_res_32233 = child_idx_32243;
                            loopres_t_res_32234 = ridx_32209;
                            loopres_t_res_32235 = lvl_32210;
                        } else {
                            int32_t lifted_unpack_arg_32245;
                            
                            lifted_unpack_arg_32245 =
                                ((int32_t *) mem_32665)[ridx_32223];
                            
                            int32_t lvl_32246 = add32(1, lvl_32210);
                            int64_t lvl_32247 = sext_i32_i64(lvl_32246);
                            bool x_32248 = sle64((int64_t) 0, lvl_32247);
                            bool y_32249 = slt64(lvl_32247, (int64_t) 3);
                            bool bounds_check_32250 = x_32248 && y_32249;
                            bool index_certs_32251;
                            
                            if (!bounds_check_32250) {
                                ctx->error =
                                    msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                              "Index [", (long long) lvl_32247,
                                              "] out of bounds for array of shape [",
                                              (long long) (int64_t) 3, "].",
                                              "-> #0  sample_programs/octree.fut:141:26-142:65\n   #1  /prelude/soacs.fut:67:19-23\n   #2  /prelude/soacs.fut:67:3-37\n   #3  sample_programs/octree.fut:48:5-163:28\n   #4  sample_programs/octree.fut:201:16-38\n   #5  sample_programs/nbody.fut:62:5-25\n   #6  sample_programs/nbody.fut:69:26-57\n   #7  sample_programs/nbody.fut:75:5-49\n   #8  sample_programs/nbody.fut:102:17-75\n   #9  sample_programs/nbody.fut:89:1-106:46\n");
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            ((int32_t *) mem_32956)[lvl_32247] = 2;
                            loopres_t_res_32233 = child_idx_32208;
                            loopres_t_res_32234 = lifted_unpack_arg_32245;
                            loopres_t_res_32235 = lvl_32246;
                        }
                        loopres_32220 = loopres_t_res_32233;
                        loopres_32221 = loopres_t_res_32234;
                        loopres_32222 = loopres_t_res_32235;
                    } else {
                        bool cond_32253 = x_32216 == 1;
                        int32_t loopres_f_res_32256;
                        int32_t loopres_f_res_32257;
                        int32_t loopres_f_res_32258;
                        
                        if (cond_32253) {
                            int64_t ridx_32259 = sext_i32_i64(ridx_32209);
                            bool x_32260 = sle64((int64_t) 0, ridx_32259);
                            bool y_32261 = slt64(ridx_32259, i_29496);
                            bool bounds_check_32262 = x_32260 && y_32261;
                            bool index_certs_32263;
                            
                            if (!bounds_check_32262) {
                                ctx->error =
                                    msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                              "Index [", (long long) ridx_32259,
                                              "] out of bounds for array of shape [",
                                              (long long) i_29496, "].",
                                              "-> #0  sample_programs/octree.fut:144:27-37\n   #1  /prelude/soacs.fut:67:19-23\n   #2  /prelude/soacs.fut:67:3-37\n   #3  sample_programs/octree.fut:48:5-163:28\n   #4  sample_programs/octree.fut:201:16-38\n   #5  sample_programs/nbody.fut:62:5-25\n   #6  sample_programs/nbody.fut:69:26-57\n   #7  sample_programs/nbody.fut:75:5-49\n   #8  sample_programs/nbody.fut:102:17-75\n   #9  sample_programs/nbody.fut:89:1-106:46\n");
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int32_t x_32264;
                            
                            x_32264 = ((int32_t *) mem_32799)[ridx_32259];
                            
                            bool cond_32265 = x_32264 == 0;
                            bool cond_32266 = !cond_32265;
                            int32_t loopres_f_res_t_res_32269;
                            int32_t loopres_f_res_t_res_32270;
                            int32_t loopres_f_res_t_res_32271;
                            
                            if (cond_32266) {
                                int32_t start_32272;
                                
                                start_32272 =
                                    ((int32_t *) mem_32838)[ridx_32259];
                                
                                int32_t x_32273;
                                
                                x_32273 = ((int32_t *) mem_32796)[ridx_32259];
                                
                                bool bool_arg_32274 = slt32(0, x_32273);
                                int32_t bool_res_32275 =
                                        btoi_bool_i32(bool_arg_32274);
                                int32_t lw_val_32276 = add32(start_32272,
                                                             bool_res_32275);
                                int64_t child_idx_32277 =
                                        sext_i32_i64(child_idx_32208);
                                bool x_32278 = sle64((int64_t) 0,
                                                     child_idx_32277);
                                bool y_32279 = slt64(child_idx_32277,
                                                     (int64_t) 8);
                                bool bounds_check_32280 = x_32278 && y_32279;
                                bool index_certs_32281;
                                
                                if (!bounds_check_32280) {
                                    ctx->error =
                                        msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                                  "Index [",
                                                  (long long) child_idx_32277,
                                                  "] out of bounds for array of shape [",
                                                  (long long) (int64_t) 8, "].",
                                                  "-> #0  sample_programs/octree.fut:146:26-150:65\n   #1  /prelude/soacs.fut:67:19-23\n   #2  /prelude/soacs.fut:67:3-37\n   #3  sample_programs/octree.fut:48:5-163:28\n   #4  sample_programs/octree.fut:201:16-38\n   #5  sample_programs/nbody.fut:62:5-25\n   #6  sample_programs/nbody.fut:69:26-57\n   #7  sample_programs/nbody.fut:75:5-49\n   #8  sample_programs/nbody.fut:102:17-75\n   #9  sample_programs/nbody.fut:89:1-106:46\n");
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                ((int32_t *) mem_32954)[child_idx_32277] =
                                    lw_val_32276;
                                
                                int32_t child_idx_32283 = add32(1,
                                                                child_idx_32208);
                                
                                ((int32_t *) mem_32956)[lvl_32211] = 0;
                                loopres_f_res_t_res_32269 = child_idx_32283;
                                loopres_f_res_t_res_32270 = ridx_32209;
                                loopres_f_res_t_res_32271 = lvl_32210;
                            } else {
                                int32_t lifted_unpack_arg_32285;
                                
                                lifted_unpack_arg_32285 =
                                    ((int32_t *) mem_32670)[ridx_32259];
                                
                                int32_t lvl_32286 = add32(1, lvl_32210);
                                int64_t lvl_32287 = sext_i32_i64(lvl_32286);
                                bool x_32288 = sle64((int64_t) 0, lvl_32287);
                                bool y_32289 = slt64(lvl_32287, (int64_t) 3);
                                bool bounds_check_32290 = x_32288 && y_32289;
                                bool index_certs_32291;
                                
                                if (!bounds_check_32290) {
                                    ctx->error =
                                        msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                                  "Index [",
                                                  (long long) lvl_32287,
                                                  "] out of bounds for array of shape [",
                                                  (long long) (int64_t) 3, "].",
                                                  "-> #0  sample_programs/octree.fut:154:26-155:65\n   #1  /prelude/soacs.fut:67:19-23\n   #2  /prelude/soacs.fut:67:3-37\n   #3  sample_programs/octree.fut:48:5-163:28\n   #4  sample_programs/octree.fut:201:16-38\n   #5  sample_programs/nbody.fut:62:5-25\n   #6  sample_programs/nbody.fut:69:26-57\n   #7  sample_programs/nbody.fut:75:5-49\n   #8  sample_programs/nbody.fut:102:17-75\n   #9  sample_programs/nbody.fut:89:1-106:46\n");
                                    err = FUTHARK_PROGRAM_ERROR;
                                    goto cleanup;
                                }
                                ((int32_t *) mem_32956)[lvl_32287] = 2;
                                loopres_f_res_t_res_32269 = child_idx_32208;
                                loopres_f_res_t_res_32270 =
                                    lifted_unpack_arg_32285;
                                loopres_f_res_t_res_32271 = lvl_32286;
                            }
                            loopres_f_res_32256 = loopres_f_res_t_res_32269;
                            loopres_f_res_32257 = loopres_f_res_t_res_32270;
                            loopres_f_res_32258 = loopres_f_res_t_res_32271;
                        } else {
                            int64_t ridx_32293 = sext_i32_i64(ridx_32209);
                            bool x_32294 = sle64((int64_t) 0, ridx_32293);
                            bool y_32295 = slt64(ridx_32293, i_29496);
                            bool bounds_check_32296 = x_32294 && y_32295;
                            bool index_certs_32297;
                            
                            if (!bounds_check_32296) {
                                ctx->error =
                                    msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                              "Index [", (long long) ridx_32293,
                                              "] out of bounds for array of shape [",
                                              (long long) i_29496, "].",
                                              "-> #0  sample_programs/octree.fut:157:35-46\n   #1  /prelude/soacs.fut:67:19-23\n   #2  /prelude/soacs.fut:67:3-37\n   #3  sample_programs/octree.fut:48:5-163:28\n   #4  sample_programs/octree.fut:201:16-38\n   #5  sample_programs/nbody.fut:62:5-25\n   #6  sample_programs/nbody.fut:69:26-57\n   #7  sample_programs/nbody.fut:75:5-49\n   #8  sample_programs/nbody.fut:102:17-75\n   #9  sample_programs/nbody.fut:89:1-106:46\n");
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int32_t ridx_32298;
                            
                            ridx_32298 = ((int32_t *) mem_32778)[ridx_32293];
                            
                            int32_t lvl_32299 = sub32(lvl_32210, 1);
                            int64_t lvl_32300 = sext_i32_i64(lvl_32299);
                            bool x_32301 = sle64((int64_t) 0, lvl_32300);
                            bool y_32302 = slt64(lvl_32300, (int64_t) 3);
                            bool bounds_check_32303 = x_32301 && y_32302;
                            bool index_certs_32304;
                            
                            if (!bounds_check_32303) {
                                ctx->error =
                                    msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                              "Index [", (long long) lvl_32300,
                                              "] out of bounds for array of shape [",
                                              (long long) (int64_t) 3, "].",
                                              "-> #0  sample_programs/octree.fut:159:44-56\n   #1  /prelude/soacs.fut:67:19-23\n   #2  /prelude/soacs.fut:67:3-37\n   #3  sample_programs/octree.fut:48:5-163:28\n   #4  sample_programs/octree.fut:201:16-38\n   #5  sample_programs/nbody.fut:62:5-25\n   #6  sample_programs/nbody.fut:69:26-57\n   #7  sample_programs/nbody.fut:75:5-49\n   #8  sample_programs/nbody.fut:102:17-75\n   #9  sample_programs/nbody.fut:89:1-106:46\n");
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int32_t x_32305;
                            
                            x_32305 = ((int32_t *) mem_32956)[lvl_32300];
                            
                            int32_t lw_val_32306 = sub32(x_32305, 1);
                            
                            ((int32_t *) mem_32956)[lvl_32300] = lw_val_32306;
                            loopres_f_res_32256 = child_idx_32208;
                            loopres_f_res_32257 = ridx_32298;
                            loopres_f_res_32258 = lvl_32299;
                        }
                        loopres_32220 = loopres_f_res_32256;
                        loopres_32221 = loopres_f_res_32257;
                        loopres_32222 = loopres_f_res_32258;
                    }
                    
                    int32_t x_32308;
                    
                    x_32308 = ((int32_t *) mem_32956)[(int64_t) 0];
                    
                    bool loop_cond_32309 = slt32(0, x_32308);
                    bool loop_while_tmp_33501 = loop_cond_32309;
                    int32_t child_idx_tmp_33504 = loopres_32220;
                    int32_t ridx_tmp_33505 = loopres_32221;
                    int32_t lvl_tmp_33506 = loopres_32222;
                    
                    loop_while_32205 = loop_while_tmp_33501;
                    child_idx_32208 = child_idx_tmp_33504;
                    ridx_32209 = ridx_tmp_33505;
                    lvl_32210 = lvl_tmp_33506;
                }
                arrzq_32199 = loop_while_32205;
                arrzq_32202 = child_idx_32208;
                arrzq_32203 = ridx_32209;
                arrzq_32204 = lvl_32210;
            }
            if ((int64_t) 32 > 0)
                memmove(mem_32999 + (int64_t) 0, mem_32954 + (int64_t) 0,
                        (int64_t) 32);
            ((float *) mem_32869.mem)[i_32042] = defunc_1_f_res_32141;
            ((float *) mem_32872.mem)[i_32042] = defunc_1_f_res_32142;
            ((float *) mem_32875.mem)[i_32042] = defunc_1_f_res_32143;
            ((float *) mem_32878.mem)[i_32042] = defunc_1_f_res_32144;
            if ((int64_t) 32 > 0)
                memmove(mem_32882.mem + (int64_t) 8 * i_32042 * (int64_t) 4,
                        mem_32999 + (int64_t) 0, (int64_t) 32);
            ((bool *) mem_32884.mem)[i_32042] = x_32140;
            ((int32_t *) mem_32887.mem)[i_32042] = parent_32157;
            ((int32_t *) mem_32890.mem)[i_32042] = tree_level_32129;
            
            int32_t inpacc_tmp_33487 = defunc_1_op_res_30243;
            
            inpacc_30228 = inpacc_tmp_33487;
        }
        inpacc_30218 = inpacc_30228;
        
        int32_t root_leaf_delta_30473 = sub32(66, root_delta_30149);
        int32_t x_30474 = add32(3, root_leaf_delta_30473);
        int32_t x_30475 = sub32(x_30474, 1);
        int32_t lvl_30476 = sdiv32(x_30475, 3);
        int32_t range_second_30477 = sub32(lvl_30476, 1);
        int64_t lvl_30478 = sext_i32_i64(lvl_30476);
        int64_t range_second_30479 = sext_i32_i64(range_second_30477);
        int32_t subtracted_step_30480 = sub32(range_second_30477, lvl_30476);
        bool step_zzero_30481 = lvl_30476 == range_second_30477;
        int32_t s_sign_30482 = (subtracted_step_30480 > 0) -
                (subtracted_step_30480 < 0);
        int64_t s_sign_30483 = sext_i32_i64(s_sign_30482);
        bool bounds_invalid_downwards_30484 = sle32(lvl_30476, 0);
        bool bounds_invalid_upwards_30485 = slt32(0, lvl_30476);
        bool downwards_30486 = s_sign_30482 == -1;
        int32_t distance_exclusive_30492;
        
        if (downwards_30486) {
            distance_exclusive_30492 = lvl_30476;
        } else {
            int32_t distance_upwards_exclusive_31726 = sub32(0, lvl_30476);
            
            distance_exclusive_30492 = distance_upwards_exclusive_31726;
        }
        
        bool x_30488 = bounds_invalid_downwards_30484 && downwards_30486;
        bool x_30489 = !downwards_30486;
        bool y_30490 = bounds_invalid_upwards_30485 && x_30489;
        bool bounds_invalid_30491 = x_30488 || y_30490;
        int64_t distance_exclusive_30493 =
                sext_i32_i64(distance_exclusive_30492);
        int64_t distance_30494 = add64((int64_t) 1, distance_exclusive_30493);
        bool range_invalid_30495 = step_zzero_30481 || bounds_invalid_30491;
        bool valid_30496 = !range_invalid_30495;
        bool range_valid_c_30497;
        
        if (!valid_30496) {
            ctx->error =
                msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s",
                          "Range ", (long long) lvl_30478, "..",
                          (long long) range_second_30479, "...",
                          (long long) (int64_t) 0, " is invalid.",
                          "-> #0  sample_programs/octree.fut:206:30-47\n   #1  sample_programs/nbody.fut:62:5-25\n   #2  sample_programs/nbody.fut:69:26-57\n   #3  sample_programs/nbody.fut:75:5-49\n   #4  sample_programs/nbody.fut:102:17-75\n   #5  sample_programs/nbody.fut:89:1-106:46\n");
            err = FUTHARK_PROGRAM_ERROR;
            goto cleanup;
        }
        
        int64_t subtracted_step_30498 = sext_i32_i64(subtracted_step_30480);
        int64_t pos_step_30499 = mul64(s_sign_30483, subtracted_step_30498);
        int64_t num_elems_30500 = sdiv_up64(distance_30494, pos_step_30499);
        
        if (memblock_set(ctx, &mem_param_33047, &mem_32869, "mem_32869") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_33052, &mem_32872, "mem_32872") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_33057, &mem_32875, "mem_32875") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_33062, &mem_32878, "mem_32878") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_33070, &mem_32882, "mem_32882") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_33075, &mem_32884, "mem_32884") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_33080, &mem_32887, "mem_32887") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_33085, &mem_32890, "mem_32890") != 0)
            return 1;
        for (int64_t i_30509 = 0; i_30509 < num_elems_30500; i_30509++) {
            int32_t binop_x_30518 = sext_i64_i32(i_30509);
            int32_t binop_x_30519 = mul32(subtracted_step_30480, binop_x_30518);
            int32_t index_primexp_30520 = add32(lvl_30476, binop_x_30519);
            
            if (memblock_alloc(ctx, &mem_33087, bytes_32883, "mem_33087")) {
                err = 1;
                goto cleanup;
            }
            if (sizze_30192 > 0)
                memmove(mem_33087.mem + (int64_t) 0, mem_param_33075.mem +
                        (int64_t) 0, sizze_30192);
            if (memblock_alloc(ctx, &mem_33090, bytes_32852, "mem_33090")) {
                err = 1;
                goto cleanup;
            }
            if (sizze_30192 * (int64_t) 4 > 0)
                memmove(mem_33090.mem + (int64_t) 0, mem_param_33080.mem +
                        (int64_t) 0, sizze_30192 * (int64_t) 4);
            if (memblock_alloc(ctx, &mem_33093, bytes_32852, "mem_33093")) {
                err = 1;
                goto cleanup;
            }
            if (sizze_30192 * (int64_t) 4 > 0)
                memmove(mem_33093.mem + (int64_t) 0, mem_param_33085.mem +
                        (int64_t) 0, sizze_30192 * (int64_t) 4);
            if (memblock_alloc(ctx, &mem_33097, bytes_32881, "mem_33097")) {
                err = 1;
                goto cleanup;
            }
            if (sizze_30192 * (int64_t) 8 * (int64_t) 4 > 0)
                memmove(mem_33097.mem + (int64_t) 0, mem_param_33070.mem +
                        (int64_t) 0, sizze_30192 * (int64_t) 8 * (int64_t) 4);
            if (memblock_alloc(ctx, &mem_33100, bytes_32852, "mem_33100")) {
                err = 1;
                goto cleanup;
            }
            if (memblock_alloc(ctx, &mem_33103, bytes_32852, "mem_33103")) {
                err = 1;
                goto cleanup;
            }
            if (memblock_alloc(ctx, &mem_33106, bytes_32852, "mem_33106")) {
                err = 1;
                goto cleanup;
            }
            if (memblock_alloc(ctx, &mem_33109, bytes_32852, "mem_33109")) {
                err = 1;
                goto cleanup;
            }
            for (int64_t i_32059 = 0; i_32059 < sizze_30192; i_32059++) {
                float x_30529;
                
                x_30529 = ((float *) mem_param_33047.mem)[i_32059];
                
                float x_30530;
                
                x_30530 = ((float *) mem_param_33052.mem)[i_32059];
                
                float x_30531;
                
                x_30531 = ((float *) mem_param_33057.mem)[i_32059];
                
                float x_30532;
                
                x_30532 = ((float *) mem_param_33062.mem)[i_32059];
                
                int32_t x_30534;
                
                x_30534 = ((int32_t *) mem_param_33085.mem)[i_32059];
                
                bool cond_30535 = x_30534 == index_primexp_30520;
                bool cond_30536 = !cond_30535;
                float defunc_0_f_res_30537;
                float defunc_0_f_res_30538;
                float defunc_0_f_res_30539;
                float defunc_0_f_res_30540;
                
                if (cond_30536) {
                    defunc_0_f_res_30537 = x_30529;
                    defunc_0_f_res_30538 = x_30530;
                    defunc_0_f_res_30539 = x_30531;
                    defunc_0_f_res_30540 = x_30532;
                } else {
                    int32_t x_31727;
                    
                    x_31727 = ((int32_t *) mem_param_33070.mem)[i_32059 *
                                                                (int64_t) 8];
                    
                    bool loop_cond_t_res_31728 = x_31727 == -1;
                    bool loop_cond_t_res_31729 = !loop_cond_t_res_31728;
                    bool defunc_0_f_res_f_res_31730;
                    float defunc_0_f_res_f_res_31731;
                    float defunc_0_f_res_f_res_31732;
                    float defunc_0_f_res_f_res_31733;
                    float defunc_0_f_res_f_res_31734;
                    int32_t defunc_0_f_res_f_res_31735;
                    bool loop_while_31736;
                    float b_31737;
                    float b_31738;
                    float b_31739;
                    float b_31740;
                    int32_t j_31741;
                    
                    loop_while_31736 = loop_cond_t_res_31729;
                    b_31737 = x_30529;
                    b_31738 = x_30530;
                    b_31739 = x_30531;
                    b_31740 = x_30532;
                    j_31741 = 0;
                    while (loop_while_31736) {
                        int64_t j_31742 = sext_i32_i64(j_31741);
                        bool x_31743 = sle64((int64_t) 0, j_31742);
                        bool y_31744 = slt64(j_31742, (int64_t) 8);
                        bool bounds_check_31745 = x_31743 && y_31744;
                        bool index_certs_31746;
                        
                        if (!bounds_check_31745) {
                            ctx->error =
                                msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                          "Index [", (long long) j_31742,
                                          "] out of bounds for array of shape [",
                                          (long long) (int64_t) 8, "].",
                                          "-> #0  sample_programs/octree.fut:214:37-49\n   #1  sample_programs/octree.fut:207:10-222:46\n   #2  sample_programs/nbody.fut:62:5-25\n   #3  sample_programs/nbody.fut:69:26-57\n   #4  sample_programs/nbody.fut:75:5-49\n   #5  sample_programs/nbody.fut:102:17-75\n   #6  sample_programs/nbody.fut:89:1-106:46\n");
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int32_t i_31747;
                        
                        i_31747 = ((int32_t *) mem_param_33070.mem)[i_32059 *
                                                                    (int64_t) 8 +
                                                                    j_31742];
                        
                        int64_t i_31748 = sext_i32_i64(i_31747);
                        bool x_31749 = sle64((int64_t) 0, i_31748);
                        bool y_31750 = slt64(i_31748, sizze_30192);
                        bool bounds_check_31751 = x_31749 && y_31750;
                        bool index_certs_31752;
                        
                        if (!bounds_check_31751) {
                            ctx->error =
                                msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                          "Index [", (long long) i_31748,
                                          "] out of bounds for array of shape [",
                                          (long long) sizze_30192, "].",
                                          "-> #0  sample_programs/octree.fut:214:30-50\n   #1  sample_programs/octree.fut:207:10-222:46\n   #2  sample_programs/nbody.fut:62:5-25\n   #3  sample_programs/nbody.fut:69:26-57\n   #4  sample_programs/nbody.fut:75:5-49\n   #5  sample_programs/nbody.fut:102:17-75\n   #6  sample_programs/nbody.fut:89:1-106:46\n");
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        float loopres_31753;
                        
                        loopres_31753 =
                            ((float *) mem_param_33047.mem)[i_31748];
                        
                        float loopres_31754;
                        
                        loopres_31754 =
                            ((float *) mem_param_33052.mem)[i_31748];
                        
                        float loopres_31755;
                        
                        loopres_31755 =
                            ((float *) mem_param_33057.mem)[i_31748];
                        
                        float loopres_31756;
                        
                        loopres_31756 =
                            ((float *) mem_param_33062.mem)[i_31748];
                        
                        float defunc_1_f_res_31757 = b_31738 + loopres_31754;
                        float defunc_1_f_res_31758 = b_31739 + loopres_31755;
                        float defunc_1_f_res_31759 = b_31740 + loopres_31756;
                        float masszq_31760 = b_31737 + loopres_31753;
                        int32_t loopres_31761 = add32(1, j_31741);
                        bool cond_31762 = slt32(loopres_31761, 8);
                        bool loop_cond_31763;
                        
                        if (cond_31762) {
                            int64_t j_31764 = sext_i32_i64(loopres_31761);
                            bool x_31765 = sle64((int64_t) 0, j_31764);
                            bool y_31766 = slt64(j_31764, (int64_t) 8);
                            bool bounds_check_31767 = x_31765 && y_31766;
                            bool index_certs_31768;
                            
                            if (!bounds_check_31767) {
                                ctx->error =
                                    msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                              "Index [", (long long) j_31764,
                                              "] out of bounds for array of shape [",
                                              (long long) (int64_t) 8, "].",
                                              "-> #0  sample_programs/octree.fut:213:46-58\n   #1  sample_programs/octree.fut:207:10-222:46\n   #2  sample_programs/nbody.fut:62:5-25\n   #3  sample_programs/nbody.fut:69:26-57\n   #4  sample_programs/nbody.fut:75:5-49\n   #5  sample_programs/nbody.fut:102:17-75\n   #6  sample_programs/nbody.fut:89:1-106:46\n");
                                err = FUTHARK_PROGRAM_ERROR;
                                goto cleanup;
                            }
                            
                            int32_t x_31769;
                            
                            x_31769 =
                                ((int32_t *) mem_param_33070.mem)[i_32059 *
                                                                  (int64_t) 8 +
                                                                  j_31764];
                            
                            bool loop_cond_t_res_31770 = x_31769 == -1;
                            bool loop_cond_t_res_31771 = !loop_cond_t_res_31770;
                            
                            loop_cond_31763 = loop_cond_t_res_31771;
                        } else {
                            loop_cond_31763 = 0;
                        }
                        
                        bool loop_while_tmp_33527 = loop_cond_31763;
                        float b_tmp_33528 = masszq_31760;
                        float b_tmp_33529 = defunc_1_f_res_31757;
                        float b_tmp_33530 = defunc_1_f_res_31758;
                        float b_tmp_33531 = defunc_1_f_res_31759;
                        int32_t j_tmp_33532 = loopres_31761;
                        
                        loop_while_31736 = loop_while_tmp_33527;
                        b_31737 = b_tmp_33528;
                        b_31738 = b_tmp_33529;
                        b_31739 = b_tmp_33530;
                        b_31740 = b_tmp_33531;
                        j_31741 = j_tmp_33532;
                    }
                    defunc_0_f_res_f_res_31730 = loop_while_31736;
                    defunc_0_f_res_f_res_31731 = b_31737;
                    defunc_0_f_res_f_res_31732 = b_31738;
                    defunc_0_f_res_f_res_31733 = b_31739;
                    defunc_0_f_res_f_res_31734 = b_31740;
                    defunc_0_f_res_f_res_31735 = j_31741;
                    defunc_0_f_res_30537 = defunc_0_f_res_f_res_31731;
                    defunc_0_f_res_30538 = defunc_0_f_res_f_res_31732;
                    defunc_0_f_res_30539 = defunc_0_f_res_f_res_31733;
                    defunc_0_f_res_30540 = defunc_0_f_res_f_res_31734;
                }
                ((float *) mem_33100.mem)[i_32059] = defunc_0_f_res_30537;
                ((float *) mem_33103.mem)[i_32059] = defunc_0_f_res_30538;
                ((float *) mem_33106.mem)[i_32059] = defunc_0_f_res_30539;
                ((float *) mem_33109.mem)[i_32059] = defunc_0_f_res_30540;
            }
            if (memblock_set(ctx, &mem_param_tmp_33507, &mem_33100,
                             "mem_33100") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_33508, &mem_33103,
                             "mem_33103") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_33509, &mem_33106,
                             "mem_33106") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_33510, &mem_33109,
                             "mem_33109") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_33511, &mem_33097,
                             "mem_33097") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_33512, &mem_33087,
                             "mem_33087") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_33513, &mem_33090,
                             "mem_33090") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_tmp_33514, &mem_33093,
                             "mem_33093") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_33047, &mem_param_tmp_33507,
                             "mem_param_tmp_33507") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_33052, &mem_param_tmp_33508,
                             "mem_param_tmp_33508") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_33057, &mem_param_tmp_33509,
                             "mem_param_tmp_33509") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_33062, &mem_param_tmp_33510,
                             "mem_param_tmp_33510") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_33070, &mem_param_tmp_33511,
                             "mem_param_tmp_33511") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_33075, &mem_param_tmp_33512,
                             "mem_param_tmp_33512") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_33080, &mem_param_tmp_33513,
                             "mem_param_tmp_33513") != 0)
                return 1;
            if (memblock_set(ctx, &mem_param_33085, &mem_param_tmp_33514,
                             "mem_param_tmp_33514") != 0)
                return 1;
        }
        if (memblock_set(ctx, &ext_mem_33176, &mem_param_33047,
                         "mem_param_33047") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_33175, &mem_param_33052,
                         "mem_param_33052") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_33174, &mem_param_33057,
                         "mem_param_33057") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_33173, &mem_param_33062,
                         "mem_param_33062") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_33172, &mem_param_33070,
                         "mem_param_33070") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_33171, &mem_param_33075,
                         "mem_param_33075") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_33170, &mem_param_33080,
                         "mem_param_33080") != 0)
            return 1;
        if (memblock_set(ctx, &ext_mem_33169, &mem_param_33085,
                         "mem_param_33085") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_32869, "mem_32869") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_32872, "mem_32872") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_32875, "mem_32875") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_32878, "mem_32878") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_32882, "mem_32882") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_32884, "mem_32884") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_32887, "mem_32887") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_32890, "mem_32890") != 0)
            return 1;
        ((float *) mem_33213)[(int64_t) 0] = y_29606;
        ((float *) mem_33213)[(int64_t) 1] = y_29607;
        ((float *) mem_33213)[(int64_t) 2] = y_29608;
        
        float defunc_2_reduce_res_30587;
        float redout_32064 = -INFINITY;
        
        for (int32_t i_32087 = 0; i_32087 < 3; i_32087++) {
            int64_t i_32065 = sext_i32_i64(i_32087);
            float x_30591;
            
            x_30591 = ((float *) mem_33213)[i_32065];
            
            float defunc_1_op_res_30590 = fmax32(x_30591, redout_32064);
            float redout_tmp_33533 = defunc_1_op_res_30590;
            
            redout_32064 = redout_tmp_33533;
        }
        defunc_2_reduce_res_30587 = redout_32064;
        if (memblock_alloc(ctx, &mem_33216, bytes_32397, "mem_33216")) {
            err = 1;
            goto cleanup;
        }
        if (memblock_alloc(ctx, &mem_33219, bytes_32397, "mem_33219")) {
            err = 1;
            goto cleanup;
        }
        if (memblock_alloc(ctx, &mem_33222, bytes_32397, "mem_33222")) {
            err = 1;
            goto cleanup;
        }
        if (memblock_alloc(ctx, &mem_33225, bytes_32397, "mem_33225")) {
            err = 1;
            goto cleanup;
        }
        if (memblock_alloc(ctx, &mem_33228, bytes_32397, "mem_33228")) {
            err = 1;
            goto cleanup;
        }
        if (memblock_alloc(ctx, &mem_33231, bytes_32397, "mem_33231")) {
            err = 1;
            goto cleanup;
        }
        for (int64_t i_32080 = 0; i_32080 < n_29481; i_32080++) {
            float x_30750;
            
            x_30750 = ((float *) mem_32546)[i_32080];
            
            float x_30751;
            
            x_30751 = ((float *) mem_32549)[i_32080];
            
            float x_30752;
            
            x_30752 = ((float *) mem_32552)[i_32080];
            
            float x_30753;
            
            x_30753 = ((float *) mem_32555)[i_32080];
            
            float x_30754;
            
            x_30754 = ((float *) mem_32558)[i_32080];
            
            float x_30755;
            
            x_30755 = ((float *) mem_32561)[i_32080];
            
            bool defunc_0_f_res_30756;
            float defunc_0_f_res_30757;
            float defunc_0_f_res_30758;
            float defunc_0_f_res_30759;
            int32_t defunc_0_f_res_30760;
            int32_t defunc_0_f_res_30761;
            int32_t defunc_0_f_res_30762;
            bool loop_while_30763;
            float acc_30764;
            float acc_30765;
            float acc_30766;
            int32_t cur_30767;
            int32_t prev_30768;
            int32_t to_check_30769;
            
            loop_while_30763 = 1;
            acc_30764 = 0.0F;
            acc_30765 = 0.0F;
            acc_30766 = 0.0F;
            cur_30767 = 0;
            prev_30768 = -1;
            to_check_30769 = 1;
            while (loop_while_30763) {
                bool cond_30770 = prev_30768 == -1;
                bool cond_30771 = !cond_30770;
                bool from_child_30772;
                
                if (cond_30771) {
                    int64_t prev_30773 = sext_i32_i64(prev_30768);
                    bool x_30774 = sle64((int64_t) 0, prev_30773);
                    bool y_30775 = slt64(prev_30773, sizze_30192);
                    bool bounds_check_30776 = x_30774 && y_30775;
                    bool index_certs_30777;
                    
                    if (!bounds_check_30776) {
                        ctx->error =
                            msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                      "Index [", (long long) prev_30773,
                                      "] out of bounds for array of shape [",
                                      (long long) sizze_30192, "].",
                                      "-> #0  sample_programs/nbody.fut:21:36-42\n   #1  sample_programs/nbody.fut:63:7-64:39\n   #2  sample_programs/nbody.fut:69:26-57\n   #3  sample_programs/nbody.fut:75:5-49\n   #4  sample_programs/nbody.fut:102:17-75\n   #5  sample_programs/nbody.fut:89:1-106:46\n");
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int32_t x_30778;
                    
                    x_30778 = ((int32_t *) ext_mem_33170.mem)[prev_30773];
                    
                    bool from_child_t_res_30779 = x_30778 == cur_30767;
                    
                    from_child_30772 = from_child_t_res_30779;
                } else {
                    from_child_30772 = 0;
                }
                
                int64_t cur_30780 = sext_i32_i64(cur_30767);
                bool x_30781 = sle64((int64_t) 0, cur_30780);
                bool y_30782 = slt64(cur_30780, sizze_30192);
                bool bounds_check_30783 = x_30781 && y_30782;
                bool index_certs_30784;
                
                if (!bounds_check_30783) {
                    ctx->error =
                        msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                  "Index [", (long long) cur_30780,
                                  "] out of bounds for array of shape [",
                                  (long long) sizze_30192, "].",
                                  "-> #0  sample_programs/nbody.fut:22:19-24\n   #1  sample_programs/nbody.fut:63:7-64:39\n   #2  sample_programs/nbody.fut:69:26-57\n   #3  sample_programs/nbody.fut:75:5-49\n   #4  sample_programs/nbody.fut:102:17-75\n   #5  sample_programs/nbody.fut:89:1-106:46\n");
                    err = FUTHARK_PROGRAM_ERROR;
                    goto cleanup;
                }
                
                float loopres_30785;
                
                loopres_30785 = ((float *) ext_mem_33176.mem)[cur_30780];
                
                float loopres_30786;
                
                loopres_30786 = ((float *) ext_mem_33175.mem)[cur_30780];
                
                float loopres_30787;
                
                loopres_30787 = ((float *) ext_mem_33174.mem)[cur_30780];
                
                float loopres_30788;
                
                loopres_30788 = ((float *) ext_mem_33173.mem)[cur_30780];
                
                bool loopres_30790;
                
                loopres_30790 = ((bool *) ext_mem_33171.mem)[cur_30780];
                
                int32_t loopres_30792;
                
                loopres_30792 = ((int32_t *) ext_mem_33169.mem)[cur_30780];
                
                float loopres_30793;
                float loopres_30794;
                float loopres_30795;
                int32_t loopres_30796;
                int32_t loopres_30797;
                
                if (from_child_30772) {
                    int32_t x_30798;
                    
                    x_30798 = ((int32_t *) ext_mem_33172.mem)[cur_30780 *
                                                              (int64_t) 8];
                    
                    bool loop_cond_30799 = x_30798 == prev_30768;
                    bool loop_cond_30800 = !loop_cond_30799;
                    bool j_30801;
                    int32_t j_30802;
                    bool loop_while_30803;
                    int32_t i_30804;
                    
                    loop_while_30803 = loop_cond_30800;
                    i_30804 = 0;
                    while (loop_while_30803) {
                        int32_t loopres_30805 = add32(1, i_30804);
                        int64_t i_30806 = sext_i32_i64(loopres_30805);
                        bool x_30807 = sle64((int64_t) 0, i_30806);
                        bool y_30808 = slt64(i_30806, (int64_t) 8);
                        bool bounds_check_30809 = x_30807 && y_30808;
                        bool index_certs_30810;
                        
                        if (!bounds_check_30809) {
                            ctx->error =
                                msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                          "Index [", (long long) i_30806,
                                          "] out of bounds for array of shape [",
                                          (long long) (int64_t) 8, "].",
                                          "-> #0  sample_programs/nbody.fut:26:32-52\n   #1  sample_programs/nbody.fut:63:7-64:39\n   #2  sample_programs/nbody.fut:69:26-57\n   #3  sample_programs/nbody.fut:75:5-49\n   #4  sample_programs/nbody.fut:102:17-75\n   #5  sample_programs/nbody.fut:89:1-106:46\n");
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int32_t x_30811;
                        
                        x_30811 = ((int32_t *) ext_mem_33172.mem)[cur_30780 *
                                                                  (int64_t) 8 +
                                                                  i_30806];
                        
                        bool loop_cond_30812 = x_30811 == prev_30768;
                        bool loop_cond_30813 = !loop_cond_30812;
                        bool loop_while_tmp_33547 = loop_cond_30813;
                        int32_t i_tmp_33548 = loopres_30805;
                        
                        loop_while_30803 = loop_while_tmp_33547;
                        i_30804 = i_tmp_33548;
                    }
                    j_30801 = loop_while_30803;
                    j_30802 = i_30804;
                    
                    bool cond_30814 = j_30802 == 7;
                    bool cond_30815;
                    
                    if (cond_30814) {
                        cond_30815 = 1;
                    } else {
                        int32_t i_31772 = add32(1, j_30802);
                        int64_t i_31773 = sext_i32_i64(i_31772);
                        bool x_31774 = sle64((int64_t) 0, i_31773);
                        bool y_31775 = slt64(i_31773, (int64_t) 8);
                        bool bounds_check_31776 = x_31774 && y_31775;
                        bool index_certs_31777;
                        
                        if (!bounds_check_31776) {
                            ctx->error =
                                msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                          "Index [", (long long) i_31773,
                                          "] out of bounds for array of shape [",
                                          (long long) (int64_t) 8, "].",
                                          "-> #0  sample_programs/nbody.fut:29:23-47\n   #1  sample_programs/nbody.fut:63:7-64:39\n   #2  sample_programs/nbody.fut:69:26-57\n   #3  sample_programs/nbody.fut:75:5-49\n   #4  sample_programs/nbody.fut:102:17-75\n   #5  sample_programs/nbody.fut:89:1-106:46\n");
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int32_t x_31778;
                        
                        x_31778 = ((int32_t *) ext_mem_33172.mem)[cur_30780 *
                                                                  (int64_t) 8 +
                                                                  i_31773];
                        
                        bool cond_f_res_31779 = x_31778 == -1;
                        
                        cond_30815 = cond_f_res_31779;
                    }
                    
                    int32_t next_cur_30824;
                    
                    if (cond_30815) {
                        int32_t loopres_30791;
                        
                        loopres_30791 =
                            ((int32_t *) ext_mem_33170.mem)[cur_30780];
                        next_cur_30824 = loopres_30791;
                    } else {
                        int32_t i_31780 = add32(1, j_30802);
                        int64_t i_31781 = sext_i32_i64(i_31780);
                        bool x_31782 = sle64((int64_t) 0, i_31781);
                        bool y_31783 = slt64(i_31781, (int64_t) 8);
                        bool bounds_check_31784 = x_31782 && y_31783;
                        bool index_certs_31785;
                        
                        if (!bounds_check_31784) {
                            ctx->error =
                                msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                          "Index [", (long long) i_31781,
                                          "] out of bounds for array of shape [",
                                          (long long) (int64_t) 8, "].",
                                          "-> #0  sample_programs/nbody.fut:31:14-38\n   #1  sample_programs/nbody.fut:63:7-64:39\n   #2  sample_programs/nbody.fut:69:26-57\n   #3  sample_programs/nbody.fut:75:5-49\n   #4  sample_programs/nbody.fut:102:17-75\n   #5  sample_programs/nbody.fut:89:1-106:46\n");
                            err = FUTHARK_PROGRAM_ERROR;
                            goto cleanup;
                        }
                        
                        int32_t next_cur_f_res_31786;
                        
                        next_cur_f_res_31786 =
                            ((int32_t *) ext_mem_33172.mem)[cur_30780 *
                                                            (int64_t) 8 +
                                                            i_31781];
                        next_cur_30824 = next_cur_f_res_31786;
                    }
                    loopres_30793 = acc_30764;
                    loopres_30794 = acc_30765;
                    loopres_30795 = acc_30766;
                    loopres_30796 = next_cur_30824;
                    loopres_30797 = to_check_30769;
                } else {
                    bool nonnegative_31798 = sle32(0, loopres_30792);
                    bool nonzzero_cert_31799;
                    
                    if (!nonnegative_31798) {
                        ctx->error = msgprintf("Error: %s\n\nBacktrace:\n%s",
                                               "negative exponent",
                                               "-> #0  sample_programs/nbody.fut:35:35-58\n   #1  sample_programs/nbody.fut:63:7-64:39\n   #2  sample_programs/nbody.fut:69:26-57\n   #3  sample_programs/nbody.fut:75:5-49\n   #4  sample_programs/nbody.fut:102:17-75\n   #5  sample_programs/nbody.fut:89:1-106:46\n");
                        err = FUTHARK_PROGRAM_ERROR;
                        goto cleanup;
                    }
                    
                    int32_t i32_arg_31800 = shl32(1, loopres_30792);
                    float i32_res_31801 = sitofp_i32_f32(i32_arg_31800);
                    float s_31802 = defunc_2_reduce_res_30587 / i32_res_31801;
                    float scale_arg_31803 = 1.0F / loopres_30785;
                    float zt_res_31804 = loopres_30786 * scale_arg_31803;
                    float zt_res_31805 = loopres_30787 * scale_arg_31803;
                    float zt_res_31806 = loopres_30788 * scale_arg_31803;
                    float x_31807 = x_30750 - zt_res_31804;
                    float y_31808 = x_30751 - zt_res_31805;
                    float zz_31809 = x_30752 - zt_res_31806;
                    float x_31810 = x_31807 * x_31807;
                    float y_31811 = y_31808 * y_31808;
                    float x_31812 = x_31810 + y_31811;
                    float y_31813 = zz_31809 * zz_31809;
                    float inner_31814 = x_31812 + y_31813;
                    float sqrt_res_31815;
                    
                    sqrt_res_31815 = futrts_sqrt32(inner_31814);
                    
                    float local_theta_31816 = s_31802 / sqrt_res_31815;
                    int32_t x_31818 = add32(y_30217, loopres_30792);
                    bool overlapping_subtree_31819 = slt32(11, x_31818);
                    bool cond_31820 = loopres_30790 ||
                         overlapping_subtree_31819;
                    bool cond_f_res_31821 = local_theta_31816 < 0.5F;
                    bool x_31822 = !cond_31820;
                    bool y_31823 = cond_f_res_31821 && x_31822;
                    bool cond_31824 = cond_31820 || y_31823;
                    float loopres_f_res_31825;
                    float loopres_f_res_31826;
                    float loopres_f_res_31827;
                    int32_t loopres_f_res_31828;
                    int32_t loopres_f_res_31829;
                    
                    if (cond_31824) {
                        float defunc_1_f_res_31830 = zt_res_31804 - x_30750;
                        float defunc_1_f_res_31831 = zt_res_31805 - x_30751;
                        float defunc_1_f_res_31832 = zt_res_31806 - x_30752;
                        float zt_res_31833 = defunc_1_f_res_31832 *
                              defunc_1_f_res_31832;
                        float zt_res_31834 = defunc_1_f_res_31831 *
                              defunc_1_f_res_31831;
                        float zt_res_31835 = defunc_1_f_res_31830 *
                              defunc_1_f_res_31830;
                        float zp_res_31836 = zt_res_31834 + zt_res_31835;
                        float zp_res_31837 = zt_res_31833 + zp_res_31836;
                        float y_31838 = epsilon_29483 * epsilon_29483;
                        float rsqr_31839 = zp_res_31837 + y_31838;
                        float sqrt_res_31840;
                        
                        sqrt_res_31840 = futrts_sqrt32(rsqr_31839);
                        
                        float invr_31841 = 1.0F / sqrt_res_31840;
                        float x_31842 = invr_31841 * invr_31841;
                        float invr3_31843 = invr_31841 * x_31842;
                        float s_31844 = loopres_30785 * invr3_31843;
                        float zt_res_31845 = defunc_1_f_res_31830 * s_31844;
                        float zt_res_31846 = defunc_1_f_res_31831 * s_31844;
                        float zt_res_31847 = defunc_1_f_res_31832 * s_31844;
                        float defunc_1_f_res_31848 = acc_30764 + zt_res_31845;
                        float defunc_1_f_res_31849 = acc_30765 + zt_res_31846;
                        float defunc_1_f_res_31850 = acc_30766 + zt_res_31847;
                        int32_t loopres_f_res_t_res_31851 =
                                sub32(to_check_30769, 1);
                        int32_t loopres_31852;
                        
                        loopres_31852 =
                            ((int32_t *) ext_mem_33170.mem)[cur_30780];
                        loopres_f_res_31825 = defunc_1_f_res_31848;
                        loopres_f_res_31826 = defunc_1_f_res_31849;
                        loopres_f_res_31827 = defunc_1_f_res_31850;
                        loopres_f_res_31828 = loopres_31852;
                        loopres_f_res_31829 = loopres_f_res_t_res_31851;
                    } else {
                        int32_t defunc_0_f_res_31854;
                        int32_t redout_32066 = 0;
                        
                        for (int32_t i_32088 = 0; i_32088 < 8; i_32088++) {
                            int64_t i_32067 = sext_i32_i64(i_32088);
                            int32_t x_31858;
                            
                            x_31858 =
                                ((int32_t *) ext_mem_33172.mem)[cur_30780 *
                                                                (int64_t) 8 +
                                                                i_32067];
                            
                            bool defunc_0_f_res_31859 = sle32(0, x_31858);
                            int32_t defunc_0_g_res_31860 =
                                    btoi_bool_i32(defunc_0_f_res_31859);
                            int32_t defunc_1_op_res_31857 =
                                    add32(defunc_0_g_res_31860, redout_32066);
                            int32_t redout_tmp_33549 = defunc_1_op_res_31857;
                            
                            redout_32066 = redout_tmp_33549;
                        }
                        defunc_0_f_res_31854 = redout_32066;
                        
                        int32_t loopres_f_res_f_res_31861;
                        
                        loopres_f_res_f_res_31861 =
                            ((int32_t *) ext_mem_33172.mem)[cur_30780 *
                                                            (int64_t) 8];
                        
                        int32_t x_31862 = add32(to_check_30769,
                                                defunc_0_f_res_31854);
                        int32_t loopres_f_res_f_res_31863 = sub32(x_31862, 1);
                        
                        loopres_f_res_31825 = acc_30764;
                        loopres_f_res_31826 = acc_30765;
                        loopres_f_res_31827 = acc_30766;
                        loopres_f_res_31828 = loopres_f_res_f_res_31861;
                        loopres_f_res_31829 = loopres_f_res_f_res_31863;
                    }
                    loopres_30793 = loopres_f_res_31825;
                    loopres_30794 = loopres_f_res_31826;
                    loopres_30795 = loopres_f_res_31827;
                    loopres_30796 = loopres_f_res_31828;
                    loopres_30797 = loopres_f_res_31829;
                }
                
                bool loop_cond_30901 = slt32(0, loopres_30797);
                bool loop_while_tmp_33540 = loop_cond_30901;
                float acc_tmp_33541 = loopres_30793;
                float acc_tmp_33542 = loopres_30794;
                float acc_tmp_33543 = loopres_30795;
                int32_t cur_tmp_33544 = loopres_30796;
                int32_t prev_tmp_33545 = cur_30767;
                int32_t to_check_tmp_33546 = loopres_30797;
                
                loop_while_30763 = loop_while_tmp_33540;
                acc_30764 = acc_tmp_33541;
                acc_30765 = acc_tmp_33542;
                acc_30766 = acc_tmp_33543;
                cur_30767 = cur_tmp_33544;
                prev_30768 = prev_tmp_33545;
                to_check_30769 = to_check_tmp_33546;
            }
            defunc_0_f_res_30756 = loop_while_30763;
            defunc_0_f_res_30757 = acc_30764;
            defunc_0_f_res_30758 = acc_30765;
            defunc_0_f_res_30759 = acc_30766;
            defunc_0_f_res_30760 = cur_30767;
            defunc_0_f_res_30761 = prev_30768;
            defunc_0_f_res_30762 = to_check_30769;
            
            float zt_res_30902 = time_step_29484 * x_30753;
            float zt_res_30903 = time_step_29484 * x_30754;
            float zt_res_30904 = time_step_29484 * x_30755;
            float defunc_1_f_res_30905 = x_30750 + zt_res_30902;
            float defunc_1_f_res_30906 = x_30751 + zt_res_30903;
            float defunc_1_f_res_30907 = x_30752 + zt_res_30904;
            float zt_res_30908 = time_step_29484 * defunc_0_f_res_30757;
            float zt_res_30909 = time_step_29484 * defunc_0_f_res_30758;
            float zt_res_30910 = time_step_29484 * defunc_0_f_res_30759;
            float defunc_1_f_res_30911 = x_30753 + zt_res_30908;
            float defunc_1_f_res_30912 = x_30754 + zt_res_30909;
            float defunc_1_f_res_30913 = x_30755 + zt_res_30910;
            
            ((float *) mem_33216.mem)[i_32080] = defunc_1_f_res_30905;
            ((float *) mem_33219.mem)[i_32080] = defunc_1_f_res_30906;
            ((float *) mem_33222.mem)[i_32080] = defunc_1_f_res_30907;
            ((float *) mem_33225.mem)[i_32080] = defunc_1_f_res_30911;
            ((float *) mem_33228.mem)[i_32080] = defunc_1_f_res_30912;
            ((float *) mem_33231.mem)[i_32080] = defunc_1_f_res_30913;
        }
        if (memblock_unref(ctx, &ext_mem_33169, "ext_mem_33169") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_33170, "ext_mem_33170") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_33171, "ext_mem_33171") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_33172, "ext_mem_33172") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_33173, "ext_mem_33173") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_33174, "ext_mem_33174") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_33175, "ext_mem_33175") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_33176, "ext_mem_33176") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_33418, &mem_32543, "mem_32543") !=
            0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_33419, &mem_33216, "mem_33216") !=
            0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_33420, &mem_33219, "mem_33219") !=
            0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_33421, &mem_33222, "mem_33222") !=
            0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_33422, &mem_33225, "mem_33225") !=
            0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_33423, &mem_33228, "mem_33228") !=
            0)
            return 1;
        if (memblock_set(ctx, &mem_param_tmp_33424, &mem_33231, "mem_33231") !=
            0)
            return 1;
        if (memblock_set(ctx, &mem_param_32351, &mem_param_tmp_33418,
                         "mem_param_tmp_33418") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_32356, &mem_param_tmp_33419,
                         "mem_param_tmp_33419") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_32361, &mem_param_tmp_33420,
                         "mem_param_tmp_33420") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_32366, &mem_param_tmp_33421,
                         "mem_param_tmp_33421") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_32371, &mem_param_tmp_33422,
                         "mem_param_tmp_33422") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_32376, &mem_param_tmp_33423,
                         "mem_param_tmp_33423") != 0)
            return 1;
        if (memblock_set(ctx, &mem_param_32381, &mem_param_tmp_33424,
                         "mem_param_tmp_33424") != 0)
            return 1;
    }
    if (memblock_set(ctx, &ext_mem_33310, &mem_param_32351,
                     "mem_param_32351") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_33309, &mem_param_32356,
                     "mem_param_32356") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_33308, &mem_param_32361,
                     "mem_param_32361") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_33307, &mem_param_32366,
                     "mem_param_32366") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_33306, &mem_param_32371,
                     "mem_param_32371") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_33305, &mem_param_32376,
                     "mem_param_32376") != 0)
        return 1;
    if (memblock_set(ctx, &ext_mem_33304, &mem_param_32381,
                     "mem_param_32381") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_32346, "mem_32346") != 0)
        return 1;
    if (memblock_unref(ctx, &mem_32398, "mem_32398") != 0)
        return 1;
    
    int64_t binop_y_33339 = (int64_t) 4 * n_29481;
    int64_t bytes_33340 = smax64((int64_t) 0, binop_y_33339);
    
    if (memblock_alloc(ctx, &mem_33341, bytes_33340, "mem_33341")) {
        err = 1;
        goto cleanup;
    }
    if (n_29481 * (int64_t) 4 > 0)
        memmove(mem_33341.mem + (int64_t) 0, ext_mem_33309.mem + (int64_t) 0,
                n_29481 * (int64_t) 4);
    if (memblock_unref(ctx, &ext_mem_33309, "ext_mem_33309") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_33345, bytes_33340, "mem_33345")) {
        err = 1;
        goto cleanup;
    }
    if (n_29481 * (int64_t) 4 > 0)
        memmove(mem_33345.mem + (int64_t) 0, ext_mem_33308.mem + (int64_t) 0,
                n_29481 * (int64_t) 4);
    if (memblock_unref(ctx, &ext_mem_33308, "ext_mem_33308") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_33349, bytes_33340, "mem_33349")) {
        err = 1;
        goto cleanup;
    }
    if (n_29481 * (int64_t) 4 > 0)
        memmove(mem_33349.mem + (int64_t) 0, ext_mem_33307.mem + (int64_t) 0,
                n_29481 * (int64_t) 4);
    if (memblock_unref(ctx, &ext_mem_33307, "ext_mem_33307") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_33353, bytes_33340, "mem_33353")) {
        err = 1;
        goto cleanup;
    }
    if (n_29481 * (int64_t) 4 > 0)
        memmove(mem_33353.mem + (int64_t) 0, ext_mem_33310.mem + (int64_t) 0,
                n_29481 * (int64_t) 4);
    if (memblock_unref(ctx, &ext_mem_33310, "ext_mem_33310") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_33357, bytes_33340, "mem_33357")) {
        err = 1;
        goto cleanup;
    }
    if (n_29481 * (int64_t) 4 > 0)
        memmove(mem_33357.mem + (int64_t) 0, ext_mem_33306.mem + (int64_t) 0,
                n_29481 * (int64_t) 4);
    if (memblock_unref(ctx, &ext_mem_33306, "ext_mem_33306") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_33361, bytes_33340, "mem_33361")) {
        err = 1;
        goto cleanup;
    }
    if (n_29481 * (int64_t) 4 > 0)
        memmove(mem_33361.mem + (int64_t) 0, ext_mem_33305.mem + (int64_t) 0,
                n_29481 * (int64_t) 4);
    if (memblock_unref(ctx, &ext_mem_33305, "ext_mem_33305") != 0)
        return 1;
    if (memblock_alloc(ctx, &mem_33365, bytes_33340, "mem_33365")) {
        err = 1;
        goto cleanup;
    }
    if (n_29481 * (int64_t) 4 > 0)
        memmove(mem_33365.mem + (int64_t) 0, ext_mem_33304.mem + (int64_t) 0,
                n_29481 * (int64_t) 4);
    if (memblock_unref(ctx, &ext_mem_33304, "ext_mem_33304") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_33409, &mem_33341, "mem_33341") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_33410, &mem_33345, "mem_33345") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_33411, &mem_33349, "mem_33349") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_33412, &mem_33353, "mem_33353") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_33413, &mem_33357, "mem_33357") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_33414, &mem_33361, "mem_33361") != 0)
        return 1;
    if (memblock_set(ctx, &mem_out_33415, &mem_33365, "mem_33365") != 0)
        return 1;
    (*mem_out_p_33550).references = NULL;
    if (memblock_set(ctx, &*mem_out_p_33550, &mem_out_33409, "mem_out_33409") !=
        0)
        return 1;
    (*mem_out_p_33551).references = NULL;
    if (memblock_set(ctx, &*mem_out_p_33551, &mem_out_33410, "mem_out_33410") !=
        0)
        return 1;
    (*mem_out_p_33552).references = NULL;
    if (memblock_set(ctx, &*mem_out_p_33552, &mem_out_33411, "mem_out_33411") !=
        0)
        return 1;
    (*mem_out_p_33553).references = NULL;
    if (memblock_set(ctx, &*mem_out_p_33553, &mem_out_33412, "mem_out_33412") !=
        0)
        return 1;
    (*mem_out_p_33554).references = NULL;
    if (memblock_set(ctx, &*mem_out_p_33554, &mem_out_33413, "mem_out_33413") !=
        0)
        return 1;
    (*mem_out_p_33555).references = NULL;
    if (memblock_set(ctx, &*mem_out_p_33555, &mem_out_33414, "mem_out_33414") !=
        0)
        return 1;
    (*mem_out_p_33556).references = NULL;
    if (memblock_set(ctx, &*mem_out_p_33556, &mem_out_33415, "mem_out_33415") !=
        0)
        return 1;
    
  cleanup:
    {
        free(mem_32425);
        free(mem_32428);
        free(mem_32431);
        free(mem_32434);
        free(mem_32437);
        free(mem_32540);
        free(mem_32546);
        free(mem_32549);
        free(mem_32552);
        free(mem_32555);
        free(mem_32558);
        free(mem_32561);
        free(mem_32660);
        free(mem_32662);
        free(mem_32665);
        free(mem_32667);
        free(mem_32670);
        free(mem_32673);
        free(mem_32676);
        free(mem_32679);
        free(mem_32778);
        free(mem_32793);
        free(mem_32796);
        free(mem_32799);
        free(mem_32838);
        free(mem_32853);
        free(mem_32954);
        free(mem_32956);
        free(mem_32999);
        free(mem_33213);
        if (memblock_unref(ctx, &mem_33365, "mem_33365") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_33361, "mem_33361") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_33357, "mem_33357") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_33353, "mem_33353") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_33349, "mem_33349") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_33345, "mem_33345") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_33341, "mem_33341") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_33424, "mem_param_tmp_33424") !=
            0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_33423, "mem_param_tmp_33423") !=
            0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_33422, "mem_param_tmp_33422") !=
            0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_33421, "mem_param_tmp_33421") !=
            0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_33420, "mem_param_tmp_33420") !=
            0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_33419, "mem_param_tmp_33419") !=
            0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_33418, "mem_param_tmp_33418") !=
            0)
            return 1;
        if (memblock_unref(ctx, &mem_33231, "mem_33231") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_33228, "mem_33228") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_33225, "mem_33225") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_33222, "mem_33222") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_33219, "mem_33219") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_33216, "mem_33216") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_33514, "mem_param_tmp_33514") !=
            0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_33513, "mem_param_tmp_33513") !=
            0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_33512, "mem_param_tmp_33512") !=
            0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_33511, "mem_param_tmp_33511") !=
            0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_33510, "mem_param_tmp_33510") !=
            0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_33509, "mem_param_tmp_33509") !=
            0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_33508, "mem_param_tmp_33508") !=
            0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_33507, "mem_param_tmp_33507") !=
            0)
            return 1;
        if (memblock_unref(ctx, &mem_33109, "mem_33109") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_33106, "mem_33106") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_33103, "mem_33103") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_33100, "mem_33100") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_33097, "mem_33097") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_33093, "mem_33093") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_33090, "mem_33090") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_33087, "mem_33087") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_33085, "mem_param_33085") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_33080, "mem_param_33080") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_33075, "mem_param_33075") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_33070, "mem_param_33070") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_33062, "mem_param_33062") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_33057, "mem_param_33057") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_33052, "mem_param_33052") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_33047, "mem_param_33047") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_33169, "ext_mem_33169") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_33170, "ext_mem_33170") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_33171, "ext_mem_33171") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_33172, "ext_mem_33172") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_33173, "ext_mem_33173") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_33174, "ext_mem_33174") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_33175, "ext_mem_33175") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_33176, "ext_mem_33176") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_32890, "mem_32890") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_32887, "mem_32887") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_32884, "mem_32884") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_32882, "mem_32882") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_32878, "mem_32878") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_32875, "mem_32875") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_32872, "mem_32872") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_32869, "mem_32869") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_32543, "mem_32543") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_33440, "mem_param_tmp_33440") !=
            0)
            return 1;
        if (memblock_unref(ctx, &mem_param_tmp_33439, "mem_param_tmp_33439") !=
            0)
            return 1;
        if (memblock_unref(ctx, &mem_32503, "mem_32503") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_32500, "mem_32500") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_32420, "mem_param_32420") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_32415, "mem_param_32415") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_32528, "ext_mem_32528") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_32529, "ext_mem_32529") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_32381, "mem_param_32381") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_32376, "mem_param_32376") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_32371, "mem_param_32371") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_32366, "mem_param_32366") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_32361, "mem_param_32361") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_32356, "mem_param_32356") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_param_32351, "mem_param_32351") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_33304, "ext_mem_33304") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_33305, "ext_mem_33305") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_33306, "ext_mem_33306") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_33307, "ext_mem_33307") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_33308, "ext_mem_33308") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_33309, "ext_mem_33309") != 0)
            return 1;
        if (memblock_unref(ctx, &ext_mem_33310, "ext_mem_33310") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_32398, "mem_32398") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_32346, "mem_32346") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_33415, "mem_out_33415") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_33414, "mem_out_33414") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_33413, "mem_out_33413") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_33412, "mem_out_33412") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_33411, "mem_out_33411") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_33410, "mem_out_33410") != 0)
            return 1;
        if (memblock_unref(ctx, &mem_out_33409, "mem_out_33409") != 0)
            return 1;
    }
    return err;
}

int futhark_entry_main(struct futhark_context *ctx,
                       struct futhark_f32_1d **out0,
                       struct futhark_f32_1d **out1,
                       struct futhark_f32_1d **out2,
                       struct futhark_f32_1d **out3,
                       struct futhark_f32_1d **out4,
                       struct futhark_f32_1d **out5,
                       struct futhark_f32_1d **out6, const int32_t in0, const
                       float in1, const float in2, const
                       struct futhark_f32_1d *in3, const
                       struct futhark_f32_1d *in4, const
                       struct futhark_f32_1d *in5, const
                       struct futhark_f32_1d *in6, const
                       struct futhark_f32_1d *in7, const
                       struct futhark_f32_1d *in8, const
                       struct futhark_f32_1d *in9)
{
    int64_t n_29481;
    int32_t n_steps_29482;
    float epsilon_29483;
    float time_step_29484;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    
    struct memblock mem_out_33415;
    
    mem_out_33415.references = NULL;
    
    struct memblock mem_out_33414;
    
    mem_out_33414.references = NULL;
    
    struct memblock mem_out_33413;
    
    mem_out_33413.references = NULL;
    
    struct memblock mem_out_33412;
    
    mem_out_33412.references = NULL;
    
    struct memblock mem_out_33411;
    
    mem_out_33411.references = NULL;
    
    struct memblock mem_out_33410;
    
    mem_out_33410.references = NULL;
    
    struct memblock mem_out_33409;
    
    mem_out_33409.references = NULL;
    
    struct memblock zzvs_mem_32343;
    
    zzvs_mem_32343.references = NULL;
    
    struct memblock yvs_mem_32342;
    
    yvs_mem_32342.references = NULL;
    
    struct memblock xvs_mem_32341;
    
    xvs_mem_32341.references = NULL;
    
    struct memblock ms_mem_32340;
    
    ms_mem_32340.references = NULL;
    
    struct memblock zzps_mem_32339;
    
    zzps_mem_32339.references = NULL;
    
    struct memblock yps_mem_32338;
    
    yps_mem_32338.references = NULL;
    
    struct memblock xps_mem_32337;
    
    xps_mem_32337.references = NULL;
    n_steps_29482 = in0;
    epsilon_29483 = in1;
    time_step_29484 = in2;
    xps_mem_32337 = in3->mem;
    n_29481 = in3->shape[0];
    yps_mem_32338 = in4->mem;
    n_29481 = in4->shape[0];
    zzps_mem_32339 = in5->mem;
    n_29481 = in5->shape[0];
    ms_mem_32340 = in6->mem;
    n_29481 = in6->shape[0];
    xvs_mem_32341 = in7->mem;
    n_29481 = in7->shape[0];
    yvs_mem_32342 = in8->mem;
    n_29481 = in8->shape[0];
    zzvs_mem_32343 = in9->mem;
    n_29481 = in9->shape[0];
    if (!(n_29481 == in3->shape[0] && (n_29481 == in4->shape[0] && (n_29481 ==
                                                                    in5->shape[0] &&
                                                                    (n_29481 ==
                                                                     in6->shape[0] &&
                                                                     (n_29481 ==
                                                                      in7->shape[0] &&
                                                                      (n_29481 ==
                                                                       in8->shape[0] &&
                                                                       n_29481 ==
                                                                       in9->shape[0]))))))) {
        ret = 1;
        if (!ctx->error)
            ctx->error =
                msgprintf("Error: entry point arguments have invalid sizes.\n");
    }
    if (ret == 0) {
        ret = futrts_entry_main(ctx, &mem_out_33409, &mem_out_33410,
                                &mem_out_33411, &mem_out_33412, &mem_out_33413,
                                &mem_out_33414, &mem_out_33415, xps_mem_32337,
                                yps_mem_32338, zzps_mem_32339, ms_mem_32340,
                                xvs_mem_32341, yvs_mem_32342, zzvs_mem_32343,
                                n_29481, n_steps_29482, epsilon_29483,
                                time_step_29484);
        if (ret == 0) {
            assert((*out0 =
                    (struct futhark_f32_1d *) malloc(sizeof(struct futhark_f32_1d))) !=
                NULL);
            (*out0)->mem = mem_out_33409;
            (*out0)->shape[0] = n_29481;
            assert((*out1 =
                    (struct futhark_f32_1d *) malloc(sizeof(struct futhark_f32_1d))) !=
                NULL);
            (*out1)->mem = mem_out_33410;
            (*out1)->shape[0] = n_29481;
            assert((*out2 =
                    (struct futhark_f32_1d *) malloc(sizeof(struct futhark_f32_1d))) !=
                NULL);
            (*out2)->mem = mem_out_33411;
            (*out2)->shape[0] = n_29481;
            assert((*out3 =
                    (struct futhark_f32_1d *) malloc(sizeof(struct futhark_f32_1d))) !=
                NULL);
            (*out3)->mem = mem_out_33412;
            (*out3)->shape[0] = n_29481;
            assert((*out4 =
                    (struct futhark_f32_1d *) malloc(sizeof(struct futhark_f32_1d))) !=
                NULL);
            (*out4)->mem = mem_out_33413;
            (*out4)->shape[0] = n_29481;
            assert((*out5 =
                    (struct futhark_f32_1d *) malloc(sizeof(struct futhark_f32_1d))) !=
                NULL);
            (*out5)->mem = mem_out_33414;
            (*out5)->shape[0] = n_29481;
            assert((*out6 =
                    (struct futhark_f32_1d *) malloc(sizeof(struct futhark_f32_1d))) !=
                NULL);
            (*out6)->mem = mem_out_33415;
            (*out6)->shape[0] = n_29481;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
  
